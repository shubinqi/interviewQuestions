<!--
 * @Author: Shu Binqi
 * @Date: 2023-02-28 03:11:14
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-03 18:00:32
 * @Description: 前端工程化
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\Module\前端工程化.md
-->

#### 前端工程化是什么？

前端工程化是一种将软件工程方法和思想应用到前端开发中的方法，旨在提高前端开发效率，降低开发成本，保障代码质量和服务稳定性。具体来说，前端工程化包括一系列规范、流程和工具，如模块化、组件化、规范化和自动化等方面。下面将从以下几个方面介绍如何实现前端工程化：

1. **前后端分工明确**：前端工程师主要负责静态资源和动态资源的处理、JavaScript 实现前端业务逻辑、HTML 模板文件的产出等任务。前后端分离是实现前端各种优化方案的基础。
2. **模块化**：模块化的职责在于模块管理和资源加载。常用的工具有 Node.js、npm、webpack、parcel、rollup 等。其中，webpack 是前端工程化中最常用的模块化解决方案之一，它可以将代码打包为模块，实现代码的分离和管理。
3. **组件化**：组件化是前端工程化中的重要组成部分，它自由、灵活、可复用，大大提高了开发效率。微信小程序的目录结构应用了组件化的思想。
4. **规范化**：规范化是前端工程化中不可或缺的一部分，它可以通过一些工具来实现，如 ESLint、stylelint 等。ESLint 是一个可插拔的 JavaScript 代码检查工具，它可以检查 JavaScript 代码中的语法错误和潜在问题，还可以对代码进行格式化和修复。
5. **自动化**：自动化阶段包括构建、测试和部署三个阶段。自动化构建工具有 grunt、gulp 等，它们可以对文件进行压缩、校验、资源合并等处理方式。
6. **性能监控**：性能监控是前端工程化中的重要环节之一，它可以通过 Performance 接口来获取当前页面与性能相关的信息。例如，可以通过 Performance 接口获取重定向耗时、DOM 渲染耗时、页面加载耗时、请求耗时等信息。同时，可以通过 performance.timing 来获取页面性能信息，并通过自定义函数来收集性能信息，例如获取资源信息等。

#### 怎么实现前端工程化？

1. **规范化开发流程和代码风格**：
   - 使用一致的代码开发规范，例如使用 Eslint 监测代码规范、使用 Prettier 自动化格式代码、使用 Git Commit Hooks 拒绝不符合规范的代码提交、使用流水线检测出不规范代码，并拒绝合入主干分支，拒绝进入发布流程。
   - 制定合适的代码流程规范，例如关联需求单/bug 单的分支命名、检查代码是否符合规范、进行 Code Review、自动化构建和测试代码、灰度发布代码等。
2. **自动化工具**：
   - 使用自动化工具确保流程正常进行，例如使用 CI/CD。
   - 面向 JS 的压缩工具，例如 UglifyJSWebpackPlugin 和 TerserWebpackPlugin。
   - 面向 CSS 的压缩工具，例如 OptimizeCssAssetsPlugin、OptimizeCssNanoPlugin 和 CSSMinimizerWebpackPlugin。
   - 在构建打包过程中，移除那些引入但未被使用的无效代码，例如使用 Tree Shaking。
3. **考虑多人协作和团队规模**：
   - 完善规范，尽量使用工具保证规范进行。
   - 合入代码前进行 Code Review，遇到分歧时可通过投票解决。
4. **考虑运行环境**：
   - 在编写代码时要考虑运行环境，例如使用 retrolambda、streamSupport 和 ThreeThen 进行转换。
   - 在编译时指定编译到特定版本的 class 文件。
5. **测试**：
   - 测试是前端工程化建设必不可少的一部分，它的作用是找出 bug，越早发现 bug，所需要付出的成本就越低。并且，它更重要的作用是在将来，而不是当下。

#### 什么是前端模块化？

前端模块化是一种管理和组织前端代码的方式，它将一个大的程序拆分成互相依赖的小文件，再用简单的方法拼装起来，以便更好地维护和管理代码。前端模块化可以使前端代码更加可重用、可维护和可扩展。在不同的模块化规范中，有不同的方式来定义和使用模块，如 CommonJS，AMD，CMD 和 ES6 模块系统。以下是一些有关前端模块化的重要概念和规范：

- CommonJS 规范：CommonJS 规范应用于 nodejs 应用中，在 nodejs 应用中每个文件就是一个模块，拥有自己的作用域，文件中的变量、函数都是私有的，与其他文件相隔离。CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。
- AMD 和 CMD 规范：AMD 和 CMD 是为了解决浏览器异步加载模块而诞生的方案，其中 AMD 由 require.js 驱动，CMD 由 sea.js 驱动。这些规范的主要目的是为了在浏览器中异步加载模块，以提高应用程序的性能。但随着打包工具的发展，commonjs 和 ES6 都可以在浏览器上运行了，因此 AMD 和 CMD 将逐渐被替代。
- ES6 模块系统：在 ES6 中，模块是一种特殊的文件类型，它使用 import 和 export 关键字来定义和使用模块。ES6 模块系统是一种新的模块化标准，可以在浏览器和 nodejs 中使用，它的主要优点是在语言层面上提供了对模块的支持，可以在编译时进行静态分析，从而提高应用程序的性能和可维护性。

模块化开发的优点：模块化开发可以使前端代码更加可重用、可维护和可扩展，具体优点包括：

- 提高代码的可读性和可维护性：将代码拆分成小的模块可以使代码更加清晰、易读，便于维护和修改。
- 减少命名冲突：模块化可以避免全局命名冲突，每个模块都有自己的作用域，变量和函数不会与其他模块的变量和函数发生冲突。
- 提高代码的可重用性：模块化可以将代码拆分成小的模块，

#### 模块化发展历程？

JavaScript 的模块化发展历程可以分为以下阶段：

1. **无模块化阶段**：最开始的 JavaScript 并没有提供模块化机制，开发者将所有 JS 文件放在一起，按照文件顺序执行，这会导致全局作用域污染、命名冲突等问题。
2. **IIFE 阶段**：为了解决全局作用域污染和命名冲突等问题，开发者使用立即执行函数（Immediately Invoked Function Expression，IIFE）来封装代码，将代码块放进函数作用域中，达到模块化的目的。
3. **CommonJS 阶段**：2009 年，Ryan Dahl 创造了 Node.js 项目，将 JavaScript 语言用于服务器端编程，这标志着 JavaScript 模块化编程正式诞生。Node.js 的模块系统参照了 CommonJS 规范，一般在服务端（Node.js）中用来同步加载模块，每个文件都可以是一个模块，它对于模块的依赖发生在代码运行阶段。CommonJS 规范被广泛应用于 Node.js 的模块系统和 webpack 等构建工具中。
4. **AMD 阶段**：由于 CommonJS 规范是同步加载模块，因此在浏览器端应用时需要借助 webpack 等构建工具提前编译打包处理。为了解决这个问题，RequireJS 团队提出了异步模块定义（Asynchronous Module Definition，AMD）规范，支持异步加载模块，适用于浏览器端应用。
5. **CMD 阶段**：CMD 是 SeaJS 团队提出的模块化规范，与 AMD 类似，支持异步加载模块，但是与 AMD 不同的是，CMD 推崇就近依赖，只有在需要时才会加载依赖的模块。
6. **UMD 阶段**：UMD（Universal Module Definition）是 AMD 和 CommonJS 的结合体，保证模块可以被 AMD 和 CommonJS 调用。
7. **ESModule 阶段**：JavaScript 在 ES6 时原生提供了 import 和 export 模块化机制（ESModule），可以在浏览器和 Node.js 等环境中直接使用，无需借助构建工具。ESModule 支持静态分析，可以在编译时确定模块依赖关系，提高性能。
8. **动态导入阶段**：ES10 引入了动态导入（Dynamic Import）语法，可以在运行时动态地加载模块，提高了模块化的灵活性和可扩展性。

#### 有哪些模块化规范？

在 JavaScript 中，有多种模块化规范。下面是一些常见的模块化规范：

1. **CommonJS**：是一种在服务器端使用的模块化规范，可以在 node.js 中使用。它规定每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。它采用同步加载方式，只有加载完成，才能执行后面的操作。在 CommonJS 中，使用 module.exports 或 exports 导出模块，使用 require 引入模块。
1. **AMD（Asynchronous Module Definition）**：是一种在浏览器端使用的模块化规范。与 CommonJS 不同，AMD 是异步加载模块，可以指定回调函数。在 AMD 中，使用 define 定义模块，通过依赖数组声明模块需要的依赖。在回调函数中，定义模块的行为，并通过 exports 导出模块。在引入模块时，使用 require 方法。
1. **CMD（Common Module Definition）**：也是一种在浏览器端使用的模块化规范。与 AMD 不同，CMD 遵循依赖就近原则。在 CMD 中，不需要在依赖数组里声明模块需要的依赖，只需要在具体代码逻辑内，把需要使用的模块 require 进来就可以了。在 CMD 中，使用 define 定义模块，通过 exports 导出模块，在引入模块时，使用 require 方法。
1. **ES6 Module**：是 js 语言层面的模块化规范。与 CommonJS 和 AMD 最大的区别在于，ES6 Module 是由 JS 解释器实现，而后两者是在运行环境中运行时实现。在 ES6 Module 中，使用 export 导出模块，使用 import 引入模块。ES6 Module 是在编译时就确定依赖关系，所有的加载都是引用，这样做的好处是可以执行静态分析和类型检查。Tree-Shaking 就是通过 ES6 Module 的 import 来进行静态分析，并且只支持 ES6 Module 模块的使用。在浏览器中，可以在 script 标签中添加 type="module" 属性来使用 ES6 Module。

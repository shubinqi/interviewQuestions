<!--
 * @Author: Shu Binqi
 * @Date: 2023-02-24 21:06:32
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-10 18:29:37
 * @Description: HTTP 面试题（35题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\计算机网络\HTTP.md
-->

#### Get 和 Post 请求的区别？

GET 和 POST 请求的区别是：

1. GET 请求一般用于获取数据，而 POST 请求一般用于提交数据。
2. GET 请求的参数会放在 URL 中，因此隐私性和安全性较差，请求的数据长度也有限制，不同浏览器和服务器的限制不同，一般在 2~8K 之间，较常见的是 1K 以内。而 POST 请求没有长度限制，请求数据放在请求体中。
3. GET 请求刷新服务器或回退不会有影响，而 POST 请求回退时会重新提交数据请求。
4. GET 请求可以被缓存，而 POST 请求不会被缓存。
5. GET 请求会被保存在浏览器的历史记录中，而 POST 不会。GET 请求可以被收藏为书签，因为参数就是 URL 中，但 POST 不行，因为参数不在 URL 中。
6. GET 请求用于从服务器上获取资源，而 POST 请求用于向服务器发送修改请求，进行数据的修改。
7. GET 请求的数据会暴露在地址栏中，而 POST 请求则不会。
8. GET 请求可以对请求的数据进行缓存，而 POST 请求不行，因为 POST 请求不能缓存，否则会导致数据的更新问题。
9. GET 请求包含的参数较少，因此在传输过程中比 POST 请求快，而 POST 请求包含的请求头较多，因此会比 GET 请求慢。

#### Get 方法 URL 长度限制的原因？

Http Get 方法提交的数据大小长度并没有限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。

如：IE 对 URL 长度的限制是 2083 字节(2K+35)。

由于 IE 浏览器对 URL 长度的允许值是最小的，所以网站开发中，只要 URL 不超过 2083 字节，那么在所有浏览器中工作都不会有问题。
GET 的长度值 = URL（2083）- （你的 Domain+Path）-2（2 是 get 请求中?=两个字符的长度）

下面就是对各种浏览器和服务器的最大处理能力做一些说明.

1. **Microsoft Internet Explorer (Browser)**：IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应。
1. **Firefox (Browser)**：对于 Firefox 浏览器 URL 的长度限制为 65,536 个字符。
1. **Safari (Browser)**：URL 最大长度限制为 80,000 个字符。
1. **Opera (Browser)**：URL 最大长度限制为 190,000 个字符。
1. **Google (chrome)**：URL 最大长度限制为 8182 个字符。
1. **Apache (Server)** server 端：能接受最大 url 长度为 8,192 个字符。
1. **Microsoft Internet Information Server(IIS)** server 端：能接受最大 url 的长度为 16,384 个字符。

#### 常见的 HTTP 请求方法？

HTTP 请求方法是指在 HTTP 协议中，客户端向服务器请求资源时所采用的方法，常见的 HTTP 请求方法有以下几种：

- **GET**：用于请求指定的资源。GET 请求只用于获取数据，不会对数据进行修改，请求参数会附在 URL 之后，例如：http://example.com/index.html?param1=value1&param2=value2。
- **POST**：向指定资源提交数据，请求参数在请求正文中，POST 请求会对数据进行修改，例如：表单提交。
- **PUT**：用于更新指定资源，客户端需要发送更新后的整个资源，如果只需要更新部分内容，可以使用 PATCH 请求。
- **DELETE**：删除指定的资源。
- **HEAD**：与 GET 请求类似，但是服务器在响应中只返回头信息，不返回实体的主体部分，用于获取资源的元数据。
- **OPTIONS**：用于获取目标资源所支持的通信选项，可以查询服务器支持哪些 HTTP 方法。
- **TRACE**：回显服务器收到的请求，主要用于测试或诊断。
- **PATCH**：用于对资源进行部分修改。

在符合 RESTful 设计规范的应用中，常用到的 HTTP 请求方法有：

- **GET**：用于获取资源。
- **POST**：用于创建资源。
- **PUT**：用于更新资源。
- **DELETE**：用于删除资源。
- **PATCH**：用于对资源进行部分修改。

需要注意的是，HTTP 请求方法的语义是约定的，虽然可以自定义请求方法，但是不符合 HTTP 协议规范，可能会产生不可预料的结果。

#### OPTIONS 请求方法是什么？使用场景？

HTTP 的 OPTIONS 方法用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站使用该方法。在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断是否接受接下来的实际请求。服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。

除了用于 CORS 的预检请求，OPTIONS 方法还可以用于以下场景：

- 确定服务器支持哪些 HTTP 方法；
- 确定服务器支持哪些请求头；
- 获取服务器支持的 MIME 类型。

在 .NET Core 中，可以使用 IOptions&lt;TOptions&gt; 接口和 Options 模式来读取相关配置值。Options 模式使用类来提供强类型的访问方式，可以通过将配置设置隔离到不同的类中来实现接口隔离原则和关注点分离原则。Options 还提供了一种验证配置数据的机制。可以使用 IOptionsSnapshot&lt;TOptions&gt; 接口来获取配置文件中的配置值，且这些值会在请求时计算一次，并在请求的生命周期内缓存。IOptionsMonitor 是一个单例服务，可以在任何时候检索当前选项值，特别适用于单例依赖项。IOptionsSnapshot 是一个作用域服务，提供在构建 IOptionsSnapshot&lt;T&gt; 对象时的选项快照。选项快照适用于短暂和作用域依赖项。

#### 了解哪些 HTTP 状态码？

HTTP（Hypertext Transfer Protocol）是一种广泛使用的协议，用于在 Web 浏览器和 Web 服务器之间传输数据。HTTP 使用状态码来表示请求的结果。

状态码的分类：

1. **1xx：信息状态码**，表示服务器已接受请求，需要请求者继续执行操作。
1. **2xx：成功状态码**，表示请求已成功被服务器接收、理解、并接受。
1. **3xx：重定向状态码**，表示客户端需要采取进一步的操作才能完成请求。
1. **4xx：客户端错误状态码**，表示客户端的请求有误。
1. **5xx：服务器错误状态码**，表示服务器在处理请求时发生了错误。

其中，2xx 和 3xx 状态码代表成功请求，4xx 和 5xx 状态码代表请求失败。根据状态码，客户端可以得知请求是否成功，以及请求失败的原因，并进行相应的处理。

以下是一些常见的 HTTP 状态码：

- **200 OK**：请求成功，服务器已经成功返回页面。
- **201 Created**：请求成功，服务器已经成功创建新的资源。
- **204 No Content**：请求成功，但没有返回任何内容。
- **301 Moved Permanently**：被请求的页面已经永久移动到新的位置，客户端应该使用新的 URI 重新请求。
- **302 Found**：被请求的页面已经暂时移动到新的位置，客户端应该在将来的请求中使用这个相同的 URI。
- **304 Not Modified**：请求的页面没有被修改，可以使用缓存的版本。
- **400 Bad Request**：请求失败，服务器无法理解请求。
- **401 Unauthorized**：请求失败，客户端没有提供身份验证信息。
- **403 Forbidden**：请求失败，客户端没有权限访问所请求的页面。
- **404 Not Found**：请求失败，所请求的页面不存在。
- **405 Method Not Allowed**：请求失败，请求中使用的 HTTP 方法不被服务器支持。
- **408 Request Timeout**：请求超时，服务器没有及时响应。
- **429 Too Many Requests**：请求过多，服务器拒绝处理请求。
- **500 Internal Server Error**：请求失败，服务器遇到了一个错误。
- **503 Service Unavailable**：请求失败，服务器暂时无法处理请求。

#### 返回 301、403、502 状态码是什么是意思？

常见的 HTTP 状态码中，301、402、502 分别表示以下含义：

1. **301 Moved Permanently**：表示所请求的资源被永久移动到了新的位置，客户端应该使用新的地址重新发送请求。这个状态码一般用于网站 URL 的重定向。
1. **403 Forbidden**：请求失败，客户端没有权限访问所请求的页面。
1. **502 Bad Gateway**：表示服务器作为网关或代理角色时无法从上游服务器或其他资源获得响应，一般是上游服务器或其他资源无响应或者响应超时引起的。这个状态码一般用于反向代理场景。

在实际的开发过程中，开发者需要熟悉常见的 HTTP 状态码，了解各种状态码的含义和使用场景，以便能够更好地处理 HTTP 请求和响应。

#### 同样是重定向，301，302，303，307 的区别？

301、302、303、307 都是 HTTP 重定向状态码，它们的区别如下：

1. **301 Moved Permanently**: 永久性重定向。请求的资源已经被分配了新的 URL，以后应该使用新的 URL。搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。
1. **302 Found**: 临时性重定向。请求的资源已经被分配了新的 URL，希望用户本次使用新的 URL 访问。由于是临时性重定向，搜索引擎会继续保留旧的网址。
1. **303 See Other**: 临时性重定向。与 302 有相同的功能，但是 303 明确要求客户端必须使用 GET 方法获取新的资源。
1. **307 Temporary Redirect**: 临时性重定向。与 302 相同，只是强制要求使用相同的 HTTP 方法。

需要注意的是，301、302、303、307 是 HTTP/1.0 和 HTTP/1.1 中的状态码，HTTP/2 中使用了相应的对应方式，301 对应 308，302 对应 307，303 对应 303，307 对应 307。

#### HTTP 状态码 304 是多好还是少好？

HTTP 状态码 304 表示 Not Modified，服务器检测到客户端发送的请求的资源未被修改过，因此直接返回客户端缓存的资源，客户端直接使用缓存，不需要再次请求服务器。这可以减轻服务器的压力，提高页面加载速度，因此频繁使用 304 状态码是比较好的。

当客户端使用缓存的资源时，请求的数据量也减少了，可以减少用户流量消耗，对用户也是有利的。但是，如果缓存的过期时间设置过长，可能导致客户端无法获取到更新的资源，从而出现显示错误等问题，因此需要根据具体情况进行合理的设置。

#### 介绍下 304 过程？

HTTP 状态码 304 过程

当客户端第一次请求一个资源时，服务器会将资源返回给客户端，并在响应头中添加一个 Etag 标识符。客户端再次请求该资源时，在请求头中添加 If-None-Match 字段，值为上次请求中服务器返回的 Etag 标识符。服务器在接收到该请求后，会与当前资源的 Etag 进行比较，如果相同，则返回状态码 304，告诉客户端可以直接使用缓存中的资源。

解决 HTTP 状态码 304 的问题

当发现服务器返回 304 状态码时，需要分析导致返回 304 状态码的原因，并制定具体的解决方案，才能快速解决 304 状态码的问题。从分析总结中可以看出，导致返回 304 状态码的原因主要有以下三点：

- **页面更新周期长或不更新**：如果页面内容更新周期长甚至不更新，静态页面基本都是直接返回 304 状态码，即便是动态页面也会因为内容不变出现返回 304 状态码的问题。
- **CDN 缓存未同步更新**：当网站页面内容更新后，设置的 CDN 缓存没有同步更新时，也会出现返回 304 状态码的情况。
- **纯静态页面或强制静态 html 生成**：如果网站有大量的纯静态页面，或者强制生成静态 html，就会出现客户端请求时、服务器返回 304 状态码的情况。

针对不同的原因，需要采取不同的解决方案，例如：

- **页面更新周期长或不更新**：可以考虑增加页面内容的更新频率，或者使用 CDN 缓存等方式来提高网页加载速度。
- **CDN 缓存未同步更新**：可以手动清除 CDN 缓存，或者使用 CDN 的缓存刷新功能来解决问题。
- **纯静态页面或强制静态 html 生成**：可以采用动态生成页面的方式，或者使用缓存技术来提高网页加载速度。

#### 常见的 HTTP 请求头和响应头？

常见的 HTTP 请求头包括：

- **Accept**：指定客户端能够接收的内容类型。例如，Accept: text/html 表示客户端可以接受 HTML 内容。
- **Accept-Charset**：指定客户端能够接受的字符集。例如，Accept-Charset: utf-8 表示客户端能够接受 UTF-8 编码的字符集。
- **Accept-Encoding**：指定客户端能够接受的内容编码。例如，Accept-Encoding: gzip 表示客户端能够接受 GZIP 压缩的内容。
- **Accept-Language**：指定客户端能够接受的语言。例如，Accept-Language: en-US 表示客户端能够接受美国英语。
- **Host**：指定客户端要连接的主机和端口号。例如，Host: www.example.com 表示客户端要连接到www.example.com网站。
- **User-Agent**：指定客户端使用的用户代理。例如，User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3 表示客户端使用的是 Chrome 浏览器。
- **Referer**：指定客户端从哪个地址跳转到当前页面。例如，Referer: http://www.example.com 表示客户端从www.example.com跳转到当前页面。
- **Authorization**：指定客户端使用的授权凭证。例如，Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== 表示客户端使用基本身份验证方式，并提供用户名和密码。
- **Cookie**：指定客户端发送的 Cookie 数据。例如，Cookie: name=value 表示客户端要发送名为 name，值为 value 的 Cookie 数据。
- **If-Modified-Since**：指定客户端缓存的资源的最后修改时间。例如，If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT 表示客户端缓存的资源最后修改时间为 2000 年 7 月 11 日 18:23:51。

常见的 HTTP 响应头包括：

- **Content-Type**：指定响应的内容类型。例如，Content-Type: text/html 表示响应的内容是 HTML。
- **Content-Length**：指定响应的内容长度。例如，Content-Length: 1024 表示响应的内容长度为 1024 字节。
- **Content-Encoding**：指定响应的内容编码。例如，Content-Encoding: gzip 表示响应的内容经过了 GZIP 压缩。
- **Content-Language**：指定响应的语言。例如，Content-Language: en-US 表示响应的语言是美国英语。
- **Cache-Control**: 控制缓存的行为，例如 no-cache、max-age=3600 等。
- **Expires**: 指定 HTTP 响应的过期时间，以 GMT 时间格式表示。
- **Last-Modified**: 指定 HTTP 响应内容的最后修改时间，以 GMT 时间格式表示。
- **ETag**: 指定 HTTP 响应内容的实体标识符，用于缓存验证。
- **Location**: 用于重定向，指定 HTTP 响应应该跳转到的 URL。
- **Set-Cookie**：指定要在客户端设置的 Cookie 数据。例如，Set-Cookie: name=value 表示要在客户端设置名为 name，值为 value 的 Cookie 数据。
- **Access-Control-Allow-Origin**: 用于跨域请求，指定允许访问该资源的域名。
- **Accept-Ranges**: 用于支持范围请求，指定支持的单位，例如 bytes。

#### 什么是 HTTPS 协议？和 HTTP 协议的区别？

HTTP（超文本传输协议）和 HTTPS（超文本传输安全协议）都是一种用于分布式、协作式和超媒体信息系统的应用层协议。其中，HTTPS 是一种透过计算机网络进行安全通信的传输协议，经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包，提供对网站服务器的身份认证，保护交换数据的隐私与完整性，因此 HTTPS 比 HTTP 更加安全。

下面是 HTTP 和 HTTPS 的区别：

- **安全性不同**：HTTPS 的通信过程是经过加密的，而 HTTP 则不加密。HTTPS 通信过程中使用 SSL/TLS 协议加密，保证了数据传输的安全性，而 HTTP 没有加密，数据传输过程不安全。
- **网站申请流程不同**：使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构）申请证书，一般免费证书很少，需要交费，Web 服务器启用 SSL 需要获得一个服务器证书并将该证书与要使用 SSL 的服务器绑定，而 HTTP 则不需要证书。
- **默认端口不同**：HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。当浏览器请求 HTTP 网站的时候，会默认连接到 80 端口上，而 HTTPS 则会默认连接到 443 端口上。
- **传输速度不同**：HTTP 的传输速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，所以一共是 12 个包。HTTPS 比 HTTP 更加耗费服务器资源。
- **安全警告不同**：当你使用浏览器访问一个 HTTP 网站的时候，你会发现浏览器会对该 HTTP 网站显示“不安全”的安全警告，提示用户当前所访问的网站可能会存在风险。而假如你访问的是一个 HTTPS 网站时，情况却是完全不一样。你会发现浏览器的地址栏会变成绿色，企业名称会展示在地址栏中，地址栏上面还会出现一把“安全锁”的图标。这些都会给予用户很大的视觉上的安全体验。

#### HTTPS 是如何保证安全的？

HTTPS（HyperText Transfer Protocol Secure）是在传输层基础上对 HTTP 协议的安全加强，主要通过以下方式来保证数据的安全：

1. **SSL/TLS 协议**：HTTPS 采用 SSL/TLS 协议来对传输的数据进行加密，防止被窃听、篡改或者伪造。TLS 目前的最新版本是 TLS 1.3。
1. **数字证书**：为了验证服务器的身份和防止中间人攻击，服务器需要使用数字证书。数字证书包含了一些基本信息，如证书颁发机构、证书有效期、服务器公钥等。浏览器使用数字证书验证服务器的身份，并根据证书中的公钥来进行数据的加密。
1. **对称加密和非对称加密**：HTTPS 采用对称加密和非对称加密相结合的方式来对数据进行加密。首先使用非对称加密算法进行身份认证和密钥协商，然后使用对称加密算法对数据进行加密。因为对称加密算法的运算速度较快，所以在传输数据时使用对称加密算法可以提高传输效率。
1. **HTTPS 证书的过期和吊销**：HTTPS 证书会设置有效期，一般为 1 年或 2 年，过期后需要重新申请。如果证书被攻击者盗用，证书的发行机构可以吊销证书，从而避免攻击者继续使用该证书进行攻击。

总之，HTTPS 通过加密、身份验证和完整性校验等方式来保证数据的安全传输。但是也要注意，HTTPS 并不能完全防止所有的攻击，例如中间人攻击、恶意软件、社会工程学等攻击方式仍然存在风险。因此，在开发过程中，还需要采取一些额外的安全措施来保护应用程序和用户的安全。

#### 对称加密算法和非对称加密算法区别是什么？

非对称加密算法和对称加密算法的区别如下：

1. 对称加密算法使用相同的密钥进行加密和解密，加密和解密的速度较快，但是密钥的传输安全性较低；而非对称加密算法使用一对公钥和私钥进行加密和解密，密钥的传输安全性较高，但是加密和解密的速度较慢。
1. 对称加密算法的密钥长度通常较短，一般为 128 位或 256 位，而非对称加密算法的密钥长度一般为 1024 位或 2048 位，甚至更长。
1. 对称加密算法适用于对大量数据进行加密和解密，而非对称加密算法适用于对少量数据进行加密和解密，例如密码、证书等。
1. 对称加密算法的密钥只有一份，加密和解密都需要使用这个密钥，因此密钥的管理较为困难；而非对称加密算法的公钥和私钥是一对，公钥可以随意分发，私钥只由拥有者掌握，因此密钥的管理较为容易。

总的来说，非对称加密算法相对于对称加密算法更加安全，但是加密和解密的速度较慢，适用于对少量数据进行加密和解密。而对称加密算法则适用于对大量数据进行加密和解密。在实际应用中，通常采用非对称加密算法和对称加密算法结合的方式，既保证了安全性，又提高了加密和解密的效率。

#### 介绍下 SSL 和 TLS？TLS/SSL 的工作原理？

SSL（Secure Sockets Layer，安全套接字层）和 TLS（Transport Layer Security，传输层安全）是用于保护网络通信安全的协议。SSL 是在 Netscape 公司开发的基础上发展起来的，后来被 TLS 所取代，TLS 是 SSL 的继承者。它们的工作原理类似，都是通过数字证书来建立安全连接，但 TLS 是 SSL 的升级版，具有更高的安全性。

SSL 和 TLS 的工作原理如下：

1. 客户端发送连接请求给服务器端，请求建立 SSL/TLS 连接。
1. 服务器端返回数字证书（包含公钥），并要求客户端验证证书的有效性。数字证书由证书颁发机构（CA）颁发，用于证明服务器的身份。
1. 客户端使用预装的根证书验证服务器端的数字证书的有效性。如果证书有效，客户端会生成一个随机的对称密钥，使用服务器端的公钥加密这个密钥，然后将加密后的密钥发送给服务器端。
1. 服务器端使用自己的私钥解密客户端发来的密钥，然后使用对称密钥来加密通信内容。
1. 客户端接收到加密的通信内容后，使用对称密钥解密内容。

在整个过程中，SSL/TLS 协议会对通信过程中的数据进行加密、解密和验证等操作，确保通信内容不被篡改、窃听和伪造。

#### HTTP 不同版本的区别？

HTTP（超文本传输协议）是一种在 Web 世界中用于传输数据的应用层协议。HTTP 有多个版本，主要包括 HTTP/0.9、HTTP/1.0、HTTP/1.1、HTTP/2 和 HTTP/3。这些版本之间有很多区别，下面将对这些版本的区别进行简单介绍：

1. **HTTP/0.9**：是 HTTP 的第一个版本，于 1991 年发布，只支持 GET 方法，没有头部信息和状态码，数据传输采用纯文本方式。
1. **HTTP/1.0**：于 1996 年发布，支持多种请求方法，引入了头部信息、状态码、缓存等概念，并且支持基本的安全机制，如通过 HTTPS 进行加密通信。
1. **HTTP/1.1**：于 1999 年发布，是 HTTP 的主流版本，引入了持久连接（keep-alive）、分块传输编码（chunked）、管道化请求（pipelining）等功能，显著提高了网络传输效率。
1. **HTTP/2**：于 2015 年发布，是 HTTP 的最新版本，采用二进制格式传输数据，支持多路复用（multiplexing）、头部压缩（header compression）、服务器推送（server push）等功能，进一步提高了网络传输效率。
1. **HTTP/3**：于 2020 年发布，是基于 QUIC 协议的 HTTP 版本，采用 UDP 协议进行数据传输，解决了 TCP 协议的拥塞控制和队头阻塞等问题，提高了网络传输效率。

#### HTTP 2.0 解决了什么问题？

HTTP/2.0 相较于 HTTP/1.x，主要解决了以下几个问题：

1. **二进制传输**：HTTP/1.x 采用文本格式传输数据，而 HTTP/2.0 使用二进制格式，可更高效地传输数据。
1. **队头阻塞**：HTTP/1.x 的请求-响应模式是串行的，也就是说同一时间只能处理一个请求，因此必须等待上一个请求响应完成才能发送下一个请求。而 HTTP/2.0 的多路复用可以同时发送多个请求，并通过二进制帧将一个连接分成多个流，每个流可以独立地双向通信，从而大大提高了并发性能。
1. **头部压缩**：HTTP/2.0 使用 HPACK 算法对头部信息进行压缩，减少了传输的数据量。
1. **服务器推送**：HTTP/2.0 可以让服务器在客户端需要请求时提前推送响应内容，从而加快了网页加载速度。

综上所述，HTTP/2.0 主要解决了 HTTP/1.x 中存在的性能瓶颈和效率问题，从而提高了网络性能和用户体验。

#### HTTP 3.0 解决了什么问题？

HTTP/3.0 是基于 QUIC 协议的新一代 HTTP 协议，主要解决的问题包括：

1. **传输效率**：HTTP/3.0 基于 QUIC 协议，使用 UDP 而非 TCP 作为传输层协议，同时支持多路复用、0-RTT 和头部压缩等技术，能够大幅提升传输效率，缩短页面加载时间。
1. **安全性**：HTTP/3.0 通过使用 QUIC 协议内置的加密机制，解决了 HTTP/2.0 中明文传输的问题，能够有效地提高通信安全性。
1. **连接稳定性**：HTTP/3.0 支持连接迁移，当客户端切换网络环境时可以快速恢复连接，减少连接中断的时间，提升连接稳定性。

总的来说，HTTP/3.0 的出现主要是为了解决 HTTP/2.0 存在的一些问题，并提升传输效率和安全性。

#### 什么是队头堵塞？如何解决队头阻塞？

队头阻塞是指在 HTTP/1.1 中，如果某个请求占用了连接的带宽，在其响应之前，后续的所有请求都必须等待，造成了阻塞的效果。

队头阻塞的解决方案如下：

- **舍弃 TCP 协议**：想要在应用程序中避免 TCP 队头阻塞带来的影响，只有舍弃 TCP 协议。比如，Google 推出的 QUIC 协议，在某种程度上可以说避免了 TCP 中的队头阻塞，因为它根本不使用 TCP 协议，而是在 UDP 协议的基础上实现了可靠传输。而 UDP 是面向数据报的协议，数据报之间不会有阻塞约束。
- **使用 SCTP 协议**：SCTP 是流控制传输协议，它是和 TCP、UDP 在同一层次的传输协议。SCTP 的多流特性也可以尽可能地避免队头阻塞的情况。
- **HTTP/2 多路复用**：HTTP/2 的多路复用解决了 HTTP 级别的队头阻塞，但是在网络模型中还需要考虑其他层的影响，比如安全层的 TLS 和传输层的 TCP。这些协议中的每一层都用一些元数据包装来自其上一层的数据。在 HTTP(S)数据中预先加上 TCP 包头，然后将其放入 IP 包等，这样就可以在协议之间实现相对简洁的分离。
- **QUIC 协议**：QUIC 协议是基于 UDP 的传输层协议，它最显著的改变包括以下几个方面：把复用移到了传输层，简化 HTTP，直接将连接复用机制放置在 QUIC 协议内来处理，简化了 HTTP 层面，使用新的传输层协议，解决队头堵塞问题。

总之，队头阻塞是由 TCP 协议的实现机制所决定的，无法避免。解决队头阻塞的方式有多种，可以选择舍弃 TCP 协议，使用 SCTP 协议或 QUIC 协议等。在 HTTP/2 中，多路复用可以解决 HTTP 级别的队头阻塞。同时，在网络模型中还需要考虑其他层的影响，比如安全层的 TLS 和传输层的 TCP。

#### HTTP 的 keep-alive 有什么作用？

在 HTTP/1.0 中，每个请求都需要建立一次连接，请求响应结束后立即关闭连接。这种方式存在一个问题，就是每次请求都需要建立连接，无法充分利用 TCP 连接的复用性，导致效率低下。

HTTP/1.1 引入了持久连接（keep-alive），允许客户端在同一连接上发送多个请求，服务器返回响应后仍保持连接不关闭，下次请求可直接复用连接，避免了多次建立连接的开销，提升了性能。

使用 keep-alive 技术可以减少连接的建立和关闭次数，降低了 TCP 连接和释放的开销，从而减少网络拥塞，提升了性能和效率。

在 HTTP/2 中，keep-alive 变得更加重要，因为 HTTP/2 中所有的请求都在一个 TCP 连接上进行，这也就意味着 keep-alive 可以充分利用 TCP 连接的复用性，提升效率。

#### HTTP 请求报文是什么样的？

HTTP 请求报文是指客户端向服务器发送的请求数据，由请求行、请求头部、空行和请求体组成。其中，请求行和请求头部是必须的，空行和请求体是可选的。

请求行包含三个部分，分别为请求方法、请求 URI 和协议版本，通常的请求方法有 GET、POST、PUT、DELETE 等。

请求头部包含一系列的键值对，用于传递客户端向服务器传递的信息，如 User-Agent、Content-Type、Authorization 等。每个键值对之间用冒号和空格隔开，行末需要添加一个回车换行符。

空行只包含一个回车换行符，用于分隔请求头和请求体。

请求体包含客户端向服务器传输的数据，如表单数据、上传的文件等。

下面是一个示例 HTTP 请求报文：

```
POST /example HTTP/1.1
Host: www.example.com
Content-Type: application/json
Content-Length: 20

{"key": "value"}
```

其中，请求行表示使用 POST 方法请求服务器上的 /example 资源，使用 HTTP 1.1 协议版本。请求头部包含了 Host、Content-Type 和 Content-Length 三个键值对。空行用于分隔请求头部和请求体。请求体为一个 JSON 字符串，长度为 20 字节。

#### HTTP 响应报文是什么样的？

HTTP 响应报文是服务器返回给客户端的信息，包括响应行、响应头、响应体三部分。

1. 响应行：响应行由协议版本、状态码和状态描述组成，格式如下：

```
HTTP/1.1 200 OK
```

其中，HTTP/1.1 为协议版本，200 为状态码，OK 为状态描述。

2. 响应头：响应头包含了响应报文的一些元数据信息，格式如下：

```
Content-Type: text/html
Content-Length: 12345
```

常见的响应头包括：

- **Content-Type**：表示响应体的 MIME 类型，比如 text/html 表示 HTML 格式的文本。
- **Content-Length**：表示响应体的长度，单位是字节。
- **Cache-Control**：表示客户端是否可以缓存响应结果。
- **Expires**：表示响应过期的时间，如果过期了客户端需要重新请求。

3. 响应体：响应体是服务器返回给客户端的实际内容，可以是 HTML、XML、JSON 等格式的数据，格式如下：

```
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <p>Hello, World!</p>
  </body>
</html>
```

以上是一个简单的 HTML 页面的响应体。

#### HTTP 协议的优点和缺点？

HTTP（Hypertext Transfer Protocol）是应用层协议，用于在 Web 应用程序中传输数据，常用于客户端与服务器之间的通信。下面是 HTTP 协议的优点和缺点：

优点：

1. **简单易用**：HTTP 协议采用了简单的请求-响应模型，客户端发起请求，服务器端响应请求，易于使用和开发。
1. **可扩展性强**：HTTP 协议的头部信息允许传递任意的数据，因此在扩展方面非常灵活。
1. **可缓存性**：HTTP 协议支持缓存机制，可以缓存响应结果，提高应用程序的响应速度和性能。
1. **跨平台性**：HTTP 协议不依赖于硬件和操作系统平台，可以在不同的操作系统和硬件平台之间实现数据交换和通信。

缺点：

1. **不安全性**：HTTP 协议采用明文传输，数据容易被窃听和篡改，不安全性较高。
1. **无状态**：HTTP 协议是无状态的，即服务器不会保留客户端的状态信息，每次请求都是独立的，需要客户端自己维护状态信息。
1. **传输效率低**：HTTP 协议采用明文传输，头部信息较大，传输效率低下。
1. **无法实现服务器推送**：HTTP 协议只能由客户端主动发起请求，服务器无法主动推送数据。

以上是 HTTP 协议的优点和缺点，需要根据具体应用场景进行选择。如果应用场景需要更高的安全性和性能，可以考虑使用 HTTPS 协议或其他协议。

#### 同一时刻浏览器针对同一域名最多可以建立几个 TCP 连接？

HTTP/2 相比于 HTTP/1.x 的主要特点是使用二进制格式传输数据，多路复用、服务器推送、首部压缩等技术，以提高传输效率和性能。

HTTP/2 仍然使用 TCP 连接，但多路复用技术允许在一个 TCP 连接上并发多个请求和响应，避免了 HTTP/1.x 中的队头阻塞问题。因此，HTTP/2 可以使用一个 TCP 连接传输多个请求和响应，从而减少了建立和关闭 TCP 连接的开销，降低了延迟和网络负载。

由于多路复用技术，HTTP/2 可以同时传输多张图片或者其他资源，没有具体的数量限制，而是由可用的带宽、服务器资源和客户端能力等因素决定。不过，需要注意的是，在 HTTP/2 中，多个请求和响应可能会通过同一个 TCP 连接传输，因此，如果某个请求或响应出现延迟或丢失，可能会影响到其他请求或响应的传输和处理。

Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器可能有所不同。

#### HTTPS 通信（握手）过程？

HTTPS 通信是一种安全的 HTTP 通信方式，其通信过程包括 SSL 的四次握手。以下是 HTTPS 通信（握手）过程的详细步骤：

1. 客户端向服务器发送 Client Hello 报文，开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2. 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 服务器发送 Certificate 报文，其中包含公开密钥证书。该证书是由服务器的证书颁发机构（CA）签发的，用于验证服务器身份和公钥的有效性。
4. 服务器发送 Server Hello Done 报文，表示握手过程结束。
5. 客户端收到服务器发来的公开密钥证书后，验证其有效性。如果证书有效，则生成一个随机数作为会话密钥，并使用服务器的公开密钥加密该密钥，然后发送给服务器。
6. 服务器收到客户端发来的加密过的会话密钥后，使用私有密钥解密该密钥，从而获得会话密钥。
7. 客户端和服务器使用会话密钥进行对称加密通信，保证通信过程的机密性和完整性。

总的来说，HTTPS 通信过程的握手包括四次握手，其中第一次握手是客户端向服务器发送 Client Hello 报文，第二次握手是服务器以 Server Hello 报文作为应答，第三次握手是服务器发送 Certificate 报文，第四次握手是服务器发送 Server Hello Done 报文。在握手过程中，客户端和服务器会交换信息，验证对方的身份和证书的有效性，并生成一个会话密钥，用于后续的加密通信。

#### HTTP 特点？

HTTP（超文本传输协议）是一种应用层协议，用于在客户端和服务器之间传输数据。HTTP 协议有以下特点：

1. **简单**：HTTP 协议使用简单，易于学习和实现。它基于请求和响应模型，客户端向服务器发送请求，服务器返回响应。
1. **无连接**：HTTP 协议是一种无连接的协议，每个请求和响应之间都是独立的，服务器不会保留任何客户端的信息。
1. **无状态**：HTTP 协议是一种无状态的协议，服务器不会保存任何客户端的状态信息。每个请求都是独立的，服务器不会记住先前的请求或响应。
1. **可扩展**：HTTP 协议是一种可扩展的协议，可以使用 HTTP 头部传递各种元数据，从而使协议具有更多的功能。
1. **支持多媒体**：HTTP 协议支持多种类型的媒体格式，例如文本、图像、音频、视频等。
1. **支持缓存**：HTTP 协议支持缓存机制，可以在客户端和服务器之间缓存响应数据，从而提高网络性能和用户体验。

总的来说，HTTP 协议是一种简单、灵活、可扩展和可靠的协议，已经成为了互联网通信的基础。

#### HTTP2 的头部压缩算法是怎样的？

#### HTTP 的长连接和短连接？

HTTP 的两种连接模式包括：

持久连接（HTTP/1.1 Keep-Alive）

HTTP 的持久连接是指客户端和服务器之间可以发送多个请求和响应，而不需要每次都建立和关闭连接。在建立持久连接之后，连接会保持一段时间，以便在同一域名下的多个请求和响应之间进行复用，减少了连接的建立和关闭所需的时间和资源。

短连接（Non-Persistent）

短连接是指每次请求和响应都需要建立和关闭一个连接。在短连接模式下，每次请求和响应之间都需要建立一个新的连接，完成请求之后立即关闭连接。这种模式会增加连接的建立和关闭所需的时间和资源，导致性能较差。

需要注意的是，在 HTTP/1.0 中默认使用短连接模式，在 HTTP/1.1 中默认使用持久连接模式。

#### 与缓存相关的 HTTP 请求头有哪些？

与缓存相关的 HTTP 请求头包括以下几个：

1. **If-Modified-Since**: 该字段的值为一个日期时间字符串，表示服务器上次返回的资源的修改时间。当客户端希望获取某个资源的最新版本时，会将该字段的值设置为上次获取时服务器返回的 Last-Modified 值，服务器会将该字段的值与该资源的最新修改时间进行比较，如果相同，则返回 304 Not Modified 状态码，否则返回新的资源内容。
1. **If-None-Match**: 该字段的值为一个资源的唯一标识符，可以是一个 ETag（entity tag）或者一个类似哈希值的字符串。服务器在返回资源时可以设置该字段的值，客户端可以将该字段的值和上次获取时服务器返回的 ETag 或哈希值进行比较，如果相同，则说明客户端已经获取过该资源的最新版本，服务器可以返回 304 Not Modified 状态码。
1. **Cache-Control**: 该字段用于控制缓存的行为，包括 no-cache、no-store、max-age 等参数。其中 no-cache 表示需要向服务器发送请求来获取最新版本的资源，no-store 表示不允许缓存该资源，max-age 表示该资源可以在客户端缓存的时间。
1. **Pragma**: 该字段的值为 no-cache，与 Cache-Control: no-cache 具有相同的作用，用于控制是否缓存该资源。
1. **Expires**: 该字段的值为一个日期时间字符串，表示该资源的过期时间。客户端可以在该时间之前使用缓存中的资源，如果过期则需要重新向服务器获取资源。该字段已经被 Cache-Control: max-age 取代，但在一些老版本的浏览器中仍然被支持。

需要注意的是，缓存的机制不仅与客户端相关，也与服务器相关。服务器可以设置一些响应头来控制浏览器如何缓存返回的资源，例如 Last-Modified 和 ETag 等字段，客户端可以根据这些响应头来判断是否使用缓存。

#### URL 有哪些组成部分？前端怎么获取？

URL 是指统一资源定位符，用于唯一标识互联网上的资源。一个标准的 URL 包含以下几个部分：

1. **协议（Protocol）**：URL 的协议通常指的是访问资源的方式，常见的有 HTTP、HTTPS、FTP、SMTP 等协议。
1. **域名（Domain Name）**：域名是指互联网上某一台服务器的名称，用于定位服务器。
1. **端口号（Port）**：端口号用于区分同一台服务器上不同的服务，例如 HTTP 服务和 FTP 服务。
1. **路径（Path）**：路径表示服务器上资源的具体路径。
1. **查询字符串（Query String）**：查询字符串通常用于向服务器传递参数，常见的格式是 key1=value1&key2=value2。
1. **锚点（Anchor）**：锚点用于在当前页面中定位到指定的位置。

前端可以通过 JavaScript 中的 window.location 对象来获取当前页面的 URL，例如：

```
// 获取当前页面的 URL
const currentUrl = window.location.href;

// 获取当前页面的协议
const protocol = window.location.protocol;

// 获取当前页面的域名
const domainName = window.location.hostname;

// 获取当前页面的端口号
const port = window.location.port;

// 获取当前页面的路径
const path = window.location.pathname;

// 获取当前页面的查询字符串
const queryString = window.location.search;

// 获取当前页面的锚点
const anchor = window.location.hash;
```

需要注意的是，window.location 对象中的一些属性是只读的，如果需要修改当前页面的 URL，可以使用 window.location.replace() 或 window.location.assign() 方法。

#### 数字证书是什么？

数字证书是一种用于验证身份和安全通信的电子文档，通常由一个数字证书颁发机构（CA）发行。数字证书包含证书持有人的公钥、证书持有人的标识信息和证书颁发机构的签名等信息。数字证书的作用类似于护照或驾驶执照，它可以证明证书持有人的身份和资格，并且可以确保通信过程中的机密性、完整性和可信性。

在 Web 安全中，数字证书通常用于 SSL/TLS 协议，用于在客户端和服务器之间建立安全的加密通信。在 SSL/TLS 握手过程中，服务器会向客户端发送数字证书，客户端会验证数字证书的有效性，并使用证书中包含的公钥与服务器进行安全通信。

#### 页面有多张图片，HTTP1 和 HTTP2 分别是怎样的加载表现？

HTTP/1 和 HTTP/2 在页面加载多张图片时的表现不同。在 HTTP/1 中，每个连接都是基于一个 TCP 连接进行建立，如果一个页面同时需要加载多张图片，每张图片都需要建立一个 HTTP 和它对应的一个 TCP 连接，因此会建立多个 HTTP 连接和多个 TCP 连接，这会导致 TCP 连接的数量过多，从而影响页面加载速度。在 HTTP/1 中的一些解决方法是使用以下技术：

- **图片懒加载**：只加载可视区域内的图片，减少请求次数。
- **图片合并**：将多张小图片合并成一张大图片，通过 CSS 的 background-image 属性来引用，减少请求次数。
- **CDN 加速**：使用 CDN 技术，将图片分散在多个服务器上，提高图片加载速度。

而在 HTTP/2 中，采用了多路复用的技术，可以在同一个 TCP 连接上同时发送多个请求和响应，从而避免了建立多个 TCP 连接的问题，提高了页面加载速度。同时 HTTP/2 还支持服务器推送，即在客户端请求一个资源时，服务器会将与这个资源相关的其他资源一起推送到客户端，减少了客户端的请求次数，提高了页面加载速度。此外，HTTP/2 还支持头部压缩技术，可以减少请求头的大小，提高传输速度。

总的来说，HTTP/2 相较于 HTTP/1 在页面加载多张图片时具有以下优势：

- **多路复用技术**：避免了建立多个 TCP 连接的问题，提高了页面加载速度。
- **服务器推送**：减少了客户端的请求次数，提高了页面加载速度。
- **头部压缩技术**：减少请求头的大小，提高传输速度。

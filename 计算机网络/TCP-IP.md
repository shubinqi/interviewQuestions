<!--
 * @Author: Shu Binqi
 * @Date: 2023-02-27 22:45:50
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-14 22:18:31
 * @Description: TCP/IP 面试题（33题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\计算机网络\TCP-IP.md
-->

#### 分层模型和应用协议是什么？

分层模型是计算机网络中的一种设计思想，将整个网络通信过程分成多个层次，每个层次各自负责不同的功能，上下层之间通过协议进行通信，从而使得整个通信过程更加简单、可靠、灵活。常见的分层模型有 OSI 模型和 TCP/IP 模型。

应用协议是在网络通信过程中用于传输数据的协议，定义了数据在网络中的传输格式、数据的编码方式、传输方式、处理方式等。应用协议通常被分为三个层次：应用层、传输层和网络层。常见的应用层协议有 HTTP、FTP、SMTP、POP3 等。传输层协议有 TCP 和 UDP。网络层协议有 IP、ICMP、ARP 等。

分层模型和应用协议是密不可分的，分层模型为协议提供了一个规范化的结构和框架，而应用协议则是分层模型的具体实现，它们共同构成了网络通信的基础。

#### OSI 七层模型是什么？

OSI（Open System Interconnection）七层模型是一种网络通信体系结构，由国际标准化组织（ISO）制定，是一种将计算机网络通信协议按照层次结构分解为七个层次的方法，用于指导网络硬件设备、软件程序的设计和互联互通。

这七个层次分别是：

1. **物理层（Physical Layer）**：传输比特流，是实际的硬件和物理媒介
1. **数据链路层（Data Link Layer）**：传输帧（Frame），负责数据的传输和检错，如 MAC 地址
1. **网络层（Network Layer）**：传输包（Packet），负责数据的路由、寻址等，如 IP 地址
1. **传输层（Transport Layer）**：传输段（Segment），建立数据传输的逻辑通路，如 TCP、UDP
1. **会话层（Session Layer）**：传输会话（Session），负责建立、管理、终止会话
1. **表示层（Presentation Layer）**：传输数据格式（Data Format），负责将数据转化为适合应用层的格式，如压缩、加密等
1. **应用层（Application Layer）**：传输报文（Message），最顶层的协议，提供应用服务，如 HTTP、FTP、SMTP 等。

每一层都有自己的功能和作用，每一层之间的协议是相互独立、互不影响的，每一层的协议都只处理同一层次上的通信问题。这种分层的设计有利于实现通信协议的标准化、分工协作和互相独立，提高了通信系统的可靠性和可维护性。

#### TCP/IP 协议族是什么？

TCP/IP 协议族是当前 Internet 最广泛使用的协议族。它也是一个五层协议组成的体系结构，包括网络层（第 3 层）、传输层（第 4 层）、应用层（第 5 层）、数据链路层（第 2 层）和物理层（第 1 层）。

其中，TCP/IP 协议族的五层协议如下：

1. **应用层（Application Layer）**：应用层是为了满足特定应用程序的需求而设计的。常见的应用层协议有 HTTP、SMTP、FTP 等。
1. **传输层（Transport Layer）**：传输层为运输数据提供了可靠的端到端（End-to-End）服务，包括 TCP 和 UDP 协议。
1. **网络层（Internet Layer）**：网络层负责为数据包在网络中的传输提供逻辑地址。其中最主要的协议是 IP 协议。
1. **数据链路层（Data Link Layer）**：数据链路层负责为数据提供逐层递进的传输，将网络层数据包封装成帧，通过物理层进行传输。其中最常见的协议是 Ethernet。
1. **物理层（Physical Layer）**：物理层主要负责传输介质的相关信息，例如电压、光信号等。其中最常见的协议是 TCP/IP 的物理层标准，包括 RJ-45、光纤等。

相对于 OSI 七层模型，TCP/IP 协议族采用的是更简单的五层协议结构，它去掉了 OSI 的表示层和会话层，将传输层的功能进行了拆分，同时也将物理层和数据链路层合并。此外，TCP/IP 协议族中的应用层和传输层是和 OSI 七层模型对应的，而网络层则对应了 OSI 七层模型中的网络层。

#### 路由器在哪一层工作？

路由器是一个多层面的设备，它可以在不同的网络层（网络协议栈的层次结构）上工作。通常，路由器的主要功能是在网络层（第三层）和数据链路层（第二层）之间转发数据包，从而实现不同网络之间的通信。

在网络层，路由器使用 IP 协议（Internet Protocol）来处理数据包。路由器通过查看数据包的目标 IP 地址，确定最佳的路径将数据包从源地址转发到目标地址。路由器还可以使用路由协议（如 OSPF、BGP 等）来学习网络拓扑并确定最佳路径。

在数据链路层，路由器使用 MAC 地址（Media Access Control）来识别设备。路由器使用 ARP 协议（Address Resolution Protocol）将 IP 地址映射到 MAC 地址，以便正确地将数据包转发到目标设备。

此外，路由器还可以支持其他协议和功能，如 NAT（Network Address Translation）、DHCP（Dynamic Host Configuration Protocol）、VPN（Virtual Private Network）等，这些协议和功能可以在不同的网络层级上工作。

#### 路由器的工作流程？

路由器的工作流程通常包括以下几个步骤：

1. **接收数据包**：当路由器接收到一个数据包时，它会检查数据包的头部信息，例如源地址、目标地址和协议类型等，以决定如何处理该数据包。
1. **查找最佳路径**：路由器会根据其路由表，确定数据包的最佳路径。路由表是一个路由器存储的表格，其中包含了网络地址和下一跳地址之间的映射关系。路由器通常使用路由协议（如 OSPF、BGP 等）来学习路由信息，并将其添加到路由表中。
1. **转发数据包**：当路由器确定了数据包的最佳路径后，它会将数据包转发到下一个路由器或目标主机。在转发数据包时，路由器会修改数据包的目标 MAC 地址和源 MAC 地址，并在数据包头部添加一些必要的信息，例如 TTL（Time to Live）和校验和等。
1. **处理异常情况**：如果路由器无法确定数据包的下一跳地址，或者发现目标地址不存在，路由器会根据配置的策略进行处理，例如将数据包丢弃或发送到特定的端口。
1. **发送回复数据包**：如果数据包是一个请求数据包（例如 PING 请求），路由器会生成一个回复数据包，并将其发送回源地址。
1. **记录日志**：路由器通常会记录一些日志信息，例如收到的数据包、转发的数据包、异常情况等，以便管理员进行故障排查和网络性能优化等工作。

以上是路由器的基本工作流程，不同的路由器在实现上可能会有一些细微的差别，但大体上都是按照这个流程工作的。

#### TCP 和 UDP 的概念及特点？

TCP 和 UDP 是网络传输层协议，常用于应用层的数据传输。

TCP（传输控制协议）是面向连接的可靠协议，它通过三次握手建立连接，在数据传输过程中提供流量控制、重传丢失的数据包、错误检查等机制，保证数据的可靠性。TCP 传输效率较低，因为每次数据传输都需要进行连接的建立和断开，同时还需要保证传输数据的完整性，数据包的数量较多，占用网络资源较多。TCP 常用于对数据完整性要求高、数据量大的场景，如文件传输、网页浏览等。

UDP（用户数据报协议）是无连接的不可靠协议，它不进行连接的建立和断开，只是简单地把数据包发送给目标地址，不提供重传丢失的数据包、流量控制、错误检查等机制，因此数据包有可能会丢失、重复、乱序，但是传输效率高。UDP 常用于对数据完整性要求不高、实时性要求高的场景，如音视频传输、实时游戏等。

总的来说，TCP 和 UDP 的选择要根据具体的应用场景和需求来决定。如果要求数据传输的可靠性和完整性，则应该选择 TCP；如果要求传输速度和实时性，则应该选择 UDP。

#### TCP 和 UDP 的区别？

TCP（传输控制协议）和 UDP（用户数据报协议）是互联网传输层中两个最基本的协议，它们在传输数据时有很多不同点，主要的区别如下：

1. **连接方式**：TCP 是一种面向连接的协议，而 UDP 是一种非连接的协议。TCP 建立连接后进行数据传输，UDP 则直接传输数据包。
1. **可靠性**：TCP 保证数据传输的可靠性，因为它使用了重传机制和校验和来确保数据的完整性和准确性，而 UDP 则不保证数据传输的可靠性。
1. **传输效率**：由于 TCP 需要保证数据的可靠性，所以它的传输效率相对较低。而 UDP 则没有这个要求，所以它的传输效率较高。
1. **数据大小限制**：TCP 没有固定的数据包大小限制，而 UDP 的数据包大小有限制，一般不超过 64KB。
1. **有序性**：TCP 保证数据的传输是有序的，即发送的数据包按照一定的顺序到达接收端。而 UDP 则没有这个保证。

总的来说，TCP 是一种比较可靠但是效率相对较低的协议，适合用于需要保证数据完整性和可靠性的场景；UDP 则是一种效率高但是可靠性较低的协议，适合用于实时传输和数据量较大的场景。

#### TCP 如何保证数据传输？

TCP（Transmission Control Protocol）使用了多种技术来保证可靠的数据传输，主要包括以下几个方面：

1. **确认和重传机制**：TCP 采用了带确认和重传机制的数据传输方式，数据包在传输过程中需要接收方发回确认信息，如果发送方在规定时间内未收到确认信息，则会重发数据包，从而保证数据的可靠性。
1. **滑动窗口**：TCP 中的滑动窗口机制可以控制发送方的发送速率，防止接收方无法处理过多的数据。发送方和接收方之间建立一个缓存区，通过滑动窗口控制缓存区的大小，防止缓存区溢出。
1. **流量控制**：TCP 可以通过拥塞控制机制来避免网络拥塞，使得网络可以在高效率的情况下进行数据传输。
1. **超时重传**：TCP 使用超时重传机制来检测丢失的数据包，如果发送方在规定时间内未收到确认信息，则会重发数据包。
1. **确认机制**：TCP 使用确认机制来保证数据传输的可靠性，接收方在接收到数据包后需要发回确认信息，发送方在收到确认信息后才能发送下一个数据包。

总的来说，TCP 可以通过上述多种机制来保证数据传输的可靠性和稳定性，但是也会导致网络传输速度较慢，占用系统资源较多。

#### TCP 和 UDP 的使用场景？

TCP 和 UDP 都是传输层协议，但是它们有不同的特点和适用场景。

TCP 主要应用于数据可靠性要求比较高的场景，如文件传输、电子邮件、网页访问等。TCP 具有以下特点：

1. **可靠传输**：TCP 采用可靠传输机制，保证数据的完整性、有序性和无丢失；
1. **有连接**：TCP 使用三次握手建立连接，通信前必须先建立连接，通信结束后要释放连接；
1. **流式传输**：TCP 是一种流式传输协议，将数据看作是一条连续的流，通过数据分段和序列号来实现数据的可靠传输；
1. **慢启动和拥塞控制**：TCP 采用慢启动和拥塞控制机制，根据网络状况动态调整数据传输速度，避免网络拥塞。

UDP 主要应用于实时性要求比较高的场景，如视频会议、实时游戏等。UDP 具有以下特点：

1. **无连接**：UDP 不需要建立连接，直接发送数据，无需等待对方确认；
1. **不可靠传输**：UDP 不保证数据的可靠传输，可能会丢失、重复或乱序；
1. **简单、快速**：UDP 协议比 TCP 简单，速度更快，网络负载小；
1. **数据报式传输**：UDP 是一种数据报式传输协议，将数据看作是一个个独立的数据报，每个数据报都包含完整的数据、目标地址和源地址。

综上所述，TCP 适用于数据可靠性要求高的场景，UDP 适用于实时性要求高的场景。

#### UDP 协议为什么不可靠？

UDP 协议因为没有提供数据传输的可靠性机制，所以被称为“不可靠的数据报协议”，主要有以下几个原因：

1. UDP 不会像 TCP 那样建立连接，因此在传输数据之前不会进行握手操作，也不会维护任何连接状态信息，这就使得 UDP 传输的数据包容易遗失或者乱序。
1. UDP 数据包发送时没有确认机制，发送方发送出去的数据包无法确定是否被对方接收，也无法确定对方接收到数据包的顺序，因此容易出现丢包和乱序的情况。
1. UDP 没有拥塞控制机制，也不会进行数据的重传，如果网络出现拥塞或者丢包现象，UDP 协议无法通过重传机制来保证数据传输的可靠性。

因此，UDP 主要用于传输实时数据，例如视频和音频等，在实时性要求高的场景下，可以快速的发送数据，而不需要等待数据的重传或者重组。但是，在需要保证数据传输可靠性的情况下，TCP 协议则是更好的选择。

#### TCP 的拥塞控制机制？

TCP 的拥塞控制机制是用于控制网络拥塞的一种算法，主要作用是让发送方发送的数据量不要超过网络承受的范围，以防止网络拥塞导致网络传输效率下降甚至瘫痪。

TCP 的拥塞控制算法主要包括四个算法：慢启动、拥塞避免、快速重传和快速恢复。

1. **慢启动（Slow Start）**：慢启动算法主要用于确定初始拥塞窗口 cwnd，其过程是从一个较小的值开始，每收到一个确认 ACK 就将 cwnd 值加倍，以此达到一个适合当前网络状况的传输速率。
1. **拥塞避免（Congestion Avoidance）**：拥塞避免算法是在慢启动之后，进入正常的拥塞控制状态。在这个状态下，TCP 每经过一个 RTT，拥塞窗口 cwnd 就加 1，以缓慢增加发送速率，直到出现丢包或超时等异常情况。
1. **快速重传（Fast Retransmit）**：当 TCP 发送的数据包在传输过程中丢失或损坏，接收方会回复一个重复确认 ACK，告诉发送方需要重传数据包。如果发送方在接收到连续 3 个重复确认 ACK 后没有收到确认回复，就会快速重传丢失的数据包，而不是等到超时再重传。
1. **快速恢复（Fast Recovery）**：快速恢复算法是在快速重传之后，进入的一种恢复机制。发送方会将拥塞窗口 cwnd 减半，但不会像超时重传一样把拥塞窗口减到初始值，而是将 cwnd 设置为 ssthresh，即先前 cwnd 值的一半。这样可以快速恢复之前的拥塞窗口大小，同时也避免了慢启动需要重新进行的过程。

#### TCP 的可靠传输机制？

TCP 提供了可靠的传输机制，确保数据从一个端点传输到另一个端点的可靠性和顺序。TCP 的可靠传输机制包括以下几个方面：

1. **应答机制**：TCP 采用了确认应答机制，当发送方发送一个数据段后，接收方会回复一个确认应答，表示已经成功接收到数据。如果发送方在一定时间内没有收到确认应答，则会认为该数据丢失或损坏，触发重传机制。
1. **重传机制**：TCP 会根据接收方的确认应答来确定哪些数据丢失或损坏，然后对丢失或损坏的数据进行重传。
1. **滑动窗口机制**：TCP 使用滑动窗口机制来控制发送方发送的数据量，以避免接收方无法处理大量数据的情况。发送方会根据接收方的窗口大小来控制发送的数据量，以确保接收方可以及时处理接收到的数据。
1. **超时重传机制**：TCP 会为每个数据段设置一个超时计时器，如果在一定时间内没有收到确认应答，则会触发重传机制。
1. **流量控制机制**：TCP 采用了流量控制机制，通过接收方发送的窗口大小来控制发送方发送的数据量，以避免接收方无法处理大量数据的情况。

#### TCP 的应答机制？

TCP 是一种面向连接的可靠的传输协议，通过应答机制实现可靠传输。当发送方向接收方发送数据段时，接收方会返回一个确认应答（ACK），表示已经成功接收到数据。如果发送方在一定时间内没有收到接收方的确认应答，则会重新发送数据，直到收到接收方的确认应答为止。此外，如果接收方在收到数据后发现有误，则会发送一个重传请求，要求发送方重新发送数据。发送方收到重传请求后，也会重新发送数据。这些机制保证了 TCP 的可靠性。

#### TCP 的重传机制？

TCP 的重传机制是指当 TCP 发送数据时，如果数据包没有得到确认或者在规定的时间内没有得到确认，TCP 就会重传数据包，以确保数据能够正确地传输。

具体来说，TCP 的重传机制包括以下几个步骤：

1. 发送方将数据包发送给接收方，并启动定时器。
1. 如果在规定的时间内没有收到接收方的确认，发送方就会重传数据包，并再次启动定时器。
1. 如果在一定次数内仍未收到接收方的确认，发送方就会认为连接已经失效，关闭连接。

TCP 的重传机制可以保证数据的可靠传输，但是也会影响数据传输的效率。如果网络丢包率较高，TCP 会频繁地重传数据包，从而降低网络的吞吐量。因此，在实际应用中，需要根据具体的情况选择合适的重传机制。

#### TCP 的滑动窗口机制？

TCP 的滑动窗口机制是一种流量控制的方法，它用于调整数据传输的速度和确保传输的可靠性。TCP 的滑动窗口机制基于接收方和发送方之间的通信，控制发送方的数据发送速度，以避免数据包的丢失和网络拥塞。

具体来说，TCP 的滑动窗口机制包括以下步骤：

1. 接收方向发送方发送一个窗口大小（Window Size）的值，用于告诉发送方它当前能够接收多少数据。
1. 发送方发送数据，并等待接收方的确认（ACK）消息。
1. 接收方接收数据，并将 ACK 消息发送给发送方，告诉它哪些数据已经成功接收。
1. 发送方根据接收到的 ACK 消息，调整窗口大小和发送速度，以便在不超过接收方窗口大小的情况下尽可能快地传输数据。
1. 如果发送方没有接收到 ACK 消息，它会重新发送数据，直到接收到 ACK 消息为止。

通过滑动窗口机制，TCP 可以动态调整数据传输速度，并防止数据包的丢失和网络拥塞。同时，TCP 还可以通过超时重传等机制来保证数据传输的可靠性。

#### TCP 的超时重传机制？

TCP 的超时重传机制是为了保证数据传输的可靠性而存在的。当一台主机向另一台主机发送数据时，如果在规定时间内没有收到对方的确认，就会触发超时重传机制。具体来说，TCP 将每个发送出去的数据段都标上一个序号，接收方在收到数据段后将给出一个确认号，表示已经成功接收到序号为该值的数据段，这个确认号就是下一个期待收到的数据段的序号。当发送方发送一个数据段后，它就会启动一个计时器，等待接收方的确认。如果在规定时间内（RTT，即往返时延）没有收到接收方的确认，发送方就会将该数据段再次发送，直到收到确认为止。

超时重传机制是通过重传丢失的数据段来保证数据的可靠传输的。如果发送方连续重发某个数据段三次仍未收到确认，则会认为该数据段丢失了，发送方会重新发送该数据段，直到收到确认为止。重传次数过多会增加网络负担，降低传输效率，所以需要在合适的时机设置超时时间，以尽可能地保证可靠传输的同时减少重传次数。

#### TCP 的流量控制机制？

TCP 的流量控制机制是通过滑动窗口实现的。每次接收到数据后，TCP 协议会向发送端发送确认 ACK 消息，其中包含窗口大小信息。窗口大小即为可以接收的字节数，发送端根据接收端返回的窗口大小信息来确定发送数据的大小，从而达到流量控制的目的。

具体来说，发送端维护了一个发送窗口和接收窗口的大小，其中发送窗口大小受拥塞控制影响，接收窗口大小受接收端缓冲区大小影响。发送端的发送窗口大小是动态变化的，它受到接收端接收窗口大小和网络拥塞程度的影响，如果接收端的接收窗口大小减小，发送端的发送窗口也会随之减小，以避免数据的丢失和网络拥塞。

在 TCP 连接建立时，会协商双方的初始窗口大小，这个值默认是 65535，也就是 64KB。发送方发送的数据不能超过对方通告的窗口大小，否则就需要等待对方通告更大的窗口，而接收方的窗口大小则取决于接收方的缓冲区大小和网络状况。在数据传输过程中，如果接收方收到的数据不连续或者丢失了，就会发送一个带有窗口大小信息的 ACK，告诉发送方可以继续发送的数据量，从而保证了 TCP 的可靠性和流量控制。

#### TCP 的三次握手和四次挥手？（建议写博客）

TCP 协议建立连接使用三次握手，断开连接使用四次挥手。

三次握手的过程如下：

1. 客户端向服务端发送 SYN 数据包，表示请求建立连接，SYN 标志位为 1，序列号为 x。
1. 服务端接收到 SYN 数据包后，向客户端发送 SYN+ACK 数据包，表示确认收到请求，SYN 和 ACK 标志位都为 1，序列号为 y，确认号为 x+1。
1. 客户端接收到 SYN+ACK 数据包后，向服务端发送 ACK 数据包，表示确认收到确认，ACK 标志位为 1，序列号为 x+1，确认号为 y+1。

四次挥手的过程如下：

1. 客户端向服务端发送 FIN 数据包，表示请求断开连接，FIN 标志位为 1，序列号为 u。
1. 服务端接收到 FIN 数据包后，向客户端发送 ACK 数据包，表示确认收到请求，ACK 标志位为 1，序列号为 v，确认号为 u+1。
1. 如果服务端还有数据需要传输，那么服务端可以继续发送数据，直到发送完毕，然后向客户端发送 FIN 数据包，FIN 标志位为 1，序列号为 w，确认号为 u+1。
1. 客户端接收到 FIN 数据包后，向服务端发送 ACK 数据包，表示确认收到请求，ACK 标志位为 1，序列号为 u+1，确认号为 w+1。服务端接收到 ACK 数据包后，关闭连接。

#### 简述一下 TCP 的三次握手？为什么要三次握手，两次不行吗？

TCP 的三次握手是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包以确认连接的过程。具体流程如下：

1. 客户端向服务器发送 SYN 报文，表示请求建立连接，其中 SYN=1，ACK=0，seq=x。
1. 服务器收到 SYN 报文后，返回 SYN+ACK 报文，其中 SYN=1，ACK=1，seq=y，ack=x+1。
1. 客户端收到 SYN+ACK 报文后，向服务器发送 ACK 报文，其中 SYN=0，ACK=1，seq=x+1，ack=y+1。

通过三次握手的过程，可以确保客户端和服务器之间的通信是可靠的，包括：

1. 确定了双方的发送和接收能力正常，可以进行数据传输；
1. 确保客户端和服务器都能收到对方的消息，避免了因网络原因造成的消息丢失问题；
1. 防止已经失效的连接请求报文段突然又传送到了服务端，因而产生错误。

为什么要进行三次握手，而不是两次或四次呢？如果只进行两次握手，会有以下问题：

客户端发出连接请求，但在网络中滞留，由于客户端没有收到服务端的确认，就会重发请求，如果服务端收到了重复的请求，就会打开多个连接，浪费系统资源；
如果只有两次握手，当客户端发送请求后，如果服务端不响应，客户端会一直等待响应，造成资源浪费。而进行三次握手可以防止这种情况的发生。
因此，通过三次握手的方式可以更加可靠地建立连接，保证数据的安全性和稳定性。

#### 简述一下 TCP 的四次挥手？为什么需要四次挥手呢？

TCP 的四次挥手指的是在 TCP 连接关闭时，客户端和服务端之间需要发送四个数据包来完成关闭过程。其过程如下：

1. 客户端发送一个 FIN 报文，请求关闭连接。
1. 服务端收到 FIN 报文后，发送一个 ACK 报文作为响应，确认收到了客户端的请求，并进入 CLOSE_WAIT 状态。
   - 此时如果服务端还有数据需要发送给客户端，会继续发送数据，直到数据发送完毕，然后发送一个 FIN 报文。
1. 客户端收到 FIN 报文后，发送一个 ACK 报文作为响应，确认收到了服务端的关闭请求，进入 TIME_WAIT 状态，等待 2MSL（最长报文段寿命）后释放连接。
1. 服务端收到客户端的 ACK 报文后，进入 CLOSED 状态，连接关闭。

四次挥手是为了保证数据的可靠传输，防止因为网络延迟等原因导致的数据丢失或者重复。如果只使用三次挥手，服务端可能无法知道客户端是否已经收到了最后一个数据包。因此，四次挥手可以保证双方都能够知道对方已经完成了关闭操作。

#### TCP 粘包是怎么回事，如何处理？

TCP 粘包是指发送方发送的数据在经过传输过程中，到达接收方时粘成了几个数据包，或者一个数据包被拆成了几个数据包。这种情况可能会导致接收方无法正确处理数据，从而造成数据错误或者丢失。

TCP 粘包问题的主要原因是 TCP 的传输是基于字节流的，而不是消息或者数据包，因此在传输过程中，没有明确的边界表示数据包的开始和结束。

为了解决 TCP 粘包问题，可以采取以下几种方法：

1. **消息边界**：发送方在每个数据包后添加一个特殊的字符或者字符串，表示该数据包的结束，接收方接收到该字符或者字符串后，就知道该数据包的结束。
2. **固定长度**：发送方在每个数据包前添加该数据包的长度，接收方在接收数据包后，根据长度来区分不同的数据包。
3. **使用应用层协议**：应用层协议可以通过在消息头部添加一个消息长度字段来指示数据包的长度和边界。

需要注意的是，TCP 粘包问题并不是 TCP 协议本身的问题，而是在应用层的数据处理上出现的问题。因此，处理 TCP 粘包问题的方法应该在应用层进行，而不是在 TCP 协议层面进行。

#### 为什么  UDP  不会粘包？

UDP 是无连接的数据报协议，数据报的单位是 UDP 报文，它的长度是固定的，即使传输的数据量很小，UDP 报文头部的长度也是固定的。因此，即使 UDP 在传输时发生丢包，也不会影响其他数据包的传输，每个 UDP 报文都是独立的，不存在粘包的情况。所以 UDP 不会发生粘包问题。

#### token 是什么？由什么构成？token 是怎么加密的？

Token（令牌）是一种身份验证方式，用于识别和验证访问应用程序的用户。Token 通常是一个字符串，由三部分构成：header、payload 和 signature。

1. Header 包含令牌的类型和使用的加密算法，通常为 JSON 格式。
1. Payload 包含用户信息和其他元数据，也通常为 JSON 格式。
1. Signature 是将 header 和 payload 加密后的字符串，用于验证令牌的完整性和真实性。

Token 的加密过程通常采用的是对称加密和非对称加密相结合的方式。在对称加密中，使用同一个密钥加密和解密数据，速度快，但密钥需要在客户端和服务器之间共享，安全性相对较低。非对称加密则使用公钥加密数据，私钥解密数据，或者使用私钥加密数据，公钥解密数据。这种方式更加安全，但速度相对较慢。在实际应用中，通常会使用对称加密加密数据，然后使用非对称加密加密对称加密所使用的密钥。

在验证 Token 时，服务器会先解密 Signature，然后使用同样的算法和密钥加密 header 和 payload，然后将两个加密后的字符串与 Signature 进行比较，以验证 Token 的完整性和真实性。

#### cookie 和 token 都放在 header 中，为什么会劫持 cookie，不会劫持 token？

劫持 Cookie 相对于劫持 Token 来说，更容易被攻击者利用。这是因为 Cookie 默认是存储在浏览器中的，而浏览器对于 Cookie 的存储、读取等操作相对容易受到攻击。攻击者可以通过一些手段（如 XSS 攻击、CSRF 攻击等）窃取用户的 Cookie，然后伪装成用户向服务器发送请求，进行一些恶意操作。

相比之下，Token 的存储方式通常是将其存储在客户端本地的 Local Storage 或 Session Storage 中，攻击者难以通过客户端窃取 Token。同时，在使用 HTTPS 协议时，Token 的传输过程中还可以通过 SSL/TLS 的加密保护，进一步增强其安全性。因此，相对于 Cookie，Token 更为安全，也更难被劫持。

#### token 过期后，页面如何实现无感刷新？

当用户的 token 过期后，页面需要进行无感刷新以重新获取新的 token，以免用户在操作过程中出现异常。常见的实现方式如下：

1. 前端在每个请求中都带上 token，如果 token 过期，服务端会返回一个特定的错误码，前端需要识别这个错误码，并进行相应的处理。一种处理方式是在出现错误时跳转到登录页面，另一种方式是在前端实现 token 的自动刷新，然后重新发起请求。
1. 前端使用拦截器（Interceptor）对每个请求进行拦截，在请求中添加 token。当请求失败时，拦截器会检查响应码，如果为特定错误码（例如 401）则会自动跳转到登录页面或进行 token 刷新。
1. 服务端可以返回一个新的 token，前端在接收到响应后将新的 token 更新到本地，并在后续请求中带上新的 token。这种方式需要前端进行相应的处理，以保证 token 的安全性。

需要注意的是，为了防止 token 的劫持和泄露，需要使用合适的加密算法进行加密，并采用 HTTPS 协议进行传输，以保障数据的安全性。

#### WebSocket 是什么？

WebSocket 是一种双向通信协议，位于 OSI 模型的应用层。与 HTTP 长连接不同，WebSocket 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。在单个 TCP 连接上进行全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。在 WebSocket 出现之前，实时 web 应用的方式为轮询，即不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果。但轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 CPU 资源。WebSocket 的特点包括：

- 全双工：建立连接后客户端与服务器端是完全平等的，可以互相主动请求。
- 单个 TCP 连接：能更好地节省服务器资源和带宽并达到实时通讯。
- 只需要完成一次握手：两者之间就可以创建持久性的连接，并进行双向数据传输。

WebSocket 的使用步骤包括：

1. **建立连接**：与服务器建立 WebSocket 连接，需要指定服务器地址和端口号。
2. **发送数据**：连接建立成功后，可以通过 send 方法向服务器发送数据。
3. **接收数据**：可以通过监听 message 事件来接收服务器返回的数据。
4. **关闭连接**：使用 close 方法关闭 WebSocket 连接。

WebSocket 的 API 包括：

- WebSocket 对象：用于创建 WebSocket 连接和发送和接收数据。
- onopen 事件：连接建立成功后触发。
- onmessage 事件：接收到服务器返回的数据时触发。
- onclose 事件：连接关闭时触发。
- onerror 事件：连接出错时触发。
- send 方法：向服务器发送数据。
- close 方法：关闭 WebSocket 连接。

在建立 WebSocket 连接时，客户端需要向服务器发送一个 HTTP 请求，该请求需要包含以下头部信息：

- Upgrade：指定协议升级为 WebSocket。
- Connection：指定连接类型为 Upgrade。
- Sec-WebSocket-Key：指定一段随机字符串。
- Origin：指定请求的源地址。
- Sec-WebSocket-Protocol：指定使用的子协议。
- Sec-WebSocket-Version：指定使用的 WebSocket 版本。

服务器需要响应一个 HTTP 响应，该响应需要包含以下头部信息：

- Upgrade：指定协议升级为 WebSocket。
- Connection：指定连接类型为 Upgrade。
- Sec-WebSocket-Accept：指定一段经过计算的字符串。
- Sec-WebSocket-Protocol：指定使用的子协议。

#### HTTP 和 WebSocket 的区别？

HTTP（超文本传输协议）和 WebSocket（Web 套接字协议）都是网络协议，但是它们有一些重要的区别。

HTTP 是基于请求-响应模式的协议。在传统的 HTTP 请求中，客户端向服务器发送请求，并等待服务器返回响应。在这个过程中，客户端必须持续地向服务器发送请求以更新数据。这种轮询机制会浪费带宽和服务器资源。

WebSocket 是一种基于事件的协议，它提供了在单个 TCP 连接上进行全双工通信的能力，因此可以实现实时通信。WebSocket 的一个重要特点是它可以通过服务器向客户端推送数据，而不需要客户端主动发起请求。这使得 WebSocket 比 HTTP 更适合于实时应用程序，例如聊天应用程序、游戏和实时协作工具。

HTTP 和 WebSocket 的另一个重要区别在于它们的协议头。HTTP 的协议头包含 HTTP 方法（如 GET 或 POST）和标头字段（如 Cookie 或 User-Agent）。WebSocket 的协议头包含用于建立 WebSocket 连接的协议升级字段。

因此，HTTP 和 WebSocket 都有各自的优势和适用场景。HTTP 适用于大多数 Web 应用程序，而 WebSocket 适用于需要实时通信和数据推送的应用程序。

#### 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？

即时通讯的实现方式有四种，包括短轮询、长轮询、SSE 和 WebSocket。其中，短轮询、长轮询和 SSE 是在 HTTP 基础上实现的，而 WebSocket 不是。以下是这四种方式的区别：

- **短轮询**：客户端定时向服务器发送请求，服务器立即返回响应。这种方式的缺点是，客户端需要频繁地向服务器发送请求，会造成网络资源的浪费，同时也会增加服务器的压力。
- **长轮询（comet）**：客户端向服务器发送请求，服务器不会立即返回响应。服务器会一直等待，直到有数据可以返回给客户端时才会返回响应。客户端收到响应后再向服务器发送下一次请求。这种方式的缺点是，服务器需要维持大量的连接，会占用大量的服务器资源。
- **SSE**：SSE（Server-Sent Events）是一种基于 HTTP 的服务器推送技术。客户端向服务器发送请求，服务器会返回一个持久化的连接，然后服务器可以向客户端推送数据。这种方式的优点是，可以实现服务器主动向客户端推送数据，不需要客户端频繁地向服务器发送请求，节省了网络资源，同时也降低了服务器的压力。
- **WebSocket**：WebSocket 是一种基于 TCP 的协议，可以实现双向通信。客户端和服务器之间建立一个持久化的连接，可以互相发送数据。WebSocket 相对于其他三种方式的优点是，可以实现双向通信，不需要客户端频繁地向服务器发送请求，同时也减少了服务器的压力。

短轮询：

```
// 客户端
setInterval(function() {
  $.ajax({
    url: '/poll',
    type: 'GET',
    success: function(data) {
      // 处理数据
    }
  });
}, 1000);

// 服务器端
app.get('/poll', function(req, res) {
  // 处理请求
  res.send(data);
});
```

长轮询：

```
// 客户端
function longPoll() {
  $.ajax({
    url: '/comet',
    type: 'GET',
    success: function(data) {
      // 处理数据
      longPoll();
    }
  });
}

longPoll();

// 服务器端
app.get('/comet', function(req, res) {
  // 处理请求
  if (dataAvailable) {
    res.send(data);
  } else {
    // 等待数据
  }
});
```

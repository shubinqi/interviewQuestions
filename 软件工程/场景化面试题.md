<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-02 22:24:34
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-10 00:00:48
 * @Description: 场景化面试题（24题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\软件工程\场景化面试题.md
-->

#### 了解前端埋点吗？是怎么做的？

前端埋点是一种数据追踪技术，用于捕获、处理和发送特定用户行为或业务过程的相关数据。前端埋点通常分为三个阶段：埋点阶段、数据收集阶段和后端处理阶段。

- **手动埋点**：通过手动编写 JavaScript 代码，将用户的操作事件绑定到代码中，再通过 Ajax 或其他技术将数据传递给后端服务器。
- **自动化埋点**：利用前端框架或第三方库提供的自动化埋点功能，无需手动编写代码。例如，Vue 框架提供的 v-track 指令、React 框架提供的 ReactGA、百度统计等第三方埋点库。
- **可视化埋点**：通过可视化界面来实现埋点，一些数据分析工具如神策、GrowingIO、Mixpanel 等提供的可视化埋点方案，可以让非开发人员也能进行埋点操作。
- **数据收集阶段**：主要是收集客户端数据，如页面 URL、用户代理信息、设备信息、用户行为等，通常使用 JavaScript 获取。
- **后端处理阶段**：将收集到的数据发送到后端服务器进行处理，存储和分析，以便进行数据统计和分析。

在实现前端埋点时，需要考虑以下几个方面：

- **埋点粒度**：要确定哪些事件需要进行埋点，需要注意埋点的粒度不要过粗也不要过细。
- **数据收集**：要考虑如何采集、存储和分析数据，需要设计好数据收集的格式、字段和处理方式。
- **代码质量**：编写埋点代码时要注意代码质量，避免对页面性能和用户体验产生负面影响。
- **隐私保护**：要遵守相关法律法规和隐私政策，保护用户隐私。

在实际应用中，还需要考虑如何将埋点代码与业务代码解耦，以便更好地维护和更新代码。常见的方法包括：

- **使用第三方埋点 SDK**：如百度统计、友盟、TalkingData、Google Analytics、Sensors Analytics 等，这些 SDK 提供了简单易用的 API，可以快速实现埋点功能。
- **使用组件库**：如 React、Vue 等，可以封装跟踪点击事件的组件，使业务代码与埋点代码解耦。例如，在 React 中可以使用 TrackerClick 组件来跟踪点击事件。

在具体实现中，可以参考以上提供的代码示例和思路，根据实际需求选择合适的方式进行前端埋点。

#### 前端埋点使用场景是什么？

前端埋点的使用场景有很多，以下列举了一些常见的场景：

1. **用户行为跟踪**：埋点可以用来跟踪用户的行为路径，分析用户的喜好、习惯等，为产品设计提供数据支持。
1. **性能监控**：通过埋点可以收集用户在使用过程中的性能数据，如加载速度、响应时间、错误率等，方便进行性能优化。
1. **页面分析**：埋点可以用来记录用户在页面中的操作行为，如点击、滚动、停留时间等，从而了解用户对页面的使用情况，进一步优化页面设计。
1. **数据采集**：埋点可以收集用户在产品中的各种数据，如地理位置、设备信息、操作系统、浏览器等，为产品设计提供数据支持。
1. **A/B 测试**：通过在页面中添加不同的埋点，可以跟踪用户在不同页面中的行为路径，从而进行 A/B 测试，评估不同页面设计的效果。

总之，前端埋点可以帮助我们深入了解用户的需求和习惯，为产品的优化提供支持。

#### token 是什么？由什么构成？token 是怎么加密的？

Token（令牌）是一种身份验证方式，用于识别和验证访问应用程序的用户。Token 通常是一个字符串，由三部分构成：header、payload 和 signature。

1. Header 包含令牌的类型和使用的加密算法，通常为 JSON 格式。
1. Payload 包含用户信息和其他元数据，也通常为 JSON 格式。
1. Signature 是将 header 和 payload 加密后的字符串，用于验证令牌的完整性和真实性。

Token 的加密过程通常采用的是对称加密和非对称加密相结合的方式。在对称加密中，使用同一个密钥加密和解密数据，速度快，但密钥需要在客户端和服务器之间共享，安全性相对较低。非对称加密则使用公钥加密数据，私钥解密数据，或者使用私钥加密数据，公钥解密数据。这种方式更加安全，但速度相对较慢。在实际应用中，通常会使用对称加密加密数据，然后使用非对称加密加密对称加密所使用的密钥。

在验证 Token 时，服务器会先解密 Signature，然后使用同样的算法和密钥加密 header 和 payload，然后将两个加密后的字符串与 Signature 进行比较，以验证 Token 的完整性和真实性。

#### 说一下单点登录？前后端怎么实现鉴权？

单点登录（Single Sign-On，简称 SSO）是指用户只需要在一个认证中心进行一次登录，就可以在多个应用中访问受保护的资源，而无需再次进行认证。SSO 可以减少用户需要记忆的登录信息，提高用户体验，也可以减少系统管理员的工作量，提高系统的安全性。

下面是一种常见的 SSO 实现方式：

1. **集中式认证中心**：用户首先访问一个认证中心，该中心对用户进行身份验证，然后向用户颁发一个令牌。这个令牌包含了用户的身份信息以及有效期等信息，可以在多个应用之间共享。
1. **应用程序**：用户访问其他应用程序时，应用程序会检查令牌的有效性，并在需要时向认证中心请求授权。如果令牌有效，则应用程序会向用户提供访问受保护资源的权限。

实现 SSO 的具体步骤如下：

1. **集成认证中心**：在系统中添加一个认证中心，以便处理用户的身份验证和授权请求。
1. **实现用户验证**：认证中心需要能够验证用户的身份。可以使用各种不同的身份验证机制，例如基于用户名和密码的身份验证、多因素身份验证、单点登录身份验证等等。
1. **颁发令牌**：认证中心需要颁发一个令牌，该令牌可以在多个应用程序之间共享，以便用户只需要进行一次身份验证。这个令牌通常包括用户的身份信息、有效期以及其他安全属性。
1. **集成应用程序**：将认证中心集成到所有应用程序中，以便应用程序可以使用认证中心进行身份验证和授权请求。
1. **验证令牌**：在每个应用程序中，使用令牌验证用户的身份。应用程序可以使用令牌中的信息来验证用户是否有权访问受保护的资源。

实现 SSO 需要使用各种技术和工具，例如 OpenID Connect、OAuth、SAML 等。开发人员应该根据实际需求来选择合适的技术和工具，并确保实现的 SSO 系统安全可靠、易于维护和扩展。

#### 扫码登录实现原理？

扫码登录是一种常见的登录方式，其原理如下：

1. 用户在登录页面上选择“扫码登录”选项。
1. 服务端生成一个二维码，并将二维码的数据存储在服务器上。二维码的数据通常包含一个唯一的标识符，用于标识该登录请求。
1. 服务端将二维码的数据以及一个生成时间戳的链接返回给客户端。
1. 客户端显示二维码，并将链接显示在二维码下方，等待用户扫码。
1. 用户使用手机等设备扫描二维码，并通过链接打开一个页面。这个页面通常是由服务端提供的。
1. 这个页面会向服务端发送一个请求，包含了二维码的标识符和生成时间戳等信息。
1. 服务端根据二维码的标识符和生成时间戳等信息验证该请求是否有效。如果请求有效，服务端就可以认为用户已经成功登录，向客户端返回登录成功的信息。
1. 客户端接收到登录成功的信息后，跳转到用户的个人中心等页面。

扫码登录的优点在于用户无需手动输入用户名和密码等敏感信息，减少了用户在登录过程中的操作，提高了用户体验。同时，扫码登录也可以提高登录的安全性，减少了用户密码泄露的风险。

#### 前端如何实现即时通讯？

前端实现即时通讯可以借助以下技术：

1. **WebSocket**：WebSocket 是一种基于 TCP 协议的双向通信协议，可以在浏览器和服务器之间创建持久性的连接，实现实时通信。在前端中，可以使用 JavaScript WebSocket API 创建 WebSocket 连接，向服务器发送和接收消息。
1. **短轮询**：短轮询就是客户端定时发送请求，获取服务器上的最新数据。这种方式不是真正的即时通讯，但一定程度上可以模拟即时通讯的效果。优点是浏览器兼容性好，实现简单，缺点是实时性不高，资源消耗高，存在较多无用请求，影响性能。
1. **Ajax 长轮询**：Ajax 长轮询是一种模拟实时通信的技术。它通过不断向服务器发送请求，服务器收到请求后，如果有新数据，则立即返回数据给客户端，否则会等待一段时间再返回响应。客户端收到响应后再次发起请求，循环这个过程。
1. **SSE**：SSE（Server-Sent Events）是一种基于 HTTP 协议的服务器推送技术。它允许服务器向客户端发送消息，而不需要客户端先发起请求。在前端中，可以使用 JavaScript EventSource API 来监听服务器发送的事件和数据。
1. **WebRTC**：WebRTC 是一种支持浏览器之间实时音视频通信的技术。它可以通过浏览器之间的点对点连接来实现通信，不需要服务器进行中转。

以上是几种常用的前端实现实时通讯的技术，可以根据实际需求选择合适的技术来实现。

#### 什么是 WebSocket？有什么优缺点？

WebSocket 是一种基于 TCP 协议的双向通信协议，它在浏览器和服务器之间创建持久性的连接，实现实时通信。

WebSocket 的优点包括：

1. **实时性好**：WebSocket 可以在客户端和服务器之间建立长连接，实现实时双向通信，与 HTTP 请求-响应模式相比，响应速度更快，延迟更低。
1. **传输效率高**：WebSocket 数据帧比较小，通信过程中只需要传输少量的控制信息，因此相对于 HTTP 请求，WebSocket 的传输效率更高。
1. **支持跨域通信**：WebSocket 支持跨域通信，可以在不同域之间建立连接。
1. **支持二进制数据**：WebSocket 支持发送二进制数据，例如音频、视频等。

WebSocket 的缺点包括：

1. **兼容性问题**：WebSocket 协议并不是所有浏览器都支持，需要使用一些 polyfill 或者降级方案来兼容不支持的浏览器。
1. **安全问题**：WebSocket 连接需要在客户端和服务器之间建立长连接，如果没有正确的安全措施，可能会被攻击者利用来进行 DDos 攻击或者数据泄露等安全问题。

总之，WebSocket 是一种强大的实时通信技术，可以用于实现在线聊天、多人协作等应用场景。它的优点在于实时性好、传输效率高、支持跨域通信和发送二进制数据等，但也存在兼容性和安全问题。

#### 什么是短轮询？有什么优缺点？

短轮询是一种通过不断向服务器发送 HTTP 请求来获取最新数据的通信方式。客户端发起请求后，服务器会立即响应并返回最新数据，然后客户端再次发起请求，如此往复，形成一个轮询的过程。

短轮询的优点是简单易实现，可以通过简单的 AJAX 请求和响应就可以完成，不需要特殊的协议或技术支持。另外，由于每次请求都是独立的，因此可以比较灵活地控制请求的频率和数据大小。

短轮询的缺点在于效率低下，因为每次请求都需要与服务器进行一次 HTTP 连接，因此会造成较大的网络开销。同时，由于轮询的时间间隔通常比较短，所以服务器需要频繁地响应请求，导致服务器负载较大。

总之，短轮询是一种简单易用但效率较低的通信方式，适用于需要实时性不高、数据量较小的应用场景。如果需要更高效的通信方式，可以考虑长轮询、WebSocket 等技术。

#### 什么是长轮询？有什么优缺点？

长轮询（Long Polling）是一种基于 HTTP 的服务器推送技术。与短轮询不同，长轮询并不是简单地周期性地向服务器发送请求，而是在客户端向服务器发送请求后，服务器保持连接不断开，直到有数据更新才返回响应，客户端接收到响应后再次发起请求，如此往复形成一种“轮询”的过程。

长轮询的优点是相对于短轮询更加高效，因为长轮询的连接在数据未更新时可以一直保持，减少了不必要的网络开销。同时，长轮询相比于传统的轮询方式，可以更快地响应数据更新，实现了较高的实时性。

长轮询的缺点在于实现相对短轮询要复杂一些，需要在客户端和服务器之间保持长连接，并实现合适的超时机制。另外，长轮询的连接时间比较长，需要占用服务器资源，如果同时有大量的连接请求，可能会导致服务器负载过高。

#### 什么是 SSE？有什么优缺点？

Server-sent Events（SSE）是一种服务器向客户端推送事件的技术，它允许服务器在任何时刻向客户端推送数据和信息。相比于 WebSocket，SSE 更适用于服务器向客户端单向推送数据的场景，比如实时通知、实时数据更新等。WebSocket 则更适用于双方需要相互通信的场景，比如聊天室应用。[0][4]

SSE 协议完全复用现有的 HTTP 协议，因此使用 HTTP Client Library 和 HTTP Server Library 即可。唯一需要注意的是，HTTP response 里 header Content-Type 的值是 text/event-stream。服务器通过发送一个包含数据的文本文件，让客户端通过事件监听器获取到这些数据。

SSE 的优点包括：

1. 实现简单，完全复用现有的 HTTP 协议。
1. 基于 HTTP 协议，因此可以跨越所有防火墙。
1. 支持自定义事件类型，可根据业务需要自行定义消息类型。
1. 可以使用 EventSource API 直接处理数据，不需要考虑数据格式和解析问题。

SSE 的缺点包括：

1. SSE 只支持从服务器到客户端的单向实时通信，无法支持双向实时通信。
1. SSE 在长时间连接时可能会出现连接中断的问题，需要在客户端进行重连。
1. SSE 对浏览器的兼容性不够好，目前主流浏览器都支持 SSE，但是 IE 和 Edge 的支持不够完善。

总的来说，SSE 是一种简单、轻量、基于 HTTP 协议的服务器向客户端推送事件的技术，适用于单向实时通信的场景。

#### WebRTC 是什么？有什么优缺点？

WebRTC（Web Real-Time Communication）是一种用于浏览器之间实时通信的技术标准。它允许网页应用程序通过简单的 JavaScript API 在浏览器之间传输音频、视频和数据，无需插件或其他第三方软件支持。

WebRTC 的优点包括：

1. **实时性**：WebRTC 延迟低，可以实现实时音视频通话和数据传输。
1. **端到端加密**：WebRTC 提供了端到端加密功能，可以确保数据传输的安全性和隐私性。
1. **跨平台支持**：WebRTC 可以在支持 WebRTC 的现代浏览器上运行，支持跨平台。
1. **开放性**：WebRTC 是开放标准，任何人都可以使用。

WebRTC 的缺点包括：

1. **兼容性问题**：WebRTC 还不是所有浏览器和设备都支持，需要在开发中注意浏览器兼容性。
1. **NAT 穿透问题**：在使用 WebRTC 进行点对点通信时，需要解决 NAT 穿透的问题。
1. **可扩展性问题**：WebRTC 对于大规模部署和高并发使用的支持尚不完善，需要进一步优化。

总体来说，WebRTC 提供了一种非常方便的实时通信方式，能够轻松实现音视频通话和数据传输，但在开发和部署中需要注意其兼容性、安全性、可扩展性等问题。

#### 前端大文件上传怎么实现的？

前端大文件上传可以通过以下几种方式实现：

1. **分片上传**：将大文件分成若干个小块，分别上传，最后在服务器端合并成一个完整的文件。这种方式可以提高上传速度，并且在上传失败时可以重传部分文件块。
1. **断点续传**：在上传大文件时，如果中途出现网络问题或上传中断，可以记录已经上传的部分，等到网络恢复或重新上传时，只需要上传缺失的部分。这种方式可以节省上传时间，并且保证上传的完整性。
1. **流式上传**：将文件按照流的方式上传，而不是一次性上传整个文件。这种方式可以减少内存占用，适用于上传大文件时内存不足的情况。

在实现这些上传方式时，通常会使用一些第三方库或工具，如 jQuery、axios、formidable、multer 等，这些工具可以方便地完成文件上传功能的开发。

#### 前端怎么实现分片上传？

前端实现分片上传的一般步骤如下：

1. 将大文件切分成多个小块，一般大小在 1-5MB 之间，可以根据实际需求进行调整。
1. 遍历这些小块，使用 FormData 对象将每个小块上传到服务器，注意需要给每个小块设置唯一的标识。
1. 在上传每个小块时，需要设置请求头 Content-Range 来指定上传数据的范围，如：Content-Range: bytes 0-1048575/2000000，其中 1048575 为当前小块的末尾位置，2000000 为整个文件的大小。
1. 上传完成后，服务器会返回上传成功的响应，可以记录已经上传成功的小块，以备后续合并文件使用。
1. 最后一块上传完成后，发送一个合并请求到服务器，服务器将已上传的小块合并成一个完整的文件。
1. 如果上传过程中发生错误，可以使用断点续传的方式重新上传失败的小块。

以下是一个基本的分片上传代码示例，以使用 axios 库为例：

```
const CHUNK_SIZE = 5 * 1024 * 1024; // 每个块的大小

// 将文件切分成多个块
function createChunks(file) {
  const chunks = [];
  let start = 0;
  while (start < file.size) {
    const end = Math.min(start + CHUNK_SIZE, file.size);
    chunks.push(file.slice(start, end));
    start += CHUNK_SIZE;
  }
  return chunks;
}

// 上传单个块
function uploadChunk(file, chunk, index, total) {
  const formData = new FormData();
  formData.append('file', chunk, `${file.name}_${index}`);
  formData.append('index', index);
  formData.append('total', total);
  return axios.post('/api/upload', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
      'Content-Range': `bytes ${chunk.start}-${chunk.end - 1}/${file.size}`,
    },
  });
}

// 上传所有块
function uploadChunks(file, chunks) {
  const promises = chunks.map((chunk, index) =>
    uploadChunk(file, chunk, index + 1, chunks.length)
  );
  return Promise.all(promises);
}

// 合并所有块
function mergeChunks(file, chunks) {
  const formData = new FormData();
  formData.append('filename', file.name);
  formData.append('filesize', file.size);
  formData.append('chunkcount', chunks.length);
  return axios.post('/api/merge', formData);
}

// 上传文件
async function uploadFile(file) {
  const chunks = createChunks(file);
  await uploadChunks(file, chunks);
  await mergeChunks(file, chunks);
}
```

在实际应用中，还需要考虑上传进度、错误处理、断点续传等问题。

#### 前端怎么实现断点续传？

前端实现断点续传的一般步骤如下：

1. 当文件上传失败时，记录已经上传的文件块编号和字节数，并在下次上传时发送给服务器。
1. 服务器收到上传请求时，根据已经上传的文件块编号和字节数，返回已经上传的文件块信息，客户端使用已上传的文件块信息进行断点续传。

以下是一个基本的断点续传代码示例，以使用 axios 库为例：

```
const CHUNK_SIZE = 5 * 1024 * 1024; // 每个块的大小

// 将文件切分成多个块
function createChunks(file) {
  const chunks = [];
  let start = 0;
  while (start < file.size) {
    const end = Math.min(start + CHUNK_SIZE, file.size);
    chunks.push(file.slice(start, end));
    start += CHUNK_SIZE;
  }
  return chunks;
}

// 上传单个块
function uploadChunk(file, chunk, index, total) {
  const formData = new FormData();
  formData.append('file', chunk, `${file.name}_${index}`);
  formData.append('index', index);
  formData.append('total', total);
  return axios.post('/api/upload', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
      'Content-Range': `bytes ${chunk.start}-${chunk.end - 1}/${file.size}`,
    },
  });
}

// 上传所有块
async function uploadChunks(file, chunks, uploadedChunks) {
  const promises = chunks.map(async (chunk, index) => {
    // 检查当前块是否已经上传
    if (uploadedChunks.includes(index + 1)) {
      return;
    }
    // 上传当前块
    await uploadChunk(file, chunk, index + 1, chunks.length);
    // 记录已经上传的块
    uploadedChunks.push(index + 1);
    // 保存已上传的块信息
    localStorage.setItem(`${file.name}_chunks`, JSON.stringify(uploadedChunks));
  });
  await Promise.all(promises);
}

// 合并所有块
function mergeChunks(file, chunks) {
  const formData = new FormData();
  formData.append('filename', file.name);
  formData.append('filesize', file.size);
  formData.append('chunkcount', chunks.length);
  return axios.post('/api/merge', formData);
}

// 上传文件
async function uploadFile(file) {
  const chunks = createChunks(file);
  // 获取已经上传的块信息
  const uploadedChunks = JSON.parse(localStorage.getItem(`${file.name}_chunks`)) || [];
  await uploadChunks(file, chunks, uploadedChunks);
  await mergeChunks(file, chunks);
}
```

在实际应用中，还需要考虑上传进度、错误处理、断点续传过程中网络中断等问题。

#### 写一个前后端分离的 web 系统的部署架构？

前后端分离的 web 系统一般采用前端单页应用（SPA）和后端 API 服务分离的架构。部署架构需要将前后端分别部署在不同的服务器上。

以下是一个可能的部署架构：

前端部署：

1. 将前端代码部署在一个静态文件服务器上，如 Nginx 等，可以利用 CDN 缓存加速静态资源的访问。
1. 静态文件服务器配置路由规则，将所有请求转发到前端应用的入口文件。
1. 前端应用可以使用 Vue.js、React 等前端框架实现，运行在客户端浏览器上，通过前端路由跳转不同的页面，向后端 API 服务器发起 HTTP 请求，获取数据并进行渲染。

后端部署：

1. 将后端 API 服务部署在一台或多台应用服务器上，如 Node.js、Java、Python 等。
1. 后端 API 服务可以使用 RESTful API 风格设计接口，接收来自前端的 HTTP 请求，查询、修改数据库，并以 JSON 格式返回数据。
1. 后端应用可以部署在 Docker 容器中，使用 Docker Compose 进行容器编排和部署，保证环境一致性和易于管理。

数据库部署：

1. 数据库可以部署在一台或多台数据库服务器上，如 MySQL、MongoDB、Redis 等。
1. 数据库可以使用主从复制、分片等技术，提高读写性能和可用性。
1. 数据库可以使用云服务提供商的数据库服务，如 AWS RDS、Azure SQL、阿里云 RDS 等，可以提供高可用、自动备份、容灾等功能。

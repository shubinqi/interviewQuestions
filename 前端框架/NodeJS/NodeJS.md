<!--
 * @Author: Shu Binqi
 * @Date: 2023-02-28 19:06:05
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-04 03:29:02
 * @Description: NodeJS 面试题（26题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\前端框架\NodeJS\NodeJS.md
-->

https://juejin.cn/post/6844903951742025736

#### 请介绍一下 Node 里的模块是什么？

在 Node 中，模块是指一个 JavaScript 文件，它包含了一些封装好的 JavaScript 方法、JSON 数据、编译过的 C/C++拓展等。模块是 Node 的一个重要概念，用于将代码组织成可重用的单元。以下是一些要点：

- 模块与文件是一一对应的，一个 Node.js 文件就是一个模块。
- Node 中可以将模块分为三类：内置模块、自定义模块和第三方模块。内置模块是 Node 官方提供的，例如 fs、path、http 等，自定义模块是我们自己创建的.js 文件，而第三方模块是非官方提供的模块，需要通过 npm 安装后才能使用。
- Node.js 的内置模块提供了访问网络、操作文件等核心功能，npm 里的模块库就是基于这些顶层 API 的进一步封装。
- Node.js 中的模块可以被看作是 JavaScript 库，是整体代码中你想放在一起的某个部分（比如函数集），你会想把这部分代码相对独立于代码库中的其它部分，可以把事情区分清楚。
- 模块可以通过 require()函数引入，并通过 module.exports 或 exports 对象导出。例如：

```
// module1.js
exports.func1 = function(){
        console.log('func1 from module1 called');
}

// module2.js
var in_module1 = require('./module1.js');
in_module1.func1();
exports.func2 = function(){
        console.log('func2 from module2 called');
}

// module3.js
var in_module2 = require('./module2.js');
in_module2.func2();
```

在这个例子中，module1.js 导出了一个名为 func1 的函数，module2.js 引入了 module1.js，并调用了其中的 func1 函数，同时还导出了一个名为 func2 的函数。module3.js 引入了 module2.js，并调用了其中的 func2 函数。最后，运行 module3.js 会输出“func1 from module1 called”和“func2 from module2 called”。

- 模块在首次被引入时会被缓存，之后的引入将直接从缓存中读取。可以通过 module.cache 对象查看当前缓存的模块。
- Node.js 12 版本开始支持 ES 模块，可以使用 import/export 语法进行模块导入导出。

#### 请介绍一下 require 的模块加载机制？

在 Node.js 中，使用 require 函数来加载模块。当 require 函数调用时，Node.js 会按照以下方式查找和加载模块：

1. 根据指定的模块标识符（通常是文件路径），Node.js 会首先检查是否是内置模块。内置模块是 Node.js 自带的模块，可以直接通过模块名进行加载，无需指定路径。
1. 如果不是内置模块，Node.js 将尝试从文件系统中加载文件，此时需要指定文件路径。在这一步中，Node.js 将尝试多次添加不同的文件扩展名（例如 .js、.json 等），以找到一个存在的文件。
1. 如果找到一个指定的文件，则 Node.js 将执行文件中的代码，并将 module.exports 对象作为模块的导出对象返回。
1. 如果在指定的路径中找不到文件，则 Node.js 将查找该路径下的 node_modules 目录。Node.js 将重复上述过程，从 node_modules 目录中查找模块，直到找到为止。
1. 如果在所有可能的路径中都没有找到模块，则 Node.js 将抛出一个 ModuleNotFoundError 错误。

需要注意的是，在 Node.js 中，模块加载是同步的（除了在特定的情况下，可以使用异步加载模块的 API）。这意味着，在加载一个模块时，Node.js 将阻塞执行程序，直到该模块加载完成并返回模块对象。因此，在编写 Node.js 应用程序时，需要注意避免加载过多的模块或加载时间过长的模块，以避免阻塞程序执行。

#### 请介绍一下 Node 事件循环的流程？

Node 事件循环是 Node.js 中实现异步 I/O 的核心机制之一，它通过一种事件驱动的方式来实现非阻塞式 I/O 操作。下面是 Node 事件循环的基本流程：

1. Node 首先会将几乎所有的 I/O 操作交给底层操作系统来处理，例如网络请求、文件读写等。
1. 当底层操作系统完成了某个 I/O 操作时，它会向 Node 发送一个信号。
1. Node 接收到信号后，会将这个 I/O 操作的回调函数添加到一个待执行的队列中。
1. Node 会不断地检查这个待执行的队列，如果发现队列中有回调函数，就会取出一个并执行。
1. 执行完回调函数后，如果队列中还有其它的回调函数，就继续取出并执行，直到队列为空。
1. 如果队列为空，Node 就会阻塞在这里等待新的事件出现，等待的过程中也会检查是否有定时器已到期。
1. 当新的事件出现时，重复以上步骤。

需要注意的是，在事件循环的每个阶段中，Node 会执行特定类型的操作。例如，定时器阶段会执行定时器的回调函数，而 I/O 阶段则会执行 I/O 操作的回调函数。因此，Node 事件循环的流程并不是一成不变的，它会根据具体的情况做出相应的调整，以保证异步操作的高效执行。

#### 在每个 tick 的过程中，如何判断是否有事件需要处理呢？

在每个 tick 的过程中，事件循环会检查它的“阶段”（phase）来决定是否有事件需要处理。事件循环共有 6 个阶段，分别是：

1. **timers 阶段**：处理定时器，即执行那些 setTimeout() 和 setInterval() 中到期的回调函数。
1. **pending callbacks 阶段**：执行延迟到下一个循环迭代的 I/O 回调函数。
1. **idle, prepare 阶段**：仅在内部使用。
1. **poll 阶段**：处理除定时器和系统事件以外的其他事件，如 I/O 请求和网络请求等。在进入该阶段时，如果 poll 队列不为空，则事件循环将遍历队列并同步地执行回调函数，直到队列为空或达到系统限制。
1. **check 阶段**：执行 setImmediate() 中注册的回调函数。
1. **close callbacks 阶段**：执行那些由于 socket 或者定时器等引起的关闭回调函数。

如果在当前事件循环迭代中没有事件需要处理，则会进入下一次事件循环迭代。事件循环会重复以上步骤，直到程序结束或事件队列为空。

#### 请描述一下整个异步 I/O 的流程？

异步 I/O 是指在 Node.js 中通过回调函数实现的非阻塞式 I/O 操作。它的实现流程可以概括为以下几个步骤：

1. 事件循环启动，开始等待事件的触发。
1. Node.js 启动异步 I/O 操作，并将回调函数加入到事件循环的任务队列中。
1. 当异步 I/O 操作完成后，Node.js 将回调函数加入到事件循环的任务队列中，等待下一次 tick 执行。
1. 事件循环每次 tick 执行时，会检查任务队列中是否有任务需要执行，如果有，则按照加入的顺序依次执行回调函数。
1. 回调函数执行完成后，事件循环继续等待下一次事件的触发。

需要注意的是，Node.js 中的异步 I/O 操作并不是在后台线程中执行的，而是在主线程中通过事件循环的方式实现的。这种机制使得 Node.js 可以高效地处理大量的并发请求。

#### 如何查看 V8 的内存使用情况？

要查看 V8 的内存使用情况，可以使用 Chrome DevTools 的 Memory 面板来查看。具体步骤如下：

1. 在 Chrome 中打开要检查内存使用情况的页面。
1. 打开开发者工具（DevTools）。
1. 选择 Memory 面板。
1. 点击 Take Heap Snapshot 按钮来记录当前内存使用情况。
1. 等待快照生成完毕后，可以查看内存分配情况、对象的数量和大小、内存泄漏等信息。

另外，可以在 Node.js 中使用 process.memoryUsage() 方法来查看 Node.js 进程的内存使用情况，例如：

```
const mem = process.memoryUsage();
console.log(mem);
```

这个方法返回一个包含内存使用情况的对象，包括堆、外部内存和操作系统内存的使用情况。

#### V8 的内存限制是多少？

V8 是 Google 开发的 JavaScript 引擎，它的内存限制在不同的系统下是不一样的。以下是不同来源的解释和数据：

- 64 位系统下，V8 的堆内存的最大值为 1464MB，而在 32 位系统中则为 732MB。其中，老生代内存为 1400MB，新生代内存为 32MB（64 位）或 16MB（32 位）。
- V8 的默认堆内存上限是可以修改的，通过 Node 启动时传递--max-old-space-size 或--max-new-space-size 参数，或者通过 NODE_OPTIONS 这个系统环境变量来配置。在 64 位系统中，V8 的最大老生代限制为 2G，而在 32 位系统中为 1G。如果物理内存超过 16G，则 64 位系统的最大堆内存限制为 4G。
- Buffer 是基于 C++，不受 V8 内存限制，使用的内存不在 1.4G 的计算范围之内。但 Buffer 的长度由 Node.js 限制，定义在 GitHub 上，而不是受内存空间限制。
- V8 中的新生代内存主要通过 Scavenge 算法进行垃圾回收，它将新生代内存一分为二，每一部分的空间成为 semispace（半空间），在这两个 semispace 中，只有一个处于使用中，成为 From 空间，另一个处于闲置状态，称为 To 空间。
- V8 的堆内存限制可以通过代码获取，通过 v8.getHeapStatistics()方法可以获取到以下信息：

```
{
  total_heap_size: 4882432,
  total_heap_size_executable: 524288,
  total_physical_size: 3544392,
  total_available_size: 4342237384,
  used_heap_size: 3967272,
  heap_size_limit: 4345298944, // 堆内存限制
  malloced_memory: 254120,
  peak_malloced_memory: 90624,
  does_zap_garbage: 0,
  number_of_native_contexts: 1,
  number_of_detached_contexts: 0
}
```

其中，heap_size_limit 表示堆内存限制。

- V8 的内存限制不仅仅受到硬件的影响，还会根据设备的性能来设置限制。V8 会根据物理内存和 V8 的最大内存限制来计算堆内存限制，其计算公式为：堆内存限制 = min([物理内存 / 4 * 调整系数], V8 最大限制)，其中调整系数为 sizeof(void*) / 4，sizeof(void*)是系统指针长度，64 位是 8，32 位是 4。

#### 为什么 V8 会有这样的内存限制？

V8 会有这样的内存限制，主要原因在于 Node 基于 V8 的构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。V8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面的所有需求，但在 Node 中，却限制了开发这个随心所欲的服务器端应用的可能性。V8 的垃圾回收策略主要基于分代式垃圾回收机制，对象的生存周期长短不一，不同的算法只能针对特定情况产生较为良好的效果。在应用中，对象的生存周期长短不一，不同的算法只能针对特定情况产生较为良好的效果。因此，V8 的内存限制主要是为了保证垃圾回收的效率和性能，并防止系统崩溃。

总之，V8 的内存限制是为了保证垃圾回收的效率和性能，并防止系统崩溃。这个限制主要是为了防止 V8 进程使用过多的 RAM，从而导致系统变慢或崩溃。V8 的内存限制是可以通过 Node 启动时传递--max-old-space-size 或--max-new-space-size 参数来修改的。如果是 Node8.x 及以上的版本，还可以通过 NODE_OPTIONS 这个系统环境变量来配置。

#### V8 的内存分代和回收算法请简单讲一讲？

V8 是一种采用分代式垃圾回收的 JavaScript 引擎，它将内存分为新生代和老生代两个代，并使用不同的回收算法对不同代的对象进行回收。

新生代内存主要存放生命周期较短的对象，一般存活时间不超过几次垃圾回收，新生代内存使用 Scavenge 算法进行回收。Scavenge 算法的核心思想是将新生代内存分为两个区域，一个是对象存活空间（from space），一个是空闲空间（to space），当 from space 被占用满时，就执行一次垃圾回收，将存活的对象复制到 to space 中，同时将 from space 中的对象标记为不可达，之后交换 from space 和 to space 的角色，完成垃圾回收。

老生代内存主要存放生命周期较长的对象，一般存活时间较长，老生代内存使用标记清除（Mark-Sweep）和标记整理（Mark-Compact）算法进行回收。标记清除算法首先对所有对象进行标记，标记为不可达的对象进行清除，但是这样会导致内存空间的碎片化，因此还需要使用标记整理算法对内存空间进行整理。标记整理算法的核心思想是将存活的对象向内存空间一端移动，然后将空间一端的所有对象清除。

V8 还有增量标记算法，在垃圾回收时避免长时间的卡顿。增量标记算法可以将标记过程分成多个小步骤，每个小步骤执行时间不会超过一定的时间阈值，执行完当前小步骤后再让 JavaScript 应用逻辑执行，这样可以让应用逻辑和垃圾回收交替执行，减少垃圾回收对应用逻辑的占用时间。

#### 老生代算法？新生代算法？

V8 对象分配空间的方式有两种：新生代（New Space）和老生代（Old Space）。

新生代中存活时间较短的对象使用 Scavenge 算法进行垃圾回收。Scavenge 算法采用 Cheney 算法实现，分为两个空间：From 空间和 To 空间。新分配的对象都存储在 From 空间，当 From 空间快被写满时，就会触发垃圾回收。垃圾回收时，将 From 空间中存活的对象复制到 To 空间，同时还要将 From 空间和 To 空间进行翻转，使得 To 空间变为 From 空间。这个过程中会暂停 JS 线程。

老生代中存活时间较长的对象使用 Mark-Sweep 和 Mark-Compact 算法进行垃圾回收。Mark-Sweep 算法将可达对象标记为“活着”，未标记的对象则认为是垃圾。Mark-Compact 算法是 Mark-Sweep 算法的增强版，它可以将存活的对象向一端移动，然后直接清除端边界外的所有对象。这样空闲的空间会形成一个大的连续的空间，方便下次内存分配。Mark-Sweep 和 Mark-Compact 算法会暂停 JS 线程，影响性能。为了避免频繁地执行垃圾回收导致应用程序性能下降，老生代设置了一个内存阈值，当达到一定的内存占用量后，会触发一次全量垃圾回收。

#### 标记清除算法的问题？

标记清除算法是一种常见的垃圾回收算法，其主要步骤是标记所有的活动对象，然后清除未标记对象。虽然这种算法可以有效地回收内存，但是它也存在一些问题：

1. **碎片化问题**：标记清除算法会将内存分为已标记和未标记两部分，清除未标记的对象后会产生大量的内存碎片，而这些碎片无法被利用，导致内存空间被浪费。
1. **效率问题**：标记清除算法需要扫描整个堆内存来标记所有的活动对象，而随着堆内存的增大，这个过程会变得越来越耗时，导致垃圾回收的效率变低。
1. **内存泄漏问题**：标记清除算法无法处理循环引用的情况，即如果两个对象相互引用，但是它们都不再被程序所引用，那么标记清除算法就无法将它们回收，导致内存泄漏。

针对这些问题，现代的垃圾回收算法已经采用了更加复杂的技术，例如标记-压缩算法、复制算法、增量标记算法等，以提高垃圾回收的效率和减少内存碎片化问题。

#### 哪些情况会造成 V8 无法立即回收内存？

V8 的垃圾回收器使用的是增量标记算法，因此在进行垃圾回收时需要遍历对象图，并对每个可达的对象进行标记，最后清理掉所有未被标记的对象。这个过程中，如果有以下情况发生，就可能会导致 V8 无法立即回收内存：

1. 正在进行垃圾回收的时候，JavaScript 线程依然在执行代码，从而导致标记的对象图不完整，有些未被标记的对象无法被回收。
1. 如果在 JavaScript 代码中使用了一些 V8 无法识别的 C++ 对象，比如通过 C++ 扩展创建的对象，V8 就无法对它们进行垃圾回收，这也可能导致内存泄漏。
1. 如果 JavaScript 代码中创建了大量的短生命周期对象，这些对象可能会在新生代中被频繁创建和销毁，从而导致 V8 无法及时回收它们占用的内存。
1. 如果 JavaScript 代码中创建了很多闭包，这些闭包中可能会包含对其他对象的引用，从而导致这些对象无法被垃圾回收。

为了避免以上情况的发生，我们可以优化 JavaScript 代码的编写方式，比如尽可能少创建短生命周期对象、避免使用闭包、尽可能少使用 C++ 扩展等，以减少内存泄漏的风险。同时，在编写 JavaScript 代码的时候，我们也可以使用一些工具来帮助我们检测内存泄漏的问题，比如 Chrome 浏览器自带的开发者工具中的 Memory 标签页。

#### 请谈一下内存泄漏是什么？

内存泄漏是指在程序中动态分配的内存由于某些原因，程序没有释放或无法释放，导致内存空间不能被再次使用的现象。简单地说，就是程序申请了一段内存空间，但是没有及时释放，这样就会导致内存使用过多，最终会导致程序崩溃或者系统变慢。

常见的内存泄漏情况包括：未释放的对象或数组、未断开的事件监听器、无限递归等。

内存泄漏会对系统造成严重的影响，因为长时间运行的程序会导致内存不断增加，直到内存耗尽，程序会变得非常缓慢或者崩溃。因此，开发者在编写代码时需要注意及时释放不再使用的内存，防止出现内存泄漏的问题。

#### 常见内存泄漏的原因和排查的方法？

内存泄漏是指程序中分配的内存空间无法被正常释放或回收，导致内存占用不断增加，最终导致程序崩溃或系统资源耗尽的问题。常见的内存泄漏包括：

1. **意外的全局变量引用**：在函数中没有使用 var 或 let 等关键字声明变量，而是直接赋值，导致变量成为全局变量，不会被回收。
1. **定时器未清除**：使用 setTimeout 或 setInterval 创建的定时器，如果没有被清除，就会一直占用内存。
1. **循环引用**：在对象之间相互引用，导致这些对象都无法被回收，例如 A 对象引用了 B 对象，而 B 对象又引用了 A 对象。
1. **闭包**：在函数内部定义的变量被外部函数引用，导致这些变量一直被引用而无法被回收。

排查内存泄漏问题的方法有：

1. **使用内存分析工具**：可以通过工具来查看内存占用情况，找出占用内存较多的对象或变量。
1. **代码审查**：检查代码中是否存在未清除的定时器、循环引用或闭包等问题。
1. **内存快照分析**：通过拍摄内存快照来分析内存泄漏的原因和位置。
1. **性能测试**：通过性能测试来发现潜在的内存泄漏问题，例如重复执行某个功能时内存占用是否会不断增加。
1. **日志记录**：在代码中添加日志记录，输出内存占用情况和对象引用情况等信息，以便分析问题。

#### 新建 Buffer 会占用 V8 分配的内存吗？

是的，新建一个 Buffer 对象会占用 V8 分配的内存。Buffer 是 Node.js 中处理二进制数据的一种方式，它本质上是一段内存，表示一定大小的字节数组，可以通过构造函数来创建。

例如，通过以下代码创建一个大小为 10 的 Buffer：

```
const buf = Buffer.alloc(10);
```

上述代码创建了一个大小为 10 字节的 Buffer 对象，它会占用 V8 分配的内存。如果创建的 Buffer 对象没有被释放，就会导致内存泄漏。因此，在使用完毕后，需要手动释放 Buffer 对象的内存，例如通过 buf = null 将变量赋值为 null，让其成为垃圾对象，在垃圾回收时被回收释放内存。

#### Buffer 的内存分配机制？

在 Node.js 中，Buffer 类用于处理二进制数据。Buffer 是一个类似于数组的对象，但它主要用来操作字节。在 Node.js 中，Buffer 对象是全局对象，因此无需使用 require() 来引入。

Buffer 的内存分配机制是通过 V8 引擎中的 C++ 层面的 ArrayBuffer 类实现的。ArrayBuffer 对象表示一段二进制数据，它内部有一个指针指向分配的内存区域，这个内存区域是由 V8 引擎进行管理的。

当创建一个 Buffer 对象时，Node.js 会为这个 Buffer 分配一段连续的内存区域，这个内存区域大小是固定的，不会发生变化。如果创建的 Buffer 对象大小超过了这个内存区域大小，Node.js 会将这个 Buffer 对象存储在新的内存区域中，并将原有内存区域释放。因此，在频繁创建大型 Buffer 对象时，可能会导致内存分配的开销较大，从而影响应用的性能。

需要注意的是，Buffer 对象的内存不是由 V8 引擎的垃圾回收机制进行管理的，而是由 Node.js 的内存管理模块进行管理。因此，如果在使用 Buffer 对象时，没有正确地释放它们所占用的内存，就可能会导致内存泄漏问题。

#### Buffer 乱码问题？

Buffer 是 Node.js 中用于处理二进制数据的类，它存储的是一组字节（byte）数据，可以用于在 Node.js 应用程序中处理网络数据、文件系统操作等场景。当在 Node.js 中使用 Buffer 读取或写入二进制数据时，如果不使用正确的编码方式将 Buffer 转化为字符串，就有可能出现乱码问题。

乱码问题通常出现在使用默认编码方式（例如 utf8）解码 Buffer 时，当被解码的二进制数据包含非 utf8 编码的字节序列时，就会产生乱码。为了解决这个问题，可以尝试使用其他编码方式对 Buffer 进行转换，例如 ASCII、Latin-1 等编码方式。

另外，还需要注意的是，在处理网络数据时，需要正确设置数据的编码方式。例如，如果一个 HTTP 请求返回的 Content-Type 响应头中指定了编码方式为 GBK，那么在处理响应数据时，需要使用 GBK 编码方式对数据进行解码，否则也会产生乱码问题。

#### webSocket 与传统的 http 有什么优势？

WebSocket 是一种基于 TCP 的协议，与传统的 HTTP/HTTPS 协议不同。相对于 HTTP，WebSocket 有以下优势：

1. **实时性更好**：HTTP 是无状态协议，每次通信都需要建立连接，通信完毕后再断开连接，每次通信都需要重新建立连接，造成较大的开销，且 HTTP 请求只能由客户端发起，服务器不能主动向客户端推送数据。而 WebSocket 在客户端和服务器建立连接之后，可以实现双向数据传输，服务器可以主动向客户端推送数据，实现了实时性更好的通信。
1. **更小的数据传输量**：HTTP 协议在传输数据时需要携带大量的头信息，而 WebSocket 协议中的头信息较小，因此相对于 HTTP，WebSocket 在传输数据时需要的数据量更少。
1. **更好的二进制数据支持**：HTTP 协议只能传输文本数据，而 WebSocket 协议支持传输二进制数据。
1. **更好的跨域支持**：WebSocket 的跨域支持更好，可以实现跨域通信。

综上所述，WebSocket 在实时通信和数据传输量方面有明显的优势。

#### https 用哪些端口进行通信？这些端口分别有什么用？

HTTPS 默认使用 443 端口进行通信。该端口是 HTTPS 通信的标准端口，主要用于将数据进行加密和解密，确保传输的数据不被窃听和篡改。

除此之外，HTTPS 通信过程中，还会使用以下端口：

1. **443 端口**：用于将数据进行加密和解密，确保传输的数据不被窃听和篡改。
1. **80 端口**：用于 HTTP 协议，主要用于客户端向服务器发送 HTTP 请求。
1. **8080 端口**：有时用于 HTTP 协议的备用端口。
1. **8443 端口**：用于 HTTPS 协议的备用端口，一般情况下不使用。

需要注意的是，在进行 HTTPS 通信时，如果使用了非标准端口（如 8080、8443 等），在访问时需要在 URL 中明确指定端口号。

#### 身份验证过程中会涉及到密钥，对称加密，非对称加密，摘要的概念，请解释一下？

身份验证过程中，常常需要使用到密码学相关的概念，下面是常见的概念及其解释：

1. **密钥**（Key）：在密码学中，密钥是用于加密和解密数据的秘密值，是一串数字、字母或符号的集合。密钥的安全性是保证数据安全的基础。
1. **对称加密**（Symmetric Encryption）：对称加密是指加密和解密使用同一个密钥的加密方式。常见的对称加密算法有 DES、3DES、AES 等。由于对称加密使用同一个密钥，因此密钥的分发和管理是对称加密的一个难点。
1. **非对称加密**（Asymmetric Encryption）：非对称加密是指加密和解密使用不同密钥的加密方式。常见的非对称加密算法有 RSA、DSA 等。非对称加密通过公钥和私钥来实现加密和解密，公钥是公开的，任何人都可以获取，而私钥是保密的，只有密钥持有人才能获取。
1. **摘要**（Digest）：摘要是一种固定长度的特殊算法，将任意长度的数据转化为固定长度的摘要值。常用的摘要算法有 MD5、SHA-1、SHA-256 等。摘要算法可以用于验证数据的完整性，常用于身份验证、数据签名等领域。

在身份验证过程中，可以使用上述概念进行加密、解密、签名、验证等操作，以确保身份验证的安全性。对称加密可以用于加密通信过程中的数据，非对称加密可以用于密钥的分发和管理，摘要算法可以用于验证数据的完整性。

#### 为什么需要 CA 机构对证书签名？

CA（Certificate Authority，证书授权机构）是负责颁发和管理数字证书的机构，其作用在于确保证书的真实性和合法性。

在使用 HTTPS 时，当客户端访问服务器时，服务器会返回自己的数字证书，客户端需要验证证书的真实性。证书上的公钥可以被任何人获取，因此黑客可以通过伪造证书来模拟服务器，客户端无法分辨真伪，进而陷入攻击者设置的陷阱中。

为了解决这个问题，数字证书采用了非对称加密技术，其中证书颁发机构（CA）用自己的私钥对数字证书进行签名，客户端验证证书时，需要用相应的 CA 的公钥来验证数字证书的合法性。只有 CA 私钥持有者才能签名，黑客即使获取到数字证书的公钥，也无法伪造数字证书，保证了证书的真实性和合法性。

同时，数字证书中还包含了摘要信息，该信息可以防止数字证书被篡改，保证了数字证书的完整性。

#### https 验证身份也就是 TSL/SSL 身份验证的过程？

HTTPS 的身份验证主要是 TLS/SSL 身份验证的过程，它通过数字证书来实现。TLS/SSL 身份验证主要包括以下几个步骤：

1. **客户端发起连接请求**：客户端向服务器发起连接请求，并发送一个 Client Hello 消息，该消息包含了客户端的 TLS/SSL 版本号、加密算法、随机数等信息。
1. **服务器返回证书**：服务器向客户端发送一个 Server Hello 消息，该消息包含了服务器的 TLS/SSL 版本号、加密算法、随机数等信息，并且会向客户端发送一个数字证书，该证书包含了服务器的公钥、证书的有效期、签发机构等信息。
1. **客户端验证证书**：客户端会对证书进行验证，验证证书的有效性、证书的签发机构等信息，并且会检查证书是否被吊销、是否过期等。
1. **生成共享密钥**：客户端会使用服务器的公钥来生成一个共享密钥，并将该密钥加密后发送给服务器。
1. **服务器解密共享密钥**：服务器使用自己的私钥来解密客户端发来的共享密钥，从而得到该密钥。
1. **加密通信**：客户端和服务器使用共享密钥来加密通信内容，从而实现数据的加密传输。

在上述过程中，数字证书起到了重要的作用，它用于验证服务器的身份和建立安全通信。而数字证书是由受信任的第三方机构（如 CA 机构）颁发的，因此在进行数字证书验证时，需要确保证书的有效性和真实性。

#### 请简述一下 node 的多进程架构？

Node 的多进程架构基于主从模型，由一个主进程和多个子进程组成，每个子进程都有一个独立的 V8 实例，可以执行 JavaScript 代码。这样，多个子进程可以同时处理请求，提高应用的并发能力和稳定性。

在 Node 的多进程架构中，主进程负责启动子进程和维护进程间的通信。具体实现上，Node 提供了两种进程间通信的方式：

1. **IPC**（Inter-Process Communication）：即进程间通信，可以通过 Node 的 child_process 模块实现。
1. **消息队列**：可以使用 Node 的 cluster 模块实现，通过将请求分发到子进程的消息队列中来实现进程间通信。

Node 中多进程的实现方式有两种：

1. **child_process**：通过 spawn、fork、exec 等方法创建子进程，每个子进程都有一个独立的 V8 实例，相互之间独立运行。
1. **cluster**：Node.js 中一个 Master 进程控制多个 Worker 进程，每个 Worker 进程都是一个单独的 Node.js 实例，共享同一个端口。Master 进程监听端口，将接收到的请求转发给 Worker 进程处理。

使用多进程架构可以有效地提高 Node 应用的稳定性和并发能力，但也会增加应用的复杂度。需要考虑进程间通信的效率和稳定性、进程之间数据共享的方式等问题。

#### 请问创建子进程的方法有哪些，简单说一下它们的区别？

在 Node.js 中，创建子进程的方法有以下几种：

1. **child_process.spawn()**：最基本的创建子进程的方法，可以通过给定的命令和参数启动一个子进程，并返回一个 ChildProcess 对象，通过该对象可以与子进程进行交互。
1. **child_process.fork()**：衍生出一个新的 Node.js 进程，并通过 IPC（进程间通信） 通道将父进程的数据发送到子进程，或将子进程的数据发送到父进程。与 spawn() 不同的是，fork() 只能用于衍生 Node.js 进程。
1. **child_process.exec()**：可以在一个 shell 中执行一个命令，并返回一个回调函数。如果需要在 shell 中执行一个脚本，或者需要对输出进行处理，则可以使用该方法。
1. **child_process.execFile()**：类似于 exec()，不同之处在于它不使用 shell，而是直接执行一个可执行文件。

这些方法的区别在于使用的场景不同，具体选择哪种方法要根据需要进行判断。例如，如果需要启动一个新的 Node.js 进程，则应该使用 fork() 方法；如果需要执行一个 shell 命令或脚本，则应该使用 exec() 方法等。

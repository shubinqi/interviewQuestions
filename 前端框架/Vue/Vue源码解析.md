<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-10 14:10:22
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-13 22:49:35
 * @Description: Vue 源码解析
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\前端框架\Vue\Vue源码解析.md
-->

### Vue 2.X 实现原理？

> github 上搜索 mini-vue 可以查看带详细中文注释的 vue 文件
> Mini-Vue（学习源码）：https://github.com/cuixiaorui/mini-vue
> Vue 项目面试题：https://www.bilibili.com/video/BV1YM411w7Zc
> 掘金源码解析文章；https://juejin.cn/post/7017628727345414152

#### Vue 的模板编译详细原理？

Vue 模板编译的过程可以分为以下几个步骤：

1. **解析模板**：将模板字符串解析成抽象语法树（AST）。AST 是一个用 JavaScript 对象表示的树形结构，它可以表示模板中的所有节点，如元素节点、文本节点、插值表达式节点等。
1. **静态优化**：遍历 AST，找出其中所有静态节点（即不包含变量或表达式的节点），并打上标记。
1. **代码生成**：根据 AST 生成 render 函数代码。这个过程可以看作是将 AST 转化成 JavaScript 代码的过程。

下面对每个步骤进行详细说明：

**解析模板**：解析模板的过程可以分为两个阶段：词法分析和语法分析。

词法分析阶段将模板字符串转换成一个个的 token，每个 token 包含其类型和原始值。例如，对于模板字符串 &lt;div&gt;{{ message }}&lt;/div&gt;，词法分析器会生成以下 token：

```
[
  { type: 'tag-start', value: '<div>' },
  { type: 'mustache-open', value: '{{' },
  { type: 'identifier', value: 'message' },
  { type: 'mustache-close', value: '}}' },
  { type: 'tag-end', value: '</div>' }
]
```

语法分析阶段则将 token 序列转换成 AST。Vue 的模板编译器使用了一个叫做“HTML Parser”的库来完成这个过程。

**静态优化**：静态节点是指不包含变量或表达式的节点。由于它们不会随着数据的变化而变化，因此可以在编译时进行优化，避免在每次渲染时都重新创建它们。Vue 的模板编译器会遍历 AST，找出其中所有静态节点，并在它们上面打上标记。

**代码生成**：代码生成阶段将 AST 转换成 JavaScript 代码。Vue 的模板编译器会将 AST 转换成一个 render 函数，这个函数接受一个“渲染上下文”作为参数，返回一个 VNode 对象。渲染上下文包含了所有渲染所需的数据，例如 props、data、computed 属性等。

渲染函数生成的代码包括了大量的 VNode 创建代码，例如：

```
h('div', { class: 'foo' }, [
  h('span', null, 'Hello'),
  h('span', null, 'World')
])
```

其中 h 是一个 createElement 函数，用于创建 VNode。上面的代码表示创建了一个包含两个 span 元素的 div 元素。

在编译时生成这些代码可以提高渲染性能，因为它避免了在每次渲染时都重新计算 VNode。

#### Vue 2.X diff 算法详细原理和对比流程？

Vue 2.x 使用的 Virtual DOM Diff 算法是一种高效的算法，用于比较新旧虚拟 DOM 之间的差异，并且仅对差异进行更新，以最小化浏览器重排和重绘。下面是 Vue 2.x 中 Diff 算法的详细原理和对比流程：

1. Diff 算法的入口是比较新旧虚拟 DOM 树的根节点。如果根节点的标签类型不同，则直接销毁旧节点，创建新节点，重新渲染整个子树。
1. 如果根节点的标签类型相同，则比较它们的属性列表。对于新旧节点都存在的属性，比较它们的值是否相同。对于只存在于新节点的属性，将新属性设置到新节点上。对于只存在于旧节点的属性，则从旧节点上移除该属性。
1. 如果新旧节点都存在子节点，则需要对子节点进行 Diff。在 Diff 子节点之前，需要对两个子节点列表的首尾节点进行比较，从而可以快速判断新旧节点是否可以复用。如果首尾节点相同，则说明新旧节点是可以复用的，直接将旧节点的属性更新到新节点上，然后对子节点列表进行 Diff。如果首尾节点不同，则说明新旧节点不能直接复用，需要按照一定的规则进行操作。
1. 对子节点列表进行 Diff 的过程可以使用双指针算法来实现。将新旧节点的子节点列表分别赋予头尾两个指针，然后依次比较指针所指的节点。如果新旧节点的头指针所指的节点相同，则说明这个节点可以直接复用，将旧节点的属性更新到新节点上，并将指针后移。如果新旧节点的尾指针所指的节点相同，则说明这个节点可以直接复用，将旧节点的属性更新到新节点上，并将指针前移。如果新旧节点的头指针和尾指针所指的节点都不能复用，则需要使用 key 值进行匹配。具体的匹配规则可以参考 Vue 官方文档中的描述。
1. Diff 算法完成后，需要根据新的虚拟 DOM 树生成真实的 DOM 节点，并将其添加到父节点上。在这个过程中，需要注意一些优化细节，例如使用文档片段来减少 DOM 操作，使用 key 值来优化 Diff 算法等。

综上所述，Vue 2.x 的 Diff 算法是一个非常高效的算法，它可以快速比较新旧虚拟 DOM 之间的差异，并仅对差异进行更新，从而最小化浏览器的重排和重绘。

#### Vue 2.X 响应式原理详细原理？

Vue 2.x 的响应式原理基于 ES5 的 Object.defineProperty()方法实现，主要包含以下几个部分：

1. **数据劫持**：Vue 通过 Object.defineProperty()方法来实现对数据的劫持。当一个对象被劫持时，Vue 会为对象的每个属性添加一个 getter 和一个 setter。当属性被访问时，getter 会被触发，当属性被修改时，setter 会被触发。
1. **依赖收集**：Vue 在模板编译阶段会对模板中的每个表达式进行解析，并为每个表达式创建一个 Watcher 实例。Watcher 实例会记录当前表达式所依赖的所有属性，并在这些属性发生变化时，触发对应的更新函数进行更新。
1. **派发更新**：当一个属性被修改时，Vue 会触发该属性的 setter 函数。setter 函数会更新当前属性的值，并触发所有依赖该属性的 Watcher 实例的更新函数进行更新。在更新函数中，Vue 会重新计算表达式的值，并将新的值渲染到页面上。
1. **数组响应式**：由于 Object.defineProperty()只能监听对象的属性变化，而无法监听数组的变化。因此，Vue 通过重写数组的七个变异方法（push、pop、shift、unshift、splice、sort、reverse）来实现数组的响应式。当数组调用这些方法时，Vue 会在内部更新数组，并派发更新。
1. **异步更新**：当数据发生变化时，Vue 并不会立即更新 DOM，而是将更新操作加入一个队列中，等到下一个 Tick 时再进行更新。这样可以避免频繁的 DOM 操作，提高性能。

综上所述，Vue 2.x 的响应式原理基于数据劫持和依赖收集实现。通过 Object.defineProperty()方法来劫持对象的属性，通过 Watcher 实例来收集依赖，并在属性发生变化时触发更新函数进行更新。同时，为了实现数组的响应式，Vue 重写了数组的七个变异方法，并实现了异步更新来提高性能。

<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-01 07:20:13
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-04 09:36:38
 * @Description: 数据结构与算法（7题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\数据结构与算法.md
-->

#### JS 有哪些数据结构？

JavaScript 有以下几种内置的数据结构：

1. **数组（Array）**：一组有序的数据集合，可以通过索引来访问其中的元素，数组长度可变。
1. **对象（Object）**：键值对的无序集合，其中键是字符串类型，值可以是任意类型，对象是一种引用数据类型。
1. **集合（Set）**：一组无序的、唯一的数据集合，其中的元素不能重复，可以进行去重操作。
1. **映射（Map）**：一组键值对的无序集合，其中的键和值可以是任意类型，键不能重复，可以根据键来访问对应的值。
1. **栈（Stack）**：一种先进后出（LIFO）的数据结构，只能在栈顶进行插入和删除操作。
1. **队列（Queue）**：一种先进先出（FIFO）的数据结构，只能在队列尾进行插入操作，在队列头进行删除操作。
1. **链表（LinkedList）**：由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，可以插入、删除任意位置的元素。
1. **树（Tree）**：由节点组成的层级结构，每个节点有一个父节点和零个或多个子节点，用于表示具有层级关系的数据结构，如文件系统、DOM 树等。
1. **图（Graph）**：由节点和边组成的网络结构，节点之间通过边相连，可以用来表示各种复杂的关系，如社交网络、地图等。

以上是 JavaScript 中常用的数据结构，不过还有其他的一些数据结构，如堆、哈希表等，这些数据结构可以通过使用 JavaScript 实现来进行应用。

#### 什么是时间复杂度和空间复杂度？

时间复杂度和空间复杂度都是用来描述算法性能的度量方式。

时间复杂度是指在算法运行过程中，执行基本操作次数的增长速度，通常用大 O 表示。它描述的是算法运行时间与输入规模之间的关系，即当问题规模增加时，算法运行时间的增长趋势。时间复杂度越小，算法运行效率越高。

空间复杂度是指算法在运行过程中所需要的额外空间，通常也用大 O 表示。它描述的是算法所需内存空间的增长趋势。空间复杂度越小，算法所需的内存空间越少。

在算法分析中，通常只考虑最坏情况下的时间复杂度和空间复杂度，因为最坏情况下是算法性能的瓶颈。

需要注意的是，时间复杂度和空间复杂度都是理论上的分析，实际运行效率与硬件环境、算法实现方式、数据分布等因素都有关系。因此，算法的时间复杂度和空间复杂度只是一种相对的度量方式，不能直接代表算法的运行时间和内存占用。

#### 时间复杂度的划分

1. **常数阶 O(1)**：常数时间复杂度。表示算法的执行时间不随输入规模而变化，即算法具有恒定的时间复杂度。例如，访问数组中的某个元素、插入或删除链表的某个节点等操作都属于常数时间复杂度。在空间复杂度方面，常数空间复杂度表示算法所需存储空间不随输入规模而变化，即算法具有恒定的空间复杂度。
1. **对数阶 O(logN)**：对数时间复杂度。表示算法的执行时间随输入规模呈对数增长，即算法的执行时间随着数据量的增加呈现逐渐减少的趋势。例如，二分查找等操作都属于对数时间复杂度。在空间复杂度方面，对数空间复杂度表示算法所需存储空间随着输入规模呈对数增长。
1. **线性阶 O(n)**：线性时间复杂度。表示算法的执行时间随着输入规模呈线性增长，即算法的执行时间随着数据量的增加呈现逐渐增加的趋势。例如，顺序查找等操作都属于线性时间复杂度。在空间复杂度方面，线性空间复杂度表示算法所需存储空间随着输入规模呈线性增长。
1. **线性对数阶 O(nlogN)**：线性对数时间复杂度。表示算法的执行时间随输入规模呈线性对数增长，即算法的执行时间随着数据量的增加呈现逐渐增加的趋势，但增长速度比线性更慢。例如，归并排序等操作都属于线性对数时间复杂度。在空间复杂度方面，线性对数空间复杂度表示算法所需存储空间随着输入规模呈线性对数增长。
1. **平方阶 O(n²)**：平方时间复杂度。表示算法的执行时间随着输入规模呈平方增长，即算法的执行时间随着数据量的增加呈现逐渐增加的趋势，并且增长速度比线性和线性对数更快。例如，冒泡排序、插入排序、选择排序等操作都属于平方时间复杂度。
1. **立方阶 O(n³)**：立方复杂度，表示算法的时间或空间复杂度随着输入规模 n 的增加呈现立方级别增加，算法效率极低，常见的算法有矩阵相乘、图的 Floyd-Warshall 算法等。
1. **K 次方阶 O(n^k)**：表示随着输入规模 n 的增大，算法的时间复杂度将以 n 的 k 次方速率增长。其中 k 是一个常数，k>=2，通常也称为多项式时间。
1. **指数阶 O(2^n)**：指数复杂度，表示算法的时间或空间复杂度随着输入规模 n 的增加呈现指数级别增加，算法效率极低，常见的算法有穷举法、背包问题等。

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

O(1) < O(log n) < O(n) < O(nlog n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

#### 你知道哪些排序方法？

常见的 JavaScript 排序算法包括：

1. **冒泡排序**：通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。时间复杂度最好为 O(n)，最坏和平均为 O(n²)。
2. **选择排序**：每次从未排序的数组中选出最小的元素，放在已排序的末尾。时间复杂度为 O(n²)。
3. **插入排序**：将未排序的元素依次插入到已排序的合适位置。时间复杂度最好为 O(n)，最坏和平均为 O(n²)。
4. **快速排序**：选择一个枢纽元素，将数组分为两部分，一部分比枢纽元素小，一部分比枢纽元素大，然后递归地对两部分进行快速排序。时间复杂度最好为 O(nlogn)，最坏为 O(n²)，平均为 O(nlogn)。
5. **归并排序**：将数组分为两部分，对每部分进行归并排序，然后将两部分合并。时间复杂度为 O(nlogn)。
6. **桶排序**：将数组中的元素按照一定的规则划分到不同的桶中，然后对每个桶中的元素进行排序，最后将所有桶中的元素合并。时间复杂度为 O(n)。
7. **基数排序**：根据元素的每一位进行排序，先按照最低位排序，再按照次低位排序，直到按照最高位排序。时间复杂度为 O(d(n+r))，其中 d 为位数，r 为基数。
8. **计数排序**：统计每个元素出现的次数，然后按照元素的大小顺序输出。时间复杂度为 O(n+k)，其中 k 为元素的范围。
9. **希尔排序**：将数组分为若干个子数组，对每个子数组进行插入排序，然后逐步减少子数组的规模。时间复杂度为 O(nlogn)。
10. **堆排序**：将数组构建成一个大根堆或小根堆，然后依次将堆顶元素与最后一个元素进行交换，再调整堆。时间复杂度为 O(nlogn)。

#### 讲一下栈结构？

栈和队列是 JavaScript 中的两种常见数据结构。栈和队列都是动态的集合，但它们之间有一些重要的区别。以下是关于栈和队列的特点的总结：

1. **栈**：在 JavaScript 中，栈数据结构是基于 Array 类型来进行封装的。栈是一种遵从后进先出（LIFO）原则的有序集合。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 在现实生活中也能发现很多栈的例子，例如，一摞书或者餐厅里叠放的盘子。栈也被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）。

栈的特点如下：

1. 后进先出（LIFO）的数据结构，最后进入的元素最先被弹出。
1. 只能从栈顶逐个存入数据，取出数据也需从栈顶逐个取出。
1. 可以使用数组来模拟栈。
1. 堆栈的基本操作包括入栈（push）、出栈（pop）、查看栈顶元素等。
1. 栈的应用包括函数调用、表达式求值、括号匹配等。

栈数据结构可以用于很多场景，例如：

- 判断括号是否匹配：使用栈存储左括号，每次遇到右括号则弹出栈顶元素判断是否匹配。
- 实现浏览器的前进后退功能：使用两个栈，一个存储历史记录，一个存储前进记录，每次点击前进或后退时，将对应的记录从一个栈中弹出并压入另一个栈中。
- 实现函数调用栈：每次调用函数时将函数名和参数压入栈中，函数执行完毕后将函数名和参数从栈中弹出。

#### 讲一下队列结构？

1. **队列**：在 JavaScript 中，队列数据结构是基于 Array 类型来进行封装的。队列是一种遵循先进先出（FIFO）原则的数据结构。除了普通队列之外，JavaScript 中还有双端队列，它允许我们同时从队头和队尾进行出队和入队操作。双端队列是队列和栈的结合体。

队列的特点如下：

1. 先进先出（FIFO）的数据结构，最早进入的元素最先被弹出。
1. 可以在队尾添加元素，在队首删除元素，查看元素也是在队首进行。
1. 可以使用数组来模拟队列。
1. 队列的基本操作包括入队（enqueue）、出队（dequeue）、查看队首元素等。
1. 队列的应用包括进程调度、打印任务等。

队列数据结构可以用于很多场景，例如：

- JS 异步中的任务队列：JavaScript 中的任务队列是一种先进先出的队列，用于管理异步任务的执行顺序。在 JavaScript 中，setTimeout 和 setInterval 这些异步函数会将任务添加到任务队列中，等待 JavaScript 引擎在适当的时候执行它们。此外，Promise 和 async/await 也是常见的异步任务，它们也会将任务添加到任务队列中。
- 图的广度优先遍历：广度优先遍历是一种图遍历算法，它需要使用队列来记录每个节点的相邻节点，以便可以在接下来最先访问它们，从而实现广度优先遍历。
- 需要先进先出的场景：队列通常用来描述算法或生活中的一些先进先出的场景，例如食堂排队打饭、计算最近请求次数等。
- 批量任务处理：在 Web 开发中，我们经常需要处理批量任务，例如用户提交的批量任务或系统触发的批量任务。队列可以用来管理这些任务，以便在适当的时候依次执行它们，从而避免阻塞用户界面或影响用户体验。

双端队列是一种灵活的数据结构，可以在队列的两端添加、删除和查看元素。

#### 栈与堆的区别？

在计算机科学中，栈（stack）和堆（heap）都是用于管理内存的数据结构，但它们有不同的特点和用途。

栈是一种线性数据结构，它的特点是后进先出（Last In First Out, LIFO）。栈通常用于程序调用栈、表达式求值和临时变量的存储。在函数调用时，函数的返回地址、参数和局部变量都被压入栈中，当函数返回时，这些值从栈中弹出。栈的操作速度比堆快，因为它使用指针移动来管理内存，而不需要复杂的内存管理算法。

堆是一种非线性数据结构，它的特点是动态分配内存，可以任意增加或减少。堆通常用于动态存储对象或数据结构，如数组、对象等。在堆中，每个对象都有一个唯一的地址，通过这个地址可以访问对象的内容。堆的操作速度比栈慢，因为它需要使用内存管理算法来管理动态分配的内存。

在内存管理方面，栈的内存分配和回收是由编译器自动完成的，而堆的内存分配和回收需要程序员手动管理。通常情况下，栈的内存空间比较小，而堆的内存空间比较大，所以在分配内存时需要考虑栈和堆的使用情况，避免出现栈溢出或堆内存泄漏的情况。

#### 深度优先遍历、广度优先遍历的区别？

深度优先遍历和广度优先遍历都是常用的遍历算法，它们的区别在于遍历的顺序和策略。

1. **深度优先遍历**（Depth First Search，DFS）是一种优先遍历策略，从起点开始一直走到最深处，直到无法继续为止，然后返回上一个分叉点，再继续尝试走其他分支。具体来说，DFS 从一个起点开始，先访问它的一个相邻节点，然后递归地访问该节点的相邻节点，直到没有未访问的相邻节点，然后返回上一层继续遍历其他相邻节点。
1. **广度优先遍历**（Breadth First Search，BFS）是一种平等遍历策略，按照从起点开始，先访问起点的所有相邻节点，然后再访问这些节点相邻的所有节点，依此类推，直到遍历完所有可到达的节点。具体来说，BFS 从一个起点开始，先访问它的所有相邻节点，然后依次访问这些节点的相邻节点，直到遍历完所有可到达的节点。

总的来说，DFS 的优点在于能够深入探索每个节点，适合用于寻找目标节点深处的情况，缺点是可能会陷入无限循环中。而 BFS 的优点在于能够按照距离优先遍历节点，适合用于寻找目标节点离起点比较近的情况，缺点是空间复杂度较高。

#### JS 中链表是什么？有什么特点？应用场景是什么？

**链表**：链表是一种数据结构，它用于存储有序的元素集合，但是与数组不同的是，链表中的元素在内存中不是连续位置的。每个元素都由一个存储元素本身的结点和指向下一元素的引用（也叫指针或者链接）组成。链表的好处在于添加或删除元素时不需要移动其他元素，但是操作链表需要指针。由于链表是一种松散的结构体，因此当您想要找到其中的某个节点时，只能够从头节点一级一级地向下找，但也因为这种松散的结构使得其进行插入和删除时只需要改变其指针域的指向即可。

链表的特点：

- 链表中的元素在内存中不是连续位置的，每个元素都由一个存储元素本身的结点和指向下一元素的引用组成。
- 链表的好处在于添加或删除元素时不需要移动其他元素。
- 链表的缺点在于访问链表中的某一元素时必须从起点开始迭代知道找到目标元素。

链表的应用场景：

- 在需要频繁地进行插入或删除操作的情况下，使用链表可以提高效率，因为链表不需要移动其他元素。
- 链表可以用来实现栈和队列等数据结构。
- 在某些算法中，链表是一种更加方便的数据结构，比如链表快排。

在 JS 中，没有内置链表这种数据结构，因此需要使用对象来模拟实现链表。一般来说，我们可以使用一个类来表示链表，该类包含一个头节点和一些方法，如 find、insert 和 remove 等。对于单向链表，每个节点只包含指向下一个节点的指针；而对于双向链表，每个节点包含指向下一个节点和上一个节点的指针。

#### JS 中二叉树是什么？有什么特点？应用场景是什么？

**二叉树**：二叉树是一种树形数据结构，每个节点最多只能有两个子节点的树。在 JavaScript 中，可以用 Object 来实现二叉树。一个二叉树的节点通常由三部分组成：节点值、左子节点和右子节点。一个简单的二叉树可以用以下代码表示：

```
const bt = {
  val: 1,
  left: {
    val: 2,
    left: { val: 4, left: null, right: null },
    right: { val: 5, left: null, right: null }
  },
  right: {
    val: 3,
    left: { val: 6, left: null, right: null },
    right: { val: 7, left: null, right: null }
  }
};
```

二叉树的特点包括：

- 每个节点最多只能有两个子节点；
- 左右子节点的次序不能颠倒，即使只有一个节点也需要区分是左子节点或右子节点；
- 没有子节点的节点称为叶子节点。

二叉树有多种类型，包括完全二叉树、满二叉树和平衡二叉树等。各类二叉树的特点如下：

- 真二叉树：每个节点的度数为 0 或 2；
- 完全二叉树：叶节点在最底部的两层，且最底层的叶节点在左侧；
- 满二叉树：所有叶子节点都在最底层，而且除了叶子节点外，每个节点都有两个子节点；
- 平衡二叉树：任意节点的左右子树的高度差不超过 1。

二叉树可以用于实现二叉查找树和二叉堆等数据结构。二叉查找树是一种特殊的二叉树，它的左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于根节点的值。这个特性使得二叉查找树具有快速查找、插入和删除的能力。二叉堆是一种特殊的二叉树，它满足堆的性质，即父节点的值总是大于或等于（或小于或等于）它的子节点的值。二叉堆可以用于实现优先队列等数据结构。

<!--
 * @Author: Shu Binqi
 * @Date: 2023-02-24 21:04:05
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-02 08:45:34
 * @Description: JavaScript 面试题汇总
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\JavaScript.md
-->

#### JavaScript 的数据类型有哪些？

JavaScript 共有 8 种数据类型，具体如下：

1. Number：数值类型，包括整数和浮点数。
1. String：字符串类型。
1. Boolean：布尔类型，只有两个值：true 和 false。
1. Null：表示空值或空对象指针。
1. Undefined：表示未定义或不存在的值。
1. Symbol：表示唯一的标识符，通常用于对象属性的键值。
1. BigInt：用于表示大整数，可以处理超出 Number 类型表示范围的整数。
1. Object：表示一个复杂数据类型，可以存储多个键值对。

其中，前 7 种数据类型为原始类型，都是不可变的，而 Object 则为引用类型，可以存储任意类型的数据。

（回答就 0 分的有：数组、函数、日期，这些是 类 class；不是类型 type）

#### 判断数据类型的方法有哪些？

① 判断多种数据类型

1. typeof：可以判断除 null 外的 ES5 基本数据类型
2. instanceof：可以正确判断对象的类型
3. construter：可以正确判断数据类型（如果创建一个对象并改变他的原型，就不能用 construter 判断类型了）
4. Object.prototype.toString.call()：可以正确判断对象的类型

需要注意的是，typeof null 的结果是 "object"，这是 JavaScript 语言本身的一个 bug，可以通过 typeof value === "object" && value === null 的方式来判断一个值是否为 null。

② 判定单个数据类型

1. Array.isArray()：判断是否是数组类型

③ 判断某个数据

1. isNaN：判断是否是一个非数字（会进行类型转换）
2. Number.isNaN：判断是否是一个非数字（首先判断是否是数字，再进行判断）
   ```
   console.log(isNaN('测试')) //true
   console.log(Number.isNaN('测试')) //false
   ```
3. isFinite() 用来判断被传入的参数值是否为一个有限数值（finite number），如果参数是 NaN，正无穷大或者负无穷大，会返回 false，其他返回 true。

#### typeof 判断不同类型时分别返回什么？

在 JavaScript 中，typeof 是一个操作符，用于返回操作数的数据类型，其返回值有以下几种：

1. **undefined**：表示未定义的值，通常是一个未声明的变量或函数中没有返回值。
1. **boolean**：表示布尔值 true 或 false。
1. **number**：表示数字类型，包括整数、浮点数和 NaN。
1. **string**：表示字符串类型，包括单引号、双引号和模板字符串。
1. **symbol**：表示 ES6 中新增的符号类型。
1. **object**：表示对象类型，包括 null、数组、函数、正则表达式等。
1. **function**：表示函数类型。

需要注意的是，typeof null 返回的是 "object"，这是 JavaScript 的历史遗留问题，被认为是一个语言设计上的失误。在 JavaScript 中，null 被视为一个特殊的对象值，但实际上它应该是一个原始值类型。因此，如果需要判断一个值是否为 null，建议使用严格相等运算符 === 来进行判断。

#### typeof null 的结果是什么，为什么？

typeof null 的结果是 "object"。这是因为在 JavaScript 的早期版本中，null 被错误地实现为对象类型，而实际上 null 是一个原始值。这个错误的实现在现代 JavaScript 中仍然存在，为了保持向后兼容性，typeof null 返回 "object"。

需要注意的是，null 和 undefined 是不同的类型，typeof undefined 的结果是 "undefined"。

#### null 和 undefined 的区别是什么？

null：空指针对象
undefined：未定义
相同点：都是基本数据类型
不同点：

1. 变量声明了但还没有定义的时候会返回 undefined；null 主要用于赋值给一些可能会返回对象的变量，作为初始化。
2. 使用 typeof 判断类型时 null 会返回 object；undefined 正确返回。（这是一个历史遗留的问题）

#### 如何获取安全的 undefined 值？

在 JavaScript 中，当访问一个不存在的变量时，会返回 undefined 值。但是在某些情况下，undefined 值可能被意外地赋值为其他值，例如：

```
let undefined = 123;
console.log(undefined); // 输出 123
```

为了避免这种情况，可以使用 void 操作符来获取安全的 undefined 值。void 操作符可以将任何表达式转换为 undefined 值，例如：

```
let a;
console.log(a); // 输出 undefined

let b = void 0;
console.log(b); // 输出 undefined

let c = void 'hello';
console.log(c); // 输出 undefined
```

因此，如果你需要获取安全的 undefined 值，可以使用 void 0 或 void 操作符。

#### 说说你对堆区和栈区的理解？

在计算机内存中，栈区和堆区是两个常用的内存分配区域。

栈区是用来存储函数的参数值、局部变量等在函数执行时需要分配的内存空间。它的特点是分配效率高，但空间较小，由系统自动分配和回收，具有后进先出（LIFO）的特点。

堆区是动态分配内存的区域，用来存储对象、数组等数据。它的特点是空间较大，但分配效率较低。由于需要手动分配和回收内存，所以容易产生内存泄漏等问题。

在 JavaScript 中，堆区用来存储对象、函数等复杂数据类型，栈区则主要用来存储基本数据类型和一些基本变量。在 JavaScript 中，每个对象都有一个原型对象，而原型对象又可以有自己的原型对象，形成原型链。在查找对象的属性时，会在原型链上依次查找，直到找到对应的属性或者查找到原型链的顶端，如果还没有找到则返回 undefined。

总的来说，栈区和堆区都是计算机内存中常用的内存分配区域，分别适用于不同的场景。在 JavaScript 中，原型和原型链则是实现继承和属性查找的重要机制。

#### isNaN 和 Number.isNaN 函数的区别？

isNaN 和 Number.isNaN 函数的主要区别在于它们对于参数的处理方式。

isNaN 函数会尝试将其参数转换为数值类型，如果参数无法被转换为数值类型，则返回 true。这意味着对于非数值类型的参数，isNaN 函数会先尝试将其转换为数值类型，然后再进行判断。例如：

```
isNaN('hello') // true
isNaN(undefined) // true
```

在这个例子中，isNaN 函数尝试将字符串 'hello' 和未定义的值 undefined 转换为数值类型，由于无法转换成功，它们会被判断为 NaN，因此返回 true。

相比之下，Number.isNaN 函数不会尝试将其参数转换为数值类型。如果参数不是 NaN 值，Number.isNaN 函数会直接返回 false。例如：

```
Number.isNaN('hello') // false
Number.isNaN(undefined) // false
```

因此，Number.isNaN 函数只有在参数是 NaN 值时才会返回 true。

总的来说，与 isNaN 函数相比，Number.isNaN 函数更加严格，因为它只会对参数进行类型检查，而不会尝试进行类型转换。

#### 判断数组类型有哪几种方法？

1. Array.isArray()：
   ```
   const arr = [1, 2, 3];
   console.log(Array.isArray(arr)); // true
   ```
2. Object.peototype.toString.call()：
   ```
   const arr = [1, 2, 3];
   console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
   ```
   需要注意的是，在某些情况下， instanceof 和 Array.isArray() 可能会出现错误的结果，特别是当变量跨框架或 Web Worker 时。因此，推荐使用 Object.prototype.toString.call() 来判断变量是否为数组。
3. instanceof：
   ```
   const arr = [1, 2, 3];
   console.log(arr instanceof Array); // true
   console.log(Array.isArray(arr)); // true
   ```
4. Array.isPrototypeOf()：

#### 有哪些方法会改变原数组？（至少 7 种）

JavaScript 中，有一些数组方法会直接修改原始数组，称为“就地方法”或“改变器方法”，这些方法包括：

1. **push()**：在数组末尾添加一个或多个元素。
1. **pop()**：删除并返回数组最后一个元素。
1. **shift()**：删除并返回数组的第一个元素。
1. **unshift()**：在数组开头添加一个或多个元素。
1. **splice()**：删除或替换数组的元素，可以在任何位置添加新元素。
1. **sort()**：对数组进行排序。
1. **reverse()**：将数组元素反转顺序。
1. **fill()**：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。
1. **copyWithin()**：在数组内部将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回修改后的数组。

这些方法会直接修改原始数组，不会创建新的数组。如果不想改变原始数组，可以使用“非就地方法”或“访问器方法”，如 slice()、concat()、filter()、map()、reduce()等。

#### 哪些方法不会改变原数组？（至少 7 种）

JavaScript 中有一些数组方法是不会改变原数组的，包括以下方法：

1. **concat()**: 连接两个或更多数组，并返回结果，原数组不会被修改。
1. **slice()**: 返回选定数组的元素，原数组不会被修改。
1. **join()**: 把数组的所有元素放入一个字符串，原数组不会被修改。
1. **toString()**: 把数组转换为字符串，并返回结果，原数组不会被修改。
1. **indexOf()**: 返回数组中某个元素第一次出现的位置，原数组不会被修改。
1. **lastIndexOf()**: 返回数组中某个元素最后一次出现的位置，原数组不会被修改。
1. **slice()**: 返回数组的一部分，原数组不会被修改。
1. **concat()**: 连接两个或更多数组，并返回结果，原数组不会被修改。
1. **includes()**: 判断一个数组是否包含某个值，原数组不会被修改。
1. **every()**: 检测数组中的所有元素是否满足指定条件，原数组不会被修改。
1. **some()**: 检测数组中的某些元素是否满足指定条件，原数组不会被修改。
1. **filter()**: 创建一个新数组，其中包含通过指定函数测试的所有元素，原数组不会被修改。
1. **map()**: 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后的返回值，原数组不会被修改。
1. **reduce()**: 将数组中的所有元素累加到一个值中，原数组不会被修改。
1. **reduceRight()**: 将数组中的所有元素累加到一个值中，原数组不会被修改。

需要注意的是，这些方法虽然不会改变原数组，但是有些方法会返回一个新的数组，需要将其赋值给一个新的变量使用。

#### 数组有哪些遍历方法？（至少 7 种）

JavaScript 数组有以下遍历方法：

for 循环：常规的 for 循环语句可以遍历数组元素，通过数组的 length 属性可以获取数组的长度。

```
const arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

forEach 方法：遍历数组元素，对每个元素执行回调函数。

```
const arr = [1, 2, 3, 4, 5];
arr.forEach(function(element) {
  console.log(element);
});
```

map 方法：遍历数组元素，对每个元素执行回调函数，将返回值存入新的数组中。

```
const arr = [1, 2, 3, 4, 5];
const newArr = arr.map(function(element) {
  return element * 2;
});
console.log(newArr); // [2, 4, 6, 8, 10]
```

filter 方法：遍历数组元素，对每个元素执行回调函数，根据返回值来过滤元素，将满足条件的元素存入新的数组中。

```
const arr = [1, 2, 3, 4, 5];
const newArr = arr.filter(function(element) {
  return element % 2 === 0;
});
console.log(newArr); // [2, 4]
```

reduce 方法：遍历数组元素，对每个元素执行回调函数，将计算结果累加到一个累加器中，返回累加器的最终结果。

```
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce(function(acc, cur) {
  return acc + cur;
}, 0);
console.log(sum); // 15
```

every 方法：遍历数组元素，对每个元素执行回调函数，当所有元素都满足条件时返回 true，否则返回 false。

```
const arr = [1, 2, 3, 4, 5];
const isAllEven = arr.every(function(element) {
  return element % 2 === 0;
});
console.log(isAllEven); // false
```

some 方法：遍历数组元素，对每个元素执行回调函数，当任意一个元素满足条件时返回 true，否则返回 false。

```
const arr = [1, 2, 3, 4, 5];
const hasEven = arr.some(function(element) {
  return element % 2 === 0;
});
console.log(hasEven); // true
```

for...of 循环：ES6 新增的语法，可以遍历数组元素。

```
const arr = [1, 2, 3, 4, 5];
for (const element of arr) {
  console.log(element);
}
```

#### 什么是事件冒泡？怎么阻止事件冒泡？

事件冒泡是指当一个元素上的事件被触发后，它会向父级元素一层层地逐级触发，直到触发到 document 对象为止。例如，当点击一个子元素时，如果该元素上绑定了事件处理程序，那么点击事件会先触发子元素上的事件处理程序，然后一级一级地向上传递，直到到达 document 对象。

阻止事件冒泡的方法有两种：

1. 使用 event.stopPropagation() 方法，该方法会阻止事件进一步冒泡。在事件处理程序中调用该方法，可以阻止事件向上层元素冒泡。
1. 使用 event.cancelBubble 属性，在 IE 中，该属性可以设置为 true，来阻止事件进一步冒泡。在其他浏览器中，该属性已经被废弃，需要使用 event.stopPropagation() 方法来代替。

#### 什么是事件捕获？如何阻止事件捕获？

事件捕获是指当一个元素触发了某个事件时，事件会从它的祖先元素一层层往下传递，直到到达目标元素并触发该事件。事件捕获的顺序与事件冒泡相反，即从外到内。

在事件捕获的过程中，可以通过调用 Event 对象的 stopPropagation() 方法来阻止事件的继续传递。该方法会停止事件的捕获和冒泡过程，并防止任何父元素或子元素受到影响。

具体来说，stopPropagation() 方法应该在事件处理程序中调用，例如：

```
document.addEventListener('click', function(event) {
  event.stopPropagation();
  // 事件处理逻辑
}, true);
```

在上述代码中，addEventListener() 方法的第三个参数为 true，表示事件使用捕获阶段进行处理。event.stopPropagation() 方法会阻止事件的继续传递，避免影响其他元素。

需要注意的是，虽然 stopPropagation() 方法可以阻止事件的继续传递，但它并不能阻止事件处理程序本身的执行。如果需要完全禁用事件处理程序的执行，可以使用 preventDefault() 方法，它可以阻止事件的默认行为，例如阻止链接的跳转或表单的提交。

#### 什么是事件委托？

事件委托（Event Delegation）是一种常用的优化前端性能的技术，它是利用事件冒泡的特性，将事件处理器绑定到它们的共同祖先节点上，从而减少绑定事件处理器的数量，提高页面的响应速度。
通过事件委托，我们可以将事件处理器绑定到共同祖先元素上，而不是将事件处理器绑定到每个子元素上。这样，当事件触发时，事件会一直冒泡到祖先元素，并在祖先元素上触发相应的事件处理器。这样就可以利用事件冒泡的机制，实现子元素和父元素之间的事件传递。
使用事件委托的好处有：

1. 减少绑定事件的数量，提高性能。
2. 动态添加的元素也可以自动绑定事件，不需要再手动绑定。
3. 可以避免因为动态添加的元素没有绑定事件而导致的事件失效的问题。

事件委托的应用场景包括：

1. 列表元素的点击事件，通过事件委托在列表的父元素上绑定点击事件，而不是在每个列表元素上绑定点击事件。
2. 表单元素的提交事件，通过事件委托在表单的父元素上绑定提交事件，而不是在每个表单元素上绑定提交事件。
3. 动态添加的元素的事件绑定，通过事件委托在它们的共同祖先元素上绑定事件处理器，而不需要在动态添加的元素上手动绑定事件处理器。

#### ES6 有哪些新语法？

ES6（ECMAScript 2015）引入了许多新的语法和特性，其中一些主要的包括：

1. **块级作用域**：使用 let 和 const 声明变量时可以创建块级作用域。
1. **箭头函数**：使用 => 语法定义匿名函数。
1. **解构赋值**：可以从数组和对象中提取值并将其赋给变量。
1. **模板字符串**：使用反引号 `` 来创建多行字符串，并且可以在字符串中插入表达式。
1. **默认参数**：定义函数参数的默认值。
1. **展开运算符**：使用 ... 语法来展开数组或对象。
1. **类和继承**：使用 class 和 extends 关键字来定义类和继承。
1. **模块化**：使用 import 和 export 关键字来导入和导出模块。
1. **Promise**：处理异步操作的一种方法，可以通过链式调用来组合多个异步操作。
1. **Symbol**：引入了一种新的原始数据类型，用于创建唯一的标识符。
1. **Map 和 WeakMap**：字典，一种新的集合类型，为 ECMAScript 语言带来了真正的键/值存储机制
1. **Set 和 WeakSet**：集合，一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。
1. **迭代器和生成器**：迭代器是一种对象，可以通过 next() 方法按顺序返回值，而生成器是一种函数，可以使用 yield 关键字来定义迭代器。
1. **for...in**：用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。
1. **for...of**：用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。

#### Map 和 Object 的区别？

1. Object 是 JavaScript 中的内置对象，用于存储键值对，键必须是字符串或符号。而 Map 是 ES6 新增的一种数据结构，也用于存储键值对，键可以是任意数据类型。
1. Map 具有更好的数据结构设计，能更高效地存储大量的键值对，并且提供了更多的方法用于操作键值对，比如 size 属性可以获取 Map 中键值对的数量。

#### Map 和 Set 的区别？

1. Set 用于存储唯一值的集合，而 Map 用于存储键值对的映射关系。
1. Set 只存储值，没有键，而 Map 存储键值对。
1. Set 只有一个值，而 Map 可以将任何值用作键或值。

#### Map 和 WeakMap 的区别？

1. Map 和 WeakMap 都是用于存储键值对的数据结构。
1. WeakMap 只能使用对象作为键，但是 Map 可以使用任何数据类型作为键。
1. WeakMap 中的键是弱引用，如果只有 WeakMap 对象中的键引用了某个对象，而该对象没有被其他对象引用，那么该对象会被垃圾回收机制回收。
1. WeakMap 没有 size 属性，也没有 clear() 方法，而且不能遍历其中的键或值。

#### Set 和 WeakSet 的区别？

1. 对象引用类型：Set 存储的是对象的引用，WeakSet 存储的是对象的弱引用，因此 WeakSet 中的对象都是可被垃圾回收的，当对象被回收后，WeakSet 会自动删除对应的元素。
1. 值唯一性：Set 中的值必须是唯一的，重复的值会被自动过滤掉，而 WeakSet 中的值可以是重复的，因为它们是通过引用来判断是否相等的。
1. 迭代器：Set 是可迭代的，可以通过 for...of 循环来遍历集合中的每一个值，而 WeakSet 是不可迭代的，不能直接遍历 WeakSet 中的元素。
1. 方法：Set 和 WeakSet 有一些不同的方法，如 Set 中的 size 属性用于获取集合中的元素个数，而 WeakSet 中没有 size 属性；Set 中的 delete 方法可以删除集合中指定的元素，而 WeakSet 中没有 delete 方法，因为它的元素是可被自动删除的。

#### for 循环和 forEach 的区别？

1. for 循环是 JavaScript 中最常用的循环语句，可以遍历数组和对象等集合数据类型。它的语法结构简单，可以通过控制循环变量来访问集合中的每一个元素。
1. forEach 是数组的一个内置方法，也用于遍历数组中的每一个元素。但是它的语法比较简洁，不需要控制循环变量，而是直接接收一个回调函数作为参数，该函数会被自动调用来处理每一个数组元素。因此，forEach 可以更加简洁和直观地遍历数组，也更适合处理一些数组操作，比如计算数组的总和或平均值等。

> for 循环比较常用，可控制性强，可以用于遍历集合、实现条件语句等多种场景；forEach 可以更加简洁地遍历数组，适用于一些数组操作

#### for...in 和 for...of 的区别？

1. for...in 用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。但是，它并不保证属性的访问顺序，也可能访问到一些原型链中的属性。
1. for...of 用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。与 for...in 不同，for...of 遍历的是集合中的元素，而不是属性。

> for...in 适用于遍历对象属性，但是不保证属性访问顺序；for...of 适用于遍历集合中的元素，比如数组、Map、Set 等。

#### 讲一下闭包？闭包的优缺点？闭包的使用场景？（建议写博客）

闭包是指在函数内部创建了一个函数，并且这个函数可以访问到外部函数的局部变量和参数，即使外部函数已经返回，内部函数仍然可以访问和操作这些变量和参数。闭包是 JavaScript 中一个非常重要的概念，它可以用来实现模块化、保存私有变量等。

闭包的优点：

1. 实现函数内部的私有变量，避免全局变量的污染。
1. 可以实现数据的封装和隐藏，确保数据的安全性。
1. 使函数内部的变量长期保存在内存中，方便以后的调用。

闭包的缺点：

1. 过度使用闭包可能会导致内存泄漏，因为闭包会使得函数中的变量被长期占用，无法被垃圾回收器回收。
1. 可能会导致性能问题，因为闭包中涉及到了变量的查找，会比普通的函数调用消耗更多的时间和内存。
1. 对于不慎使用闭包的开发者来说，可能会出现变量覆盖等问题。

闭包的使用场景包括但不限于以下几个方面：

1. **模块化开发**：通过闭包来实现模块化开发，将模块中需要暴露的接口通过返回函数的形式暴露出去，同时保护模块中的私有变量。
1. **私有变量**：闭包可以用来实现 JavaScript 中的私有变量，将需要保护的变量封装在一个函数内部，通过返回一个访问该变量的函数，从而控制对变量的访问和修改。
1. **延迟执行**：利用闭包来延迟函数的执行，在函数外部创建一个闭包，然后将需要延迟执行的函数作为参数传入，从而实现延迟执行的效果。
1. **计数器**：闭包可以用来实现一个简单的计数器，每次调用计数器函数都会返回一个新的计数值。
1. **缓存**：利用闭包来实现缓存机制，将需要缓存的数据存储在闭包中，从而提高访问速度。
1. **回调函数**：利用闭包来实现回调函数，将回调函数作为参数传入，从而实现函数之间的协作。

需要注意的是，闭包会占用内存，并且可能会导致内存泄漏，因此在使用闭包时需要注意内存管理。

#### 闭包的执行过程？

闭包是指有权访问另一个函数作用域中变量的函数，即使外部函数已经执行结束，内部函数依然可以访问外部函数的作用域。

当一个函数被调用时，都会创建一个执行环境，包含函数的参数、局部变量、this 等。在执行环境中，会创建一个变量对象（VO），用于存储变量和函数声明，并将其放入作用域链中。

当函数执行完毕时，其执行环境会被销毁，但是其作用域链中的变量对象依然存在，因为闭包函数依然引用了该变量对象，所以该变量对象不能被销毁，直到闭包函数被销毁时才会一起销毁。

下面是一个简单的闭包例子：

```
function outer() {
  var count = 0;
  return function inner() {
    count++;
    console.log(count);
  }
}

var counter = outer();
counter(); // 输出1
counter(); // 输出2
counter(); // 输出3
```

在上面的例子中，调用 outer 函数返回一个内部函数 inner，该内部函数引用了 outer 函数中的变量 count。当执行完 outer 函数后，其执行环境被销毁，但是变量 count 依然存在，因为内部函数 inner 引用了它。所以每次调用 counter 函数时，count 都会累加并输出。

这就是闭包的执行过程：当函数执行完毕后，其执行环境会被销毁，但是变量对象依然存在于作用域链中，直到闭包函数被销毁时才会一起销毁。

#### 讲一下原型、原型链？

在 JavaScript 中，每个对象都有一个内部属性 \[[Prototype]]，通常称为“原型”，它引用另一个对象。这个被引用的对象也可以有自己的原型，并且可能还有自己的原型，这样形成了一个“原型链”。

当我们访问一个对象的属性或方法时，JavaScript 引擎会先在对象自身中查找是否存在该属性或方法，如果没有找到，则会到对象的原型中查找，如果还没找到，会继续在原型的原型中查找，直到找到该属性或者找到原型链的末尾为止。

JavaScript 中，函数对象具有 prototype 属性，而普通对象没有。当我们创建一个函数时，该函数的 prototype 属性指向一个新的对象。这个对象被称为该函数的原型对象。

使用构造函数创建对象时，通过 new 关键字创建的对象会自动继承构造函数的 prototype 属性所指向的原型对象，形成了一个“原型链”。

通过原型链，我们可以实现对象的属性和方法的继承。如果我们尝试访问一个对象的属性或方法，而该对象本身并没有定义该属性或方法，JavaScript 引擎就会在该对象的原型对象中查找，一直到找到为止。

需要注意的是，原型链的层次越深，访问属性的速度就会越慢，因此应该尽量保持原型链的简洁。另外，由于 JavaScript 中对象是动态的，因此在运行时可以随时修改对象的原型，这也是 JavaScript 中比较灵活的特性之一。

#### 原型链的终点是什么？如何打印出原型链的终点？

由于 Object 是构造函数，原型链终点是 Object.prototype.\_\_proto\_\_ ，而 Object.prototype.\_\_proto\_\_ === null // true，所以，原型链的终点是 **null** 。

原型链上的所有原型都是对象，所有的对象最终都是由 Object 构造的，而 Object.prototype 的下一级是 Object.prototype.\_\_proto\_\_ 。

可以通过 \_\_proto\_\_ 或者 Object.getPrototypeOf() 方法来访问一个对象的原型链。我们可以在一个循环中逐级遍历，直到找到终点。

需要注意的是：目前各浏览器对于原型链的定义并不统一，有的是 \_\_proto\_\_，有的是 \[\[prototype]]，需要根据实际情况进行判断，建议使用 Object.getPrototypeOf() 方法实现。

举个例子，在控制台中输入以下代码可以打印出原型链的终点：

```
let obj = {};
let prototype = Object.getPrototypeOf(obj);

while (prototype) {
  console.log(prototype);
  prototype = Object.getPrototypeOf(prototype);
}
```

如果一个对象没有原型，那么 Object.getPrototypeOf(obj) 返回的就是 null。所以循环应该在遍历到 null 之前结束。

#### == 和 === 的区别？

== 和 === 都是比较运算符，主要用于比较两个值的相等性。它们的区别在于以下几点：

- == 运算符会在比较之前进行类型转换，而 === 运算符不会进行类型转换，只有在两个值类型相同的情况下才会返回 true。
- == 运算符在比较时，如果两个值类型不同，会将其中一个值转换为另一个值的类型，然后再比较它们的值。例如，如果比较一个字符串和一个数字，== 运算符会将字符串转换为数字，然后再比较它们的值。而 === 运算符不会进行类型转换，因此如果比较一个字符串和一个数字，它们的类型不同，会直接返回 false。
- === 运算符比 == 运算符更严格，因为它不会进行类型转换，所以在比较时需要注意两个值的类型是否相同。如果类型不同，=== 运算符会直接返回 false。

举个例子：

```
let x = 1;
let y = "1";
console.log(x == y);  // true，因为 "1" 被转换成了数字 1
console.log(x === y); // false，因为类型不同
```

#### `Object.is()` 与比较操作符 “`===`”、“`==`” 的区别？

在 JavaScript 中，Object.is() 方法和比较操作符 === 和 == 都可以用于比较两个值是否相等，但它们之间有一些细微的差别：

=== 和 == 的比较规则是基于相等性运算符（`==`）和严格相等性运算符（`===`）的算法规则。=== 会先判断类型是否相同，再判断值是否相等。== 则会对操作数进行类型转换，再进行比较。因此，=== 是严格相等，要求类型和值都相等，而 == 则允许类型转换后值相等即可。

Object.is() 比较规则不同于 === 和 ==，它认为以下情况是相等的：

1. 两个值都是 undefined
1. 两个值都是 null
1. 两个值都是 true 或都是 false
1. 两个值引用同一个对象
1. 两个值都是数字且具有相同的值，但是区分 +0 和 -0，以及 NaN 和 NaN。

因此，使用 Object.is() 可以更准确地比较两个值是否相等。

#### 什么是 JavaScript 中的包装类型？

JavaScript 中的包装类型是指基本数据类型（如字符串、数字和布尔值）对应的对象类型。当对基本类型的值进行属性和方法的访问时，JavaScript 会自动将基本类型转换为对应的包装类型，执行完操作后再将其转换回基本类型。

举个例子，当我们对字符串 'hello' 调用其 toUpperCase() 方法时，实际上 JavaScript 隐式地将字符串转换为 String 类型的对象，调用对象上的方法，然后再将其转换回字符串类型。

```
let str = 'hello';
console.log(str.toUpperCase()); // 'HELLO'
```

这里的 str 是基本数据类型的字符串，但在调用 toUpperCase() 方法时，JavaScript 自动将其转换为 String 对象类型，因为 toUpperCase() 方法只存在于 String 对象的原型链中。

包装类型的存在是为了在需要使用对象时方便地操作基本数据类型。然而，由于基本数据类型和包装类型之间的自动转换，有时会导致一些意外的问题和性能问题。

#### 为什么 0.1+0.2 ! == 0.3，如何让其相等（精度丢失）

在 JavaScript 中，0.1+0.2 不等于 0.3 是由于浮点数在计算机中的存储方式导致的。由于计算机使用二进制进行存储和计算，无法精确地表示某些十进制数，比如 0.1 和 0.2，所以在计算时会出现精度误差。

要让 0.1+0.2 等于 0.3，一种方法是使用 toFixed() 方法，另一种是将浮点数转换成整数进行计算。例如：

```
const result = (0.1 * 10 + 0.2 * 10) / 10;
console.log(result); // 0.3
```

另外，也可以使用第三方库如 decimal.js、big.js 等来解决浮点数计算精度问题。

#### 执行上下文的类型？执行上下文栈是什么？

执行上下文是 JavaScript 中非常重要的概念之一，它定义了函数在执行过程中的环境。执行上下文可以理解为一个对象，包含了当前执行函数的所有变量、函数、参数等信息。

JavaScript 中有三种执行上下文类型：

1. **全局执行上下文**：在脚本文件中执行的代码会被包含在全局执行上下文中。
1. **函数执行上下文**：每次调用函数都会创建一个新的函数执行上下文。
1. **Eval 函数执行上下文**：在 eval 函数中执行的代码会被包含在 Eval 函数执行上下文中。

执行上下文栈是 JavaScript 中的一个栈结构，它用于存储当前代码执行的所有执行上下文。当 JavaScript 引擎遇到一个函数调用时，会将该函数的执行上下文添加到执行上下文栈的顶部。当函数执行结束时，执行上下文会从栈中弹出，控制权交回上一个执行上下文。

在 JavaScript 中，执行上下文栈的运作机制可以解释函数调用和返回的原理，也能帮助我们更好地理解作用域链、闭包等概念。

#### 执行上下文的三个阶段？

执行上下文可以分为以下三个阶段：

1. **创建阶段（Creation Phase）**：创建阶段是执行上下文的第一个阶段，会在代码执行前进行。在这个阶段，JavaScript 引擎会创建变量对象（Variable Object），建立作用域链（Scope Chain）和确定 this 的指向。其中变量对象包括函数声明、函数的形参和变量声明等。
1. **执行阶段（Execution Phase）**：执行阶段是执行上下文的第二个阶段，会在创建阶段后执行。在这个阶段，JavaScript 引擎会按照顺序执行代码，并根据代码操作变量对象、作用域链和 this 对象等。
1. **销毁阶段（Termination Phase）**：当代码执行完成后，JavaScript 引擎会销毁当前执行上下文。在这个阶段，会释放当前执行上下文所占用的内存空间，并将上下文从执行上下文栈中弹出。

以上三个阶段构成了执行上下文的完整生命周期。

#### 讲一下作用域？什么是作用域链？

作用域（Scope）指的是变量或函数的可访问范围，JavaScript 中有全局作用域和函数作用域两种类型的作用域。

1. **全局作用域**：指的是在函数外部声明的变量和函数，它们可以被代码中的任何地方访问到。
1. **函数作用域**：指的是在函数内部声明的变量和函数，它们只能在函数内部访问到，外部无法访问。
1. **块级作用域**：指的是使用花括号 {} 包围起来的代码块，例如 if 语句、for 循环、函数等。

作用域链（Scope Chain）指的是当 JavaScript 引擎在查找变量的值时，从当前作用域开始查找，如果在当前作用域中找不到该变量，则会一层层向上查找，直到找到该变量或查找到全局作用域为止。

当 JavaScript 引擎在执行函数时，会创建一个执行上下文（Execution Context），每个执行上下文都有一个与之对应的作用域链。在创建执行上下文时，JavaScript 引擎会将当前作用域链保存在执行上下文的内部属性中，当查找变量时，JavaScript 引擎会先查找当前执行上下文的变量，如果找不到则会向上查找作用域链中的上一级执行上下文，直到找到为止。

作用域链的顶端是全局执行上下文，作用域链的底端是当前函数执行上下文，函数执行上下文中的变量和函数可以通过作用域链访问到全局作用域中的变量和函数，但全局作用域中的变量和函数无法通过作用域链访问到函数执行上下文中的变量和函数。

#### 如何延长作用域链？

在 JavaScript 中，作用域链的长度取决于函数定义的位置和嵌套关系。作用域链由当前执行上下文的变量对象（包括该函数的参数、内部变量和函数）和其外部环境的变量对象（如全局环境变量对象）组成。作用域链的主要作用是用于查找变量和函数的值。

在函数内部通过 with 语句或者 eval() 函数创建新的变量对象时，也会延长作用域链。使用 with 语句时，将指定对象添加到作用域链的前端。使用 eval() 函数时，将传入的字符串解析为 JavaScript 代码并将其执行，并将其变量和函数定义添加到当前作用域链的前端。

需要注意的是，with 语句和 eval() 函数会降低代码的可读性和可维护性，同时也可能引发安全问题，应该尽量避免使用。

#### 作用域链应用场景有哪些？

作用域链是 JavaScript 中非常重要的概念，它决定了变量和函数在代码中的可见性和可访问性。下面介绍一些作用域链应用场景：

1. **实现闭包**：在 JavaScript 中，函数内部可以访问外部函数的变量和函数，这就是闭包。闭包的实现依赖于作用域链，即内部函数可以访问外部函数的变量是因为内部函数的作用域链包含了外部函数的作用域链。
1. **模块化开发**：作用域链可以用来实现模块化开发，即将代码拆分成多个模块，每个模块都有自己的作用域，不同模块之间的变量和函数不会互相干扰。这可以通过立即执行函数表达式（IIFE）等方式实现。
1. **变量查找**：作用域链可以决定变量的查找顺序。当需要查找某个变量时，JavaScript 引擎会沿着作用域链依次查找变量，直到找到该变量或者到达全局作用域。这个过程是自动进行的，我们不需要显式地指定变量的查找路径。
1. **作用域隔离**：作用域链可以实现作用域隔离，即在不同的作用域中定义同名变量不会相互影响。这可以有效地避免变量名冲突的问题。

总之，作用域链是 JavaScript 中非常重要的概念，可以用来实现许多复杂的功能，也是理解 JavaScript 闭包和模块化开发的基础。

#### 变量提升与函数提升的区别？

变量提升和函数提升都是 JavaScript 中的预解析机制。它们的区别在于变量提升只会将声明提升至作用域的顶部，而不会将赋值也提升至作用域的顶部，而函数提升则会将整个函数声明提升至作用域的顶部。

具体来说，变量提升会将变量声明提升至作用域的顶部，但是不会将变量的赋值也提升。例如：

```
console.log(a);  // undefined
var a = 1;
```

上述代码中，变量 a 在 console.log 语句之前被声明了，但是由于变量提升只将声明提升至作用域的顶部，所以此时 a 的值为 undefined。

而函数提升会将整个函数声明提升至作用域的顶部，包括函数名和函数体。例如：

```
foo();  // "Hello, world!"
function foo() {
  console.log("Hello, world!");
}
```

上述代码中，函数 foo 的声明被提升至作用域的顶部，因此在函数调用之前就已经可以访问到它。

需要注意的是，使用 let 和 const 声明的变量不会存在变量提升，因此不能在声明之前使用这些变量。同时，使用 const 声明的常量必须在声明时就赋值，否则会报错。

### var、let 和 const 的区别？

在 ES6 中，引入了 let 和 const 关键字，可以用来定义块级作用域的变量，也就是只在当前代码块内有效，出了代码块就无法访问。与之不同的是，使用 var 关键字定义的变量是函数作用域的，如果在函数内部使用 var 定义的变量，那么这个变量在整个函数内部都是可访问的。

总结一下 var、let、const 的区别：

1. var 定义的变量是函数作用域的，而 let 和 const 定义的变量是块级作用域的。
1. var 定义的变量可以被重新赋值和重新声明，而 let 定义的变量可以被重新赋值但不能被重新声明，const 定义的变量既不能被重新赋值也不能被重新声明。
1. 在全局作用域下使用 let 和 const 定义变量时不会将其挂在全局对象下，而 var 定义的变量会。

需要注意的是，由于 JavaScript 中存在变量提升的机制，在使用 var 声明变量时，变量会被提升到函数作用域的顶部，因此在变量声明之前访问该变量不会报错，但是其值为 undefined。而使用 let 和 const 声明变量时，则不存在变量提升的情况，访问未声明的变量会直接报错。

#### 说说 JS 中的预解析？

JavaScript 中的预解析（Hoisting）是指在代码执行之前，JavaScript 引擎会先扫描整个代码，将所有的变量声明和函数声明提前到当前作用域的顶部，这个过程就称为预解析。

在预解析过程中，变量声明会被提前到作用域顶部，但是变量的赋值不会被提前。函数声明会被整个提前，包括函数体内的代码。而函数表达式只会被提前函数名，不会被提前函数体内的代码。

例如：

```
console.log(a); // undefined
var a = 1;

console.log(b); // Uncaught ReferenceError: b is not defined
let b = 2;

foo(); // "hello"
function foo() {
  console.log("hello");
}

bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log("world");
};
```

在上面的代码中，变量 a 被预解析并被赋予了默认值 undefined，所以第一次 console.log 输出 undefined，而变量 b 是用 let 声明的，它不存在变量提升，所以在声明之前访问会报错。

函数 foo() 是函数声明，因此整个函数会被提前，所以在函数声明之前调用函数不会报错。而变量 bar 是一个函数表达式，只有函数名被提前，函数体内的代码不会被提前，所以在声明之前调用会报错。

因此，了解 JavaScript 中的预解析对于理解变量作用域和函数作用域都是非常重要的。

#### 讲一下异步编程？异步编程的实现方式？

异步编程是指在代码执行过程中可以同时处理多个任务，而不必等待前一个任务结束才能执行下一个任务的编程方式。在 JavaScript 中，异步编程可以通过回调函数、Promise 和 async/await 等方式来实现。

1. 回调函数

回调函数是一种最简单的异步编程方式。它通过在函数调用时传递一个回调函数来实现异步操作。当异步操作完成后，回调函数会被调用。

例如，读取文件是一个异步操作，可以通过 Node.js 的 fs 模块的 readFile 方法来实现：

```
const fs = require('fs');

fs.readFile('file.txt', 'utf8', function(err, data) {
  if (err) throw err;
  console.log(data);
});
```

2. Promise

Promise 是一种更加先进的异步编程方式，它可以解决回调函数存在的一些问题，例如回调地狱和错误处理。

Promise 有三个状态：pending（等待状态）、fulfilled（已完成状态）和 rejected（已失败状态）。当异步操作完成时，Promise 会从等待状态转变为已完成状态或已失败状态。

Promise 提供了 then 和 catch 方法来处理异步操作的结果。then 方法用于处理已完成状态的结果，catch 方法用于处理已失败状态的结果。

例如，可以通过 Promise 实现读取文件：

```
const fs = require('fs/promises');

fs.readFile('file.txt', 'utf8')
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

3. async/await

async/await 是一种基于 Promise 的异步编程方式，它可以让异步代码看起来像同步代码，提高了代码的可读性和可维护性。

async/await 在函数前加上 async 关键字，使函数返回一个 Promise。在函数内部，使用 await 关键字来等待异步操作的完成，然后使用 try/catch 来捕获错误。

例如，可以通过 async/await 实现读取文件：

```
const fs = require('fs/promises');

async function readFile() {
  try {
    const data = await fs.readFile('file.txt', 'utf8');
    console.log(data);
  } catch (err) {
    console.error(err);
  }
}

readFile();
```

异步编程的实现方式多种多样，不同的场景适合不同的实现方式。需要根据实际情况选择合适的方式。

#### 并发与并行的区别？同步任务和异步任务的区别？

并发与并行

1. 并发（concurrency）指的是在一段时间内，多个任务同时在执行，但是不一定是在同一时刻在执行，可能是交替执行，因此对于用户来说是同时在执行。
1. 并行（parallelism）指的是在同一时刻多个任务在同时执行，因此对于用户来说是真正意义上的同时执行。

同步任务和异步任务

1. 同步任务（synchronous task）指的是在主线程上排队执行的任务，只有当前面的任务执行完毕，后面的任务才能执行。同步任务是阻塞式的，只有等待前面的任务执行完毕，才能执行下一个任务。
1. 异步任务（asynchronous task）指的是不在主线程上排队执行的任务，而是在任务完成后将结果通知到任务队列中，等待主线程空闲后再来执行。异步任务是非阻塞式的，可以在任务执行的同时执行其他的任务。常见的异步任务包括定时器、事件监听、Ajax 请求等。

#### setTimeout、setInterval、requestAnimationFrame 的区别？

setTimeout、setInterval 和 requestAnimationFrame 都是 JavaScript 中常见的定时器 API，但它们的使用场景和工作原理有所不同。

1. **setTimeout**：setTimeout 函数是在指定的时间间隔后执行一次回调函数。它可以用于实现延迟执行某个任务或定时触发某个事件。
1. **setInterval**：setInterval 函数是在指定的时间间隔内重复执行一个回调函数。它可以用于实现周期性执行某个任务或定时轮询某个事件。
1. **requestAnimationFrame**：requestAnimationFrame 是浏览器提供的一个 API，它的作用是在下一次浏览器重绘之前执行指定的回调函数。requestAnimationFrame 可以实现平滑的动画效果，避免了由于帧率过低导致的卡顿和画面撕裂等问题。

区别如下：

1. setTimeout 和 setInterval 在执行回调函数时，不考虑浏览器是否正在执行其他任务，因此可能会因为浏览器执行任务过多而出现卡顿、延迟等问题，而 requestAnimationFrame 会在浏览器空闲时执行回调函数，因此能够更好地保证性能和用户体验。
1. setTimeout 和 setInterval 可以自由控制执行时间间隔，而 requestAnimationFrame 则是根据浏览器的刷新率自动调整回调函数的执行时间。
1. 在不同的场景下，这三个 API 的使用方式也有所不同。setTimeout 和 setInterval 适用于周期性执行某个任务或延迟执行某个任务的场景，而 requestAnimationFrame 则适用于实现平滑的动画效果。

#### setTimeout、Promise、async/await 的区别？

setTimeout、Promise、async/await 都是 JavaScript 中用于处理异步编程的机制，它们之间有以下的区别：

1. **setTimeout**：setTimeout 是一种在指定时间后执行一次的异步调用方法，它将回调函数加入到任务队列中，等待执行。setTimeout 可以用于实现定时器和一些简单的异步操作。
1. **Promise**：Promise 是一种可以表示异步操作的对象，它可以让我们更方便地进行异步编程。Promise 对象表示一个异步操作的最终完成或失败，并返回一个结果值或错误。Promise 有三种状态，分别为 Pending、Resolved 和 Rejected。在异步操作成功时，会调用 resolve 函数，将 Promise 对象的状态设置为 Resolved，否则调用 reject 函数，将 Promise 对象的状态设置为 Rejected。Promise 可以通过 then 和 catch 方法进行链式调用。
1. **async/await**：async/await 是一种使用 Promise 进行异步编程的语法糖，它可以让异步代码看起来像同步代码一样易于理解和编写。async/await 在语言层面提供了异步编程的支持，它使得异步代码的执行顺序更加明确，避免了回调函数嵌套带来的问题。async/await 是基于 Promise 实现的，async 函数返回一个 Promise 对象，可以通过 await 关键字等待异步操作的完成，并获取异步操作的结果。

#### 说说你对 this 的理解？如何判断 this 的指向？

在 JavaScript 中，this 是一个关键字，用来指向当前函数的上下文对象。this 的指向会根据函数的调用方式而变化。

通常情况下，this 的指向可以通过函数的调用方式来判断。以下是常见的几种情况：

1. **默认绑定**：当函数直接调用时，this 指向全局对象（非严格模式）或 undefined（严格模式）。
1. **隐式绑定**：当函数作为对象的方法调用时，this 指向该对象。
1. **显示绑定**：当使用 call、apply 或 bind 方法时，可以显式指定函数的 this 指向。
1. **new 绑定**：当使用 new 关键字调用构造函数时，this 指向新创建的对象。

在判断 this 的指向时，可以先排除掉默认绑定的情况，再根据函数的调用方式来确定 this 的指向。

需要注意的是，在箭头函数中，this 的指向是在定义时确定的，指向外层函数的 this，而不是在调用时确定的。

此外，还有一些特殊情况，例如使用 bind 方法绑定 this 后返回一个新的函数时，新函数中的 this 仍然指向原来的对象，而不是 bind 方法中指定的对象。

综上所述，判断 this 的指向需要结合具体的场景来分析。通常可以先排除掉默认绑定的情况，再根据函数的调用方式来确定 this 的指向。如果还存在不确定的情况，可以使用一些工具或方法来辅助判断，例如调试工具、箭头函数等。

#### 有哪些方法可以改变 this 指向？call、apply 和 bind 的区别？

在 JavaScript 中，有几种方法可以改变函数的 this 指向，包括 call()、apply()、bind() 和 使用变量保存 this 四种方式。

call() 和 apply() 可以将函数中的 this 指向指定的对象，并立即执行函数。两者的区别在于参数传递的方式不同，call() 采用逐个传递参数，而 apply() 则通过数组的形式传递参数。

bind() 方法也可以改变函数的 this 指向，但与 call() 和 apply() 不同的是，它不会立即执行函数，而是返回一个新的函数，需要调用返回的函数才能执行原来的函数。

箭头函数在定义时会捕获当前上下文的 this 值，并且该值在函数生命周期内不会发生变化。这意味着在箭头函数中无法通过 call()、apply() 或 bind() 方法来改变函数的 this 指向。

使用对象方法调用函数时，函数的 this 指向该对象。

要判断函数中的 this 指向，可以根据函数的调用方式和定义方式来确定。如果函数是作为对象的方法调用，则 this 指向该对象；如果是作为普通函数调用，则 this 指向全局对象；如果使用 call()、apply() 或 bind() 方法改变函数的 this 指向，则 this 指向指定的对象；如果使用箭头函数定义函数，则 this 指向定义时的上下文。

####

在 JavaScript 中，使用 new 关键字创建一个对象时，发生了以下步骤：

1. 创建一个新的空对象。
1. 将该对象的原型指向构造函数的 prototype 属性。
1. 使用指定的参数列表调用函数，并将 this 绑定到新创建的对象上。
1. 如果构造函数没有返回任何对象，则返回新创建的对象；否则，返回构造函数返回的对象。

举个例子，假设有以下构造函数：

```
function Person(name, age) {
  this.name = name;
  this.age = age;
}
```

使用 new 关键字创建一个 Person 实例的过程如下：

```
const person = new Person('John', 30);
```

1. 创建一个空对象 {}。
1. 将该对象的原型指向 Person.prototype。
1. 调用 Person 函数，并将 this 绑定到新创建的对象上，即执行 this.name = 'John'; this.age = 30;。
1. 返回新创建的对象 { name: 'John', age: 30 }。

在这个过程中，Person 函数就充当了一个类的角色，而通过 new 关键字创建的对象就是该类的一个实例。

#### 怎么判断一个对象是否是空对象？

可以使用 Object.keys() 或 Object.getOwnPropertyNames() 方法来判断一个对象是否是空对象，这两个方法都可以获取对象自身属性的属性名，如果返回的数组长度为 0，则说明对象没有自身属性，即为空对象。

例如：

```
const obj1 = {};
const obj2 = { foo: 'bar' };

console.log(Object.keys(obj1).length === 0); // true
console.log(Object.keys(obj2).length === 0); // false
console.log(Object.getOwnPropertyNames(obj1).length === 0); // true
console.log(Object.getOwnPropertyNames(obj2).length === 0); // false
```

上面的代码中，obj1 是空对象，obj2 不是空对象。可以使用 Object.keys() 或 Object.getOwnPropertyNames() 方法判断它们是否为空对象。

#### 说说你对 JSON 的理解？

JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它基于 JavaScript 语法的子集，具有易于理解和编写、易于解析和生成、易于扩展和使用等优点。JSON 可以表示简单的值，例如字符串和数字，还可以表示复杂的结构，例如对象和数组。

JSON 的语法和 JavaScript 对象的语法非常相似，由于 JavaScript 的普及，JSON 已经成为了很多应用程序中的标准数据格式之一。JSON 支持的数据类型包括字符串、数字、布尔值、null、对象和数组，其中对象和数组可以嵌套使用。

在 JavaScript 中，可以使用 JSON 对象的 parse() 方法将 JSON 字符串转换为 JavaScript 对象，使用 stringify() 方法将 JavaScript 对象转换为 JSON 字符串。通过使用 JSON，应用程序可以方便地传递和处理数据，与传统的 XML 数据格式相比，JSON 更加简单、轻量和易于使用。

#### 什么是伪数组（类数组）？

伪数组（或称类数组）是一种类似于数组的对象，它具有以下特点：

1. 有从 0 开始的数字索引
1. 拥有 length 属性
1. 没有数组所具有的方法（如 push、pop、forEach 等）
1. 常见的伪数组包括函数的 arguments 对象、DOM 元素的 NodeList、HTMLCollection 等。

尽管伪数组看起来像是数组，但它们不是真正的数组，因为它们没有数组的原型。因此，如果要对伪数组进行数组操作，需要使用一些方法将其转换为真正的数组，比如使用 Array.from 或 Array.prototype.slice.call 方法。

#### 类数组转换成数组的方法有哪些？

类数组指的是具有数组的 length 属性和索引值的对象，但是没有数组的原型方法（如 push、pop、splice 等）。将类数组转换成数组有以下几种方法：

Array.from()：ES6 新增的方法，可以将类数组对象或可迭代对象转换成真正的数组。

```
const arrayLike = {0: 'a', 1: 'b', 2: 'c', length: 3};
const arr = Array.from(arrayLike); // ['a', 'b', 'c']
```

Array.prototype.slice.call()：可以将一个类数组对象转换成一个新的数组，常用于将 arguments 转换成数组。

```
function foo() {
  const arr = Array.prototype.slice.call(arguments); // 将 arguments 转换成数组
  console.log(arr);
}
foo(1, 2, 3); // [1, 2, 3]
```

扩展运算符（...）：同样可以将一个类数组对象转换成一个新的数组。

```
const arrayLike = {0: 'a', 1: 'b', 2: 'c', length: 3};
const arr = [...arrayLike]; // ['a', 'b', 'c']
```

Array.prototype.concat.apply()：与第二种方法类似，将类数组对象转换成一个新的数组。

```
const arrayLike = {0: 'a', 1: 'b', 2: 'c', length: 3};
const arr = Array.prototype.concat.apply([], arrayLike); // ['a', 'b', 'c']
```

需要注意的是，以上几种方法都是将类数组对象转换成一个新的数组，原始的类数组对象并没有改变。

#### Unicode、UTF-8、UTF-16、UTF-32 的区别？

Unicode 是一种字符集，定义了每个字符对应的唯一编号，可以看作是字符和数字的映射关系。UTF（Unicode Transformation Format）是一种编码方式，将 Unicode 中的数字编码为字节序列，以便存储和传输。

UTF-8 是一种可变长度的编码方式，使用 1-4 个字节表示每个字符，适用于存储英文、数字、符号等单字节字符，也能够表示中文、日文等多字节字符。UTF-8 最大的优点是向后兼容 ASCII 编码，它的前 128 个字符与 ASCII 编码完全相同。

UTF-16 也是一种可变长度的编码方式，使用 2 或 4 个字节表示每个字符，适用于存储英文、数字、符号等单字节字符，以及中文、日文等多字节字符。与 UTF-8 不同，UTF-16 对于字符的编码方式是固定的，不存在字节序列的问题。

UTF-32 是一种固定长度的编码方式，使用 4 个字节表示每个字符，适用于存储所有字符。UTF-32 对于每个字符都分配了固定的空间，因此可以快速访问任何一个字符，但相应的存储空间会更大。

总之，Unicode 定义了字符集，UTF 定义了字符集到字节序列的映射方式，不同的 UTF 编码方式决定了字符集到字节序列的具体实现方式，每种编码方式都有自己的优缺点，需要根据实际情况进行选择。

#### escape、encodeURI、encodeURIComponent 的区别？

在 JavaScript 中，escape、encodeURI 和 encodeURIComponent 都是用来对字符串进行编码的方法，但它们的具体实现和编码规则有所不同，因此在使用时需要根据具体的情况选择合适的方法。

1. **escape**: 对字符串进行编码，将字符串中的非 ASCII 字符全部转义为 %xx 的格式，其中 xx 表示字符的 16 进制编码值。需要注意的是，该方法已经被废弃，不建议在实际开发中使用。
1. **encodeURI**: 对整个 URL 进行编码，主要用于编码 URL 中的查询参数部分。与 escape 不同，该方法只会对非 ASCII 字符进行编码，将其转义为 %xx 的格式。此外，该方法不会对一些特殊字符进行编码，例如冒号、正斜杠、问号等。
1. **encodeURIComponent**: 用于对 URI 的组成部分进行编码，主要用于编码 URI 中的路径部分和查询参数部分。与 encodeURI 不同，该方法会对所有非 ASCII 字符进行编码，并将其转义为 %xx 的格式。同时，该方法还会对一些特殊字符进行编码，例如冒号、正斜杠、问号等。

需要注意的是，无论是哪种编码方法，都可以使用对应的解码方法进行解码，例如 unescape、decodeURI 和 decodeURIComponent。

#### 什么是尾调用，使用尾调用有什么好处？

尾调用是指函数调用语句中的函数调用是另一个函数的最后一条语句。当一个函数在执行完自己的任务后，调用另外一个函数并将其结果返回时，如果该调用语句满足一定的条件，那么这个调用语句就是一个尾调用。尾调用不会在当前函数创建一个新的栈帧，而是可以复用当前函数的栈帧，从而达到优化内存使用的目的。

使用尾调用可以避免函数调用栈过深，从而提高性能和减少内存消耗。对于一些需要频繁调用的函数，使用尾调用可以有效地减少内存消耗和栈溢出的风险。

需要注意的是，尾调用优化不是 ECMAScript 规范中必须实现的，实现也存在兼容性问题，因此在编写代码时需要谨慎使用。

#### use strict; 是什么? 它有什么作用？

"use strict" 是 JavaScript 的一个指令，用于告诉浏览器或 Node.js，启用严格模式（strict mode）。在严格模式下，JavaScript 引擎会进行额外的检查，以帮助开发人员避免一些常见的错误，从而提高代码的安全性和可靠性。

使用 "use strict" 可以带来以下好处：

1. 严格模式禁止使用一些不安全的语法，如未声明变量、删除变量等，这可以避免一些潜在的错误。
1. 严格模式中禁止使用 with 语句，这可以防止代码中出现一些奇怪的行为，提高代码的可读性和可维护性。
1. 在严格模式下，函数中的 this 关键字会被绑定到 undefined，而不是全局对象，这可以避免一些奇怪的行为。
1. 严格模式中的 eval 函数不能修改当前作用域中的变量或声明函数，这可以减少一些潜在的安全风险。

总之，使用 "use strict" 可以使代码更加安全、可靠和易于维护。

#### 如何判断一个对象是否属于某个类？

在 JavaScript 中，我们可以使用 instanceof 操作符来判断一个对象是否属于某个类。instanceof 操作符需要两个操作数，一个是待判断的对象，一个是目标类构造函数。

语法如下：

```
object instanceof constructor
```

如果 object 是 constructor 的实例，返回 true，否则返回 false。

例如，判断 obj 是否是 Array 类的实例：

```
var obj = [1, 2, 3];
console.log(obj instanceof Array); // true
```

需要注意的是，instanceof 判断的是对象是否是由目标类构造函数创建的实例，而不是判断对象的类型。如果对象是通过字面量或 Object.create() 创建的，instanceof 会返回 false。

此外，如果一个类的原型链中包含了目标类的原型对象，也会返回 true。因此，instanceof 可以用来实现继承。

#### 强类型语言和弱类型语言的区别？

强类型语言和弱类型语言是编程语言的两个重要概念，它们的区别在于变量的类型检查和类型转换方面：

1. **强类型语言**：变量类型一旦定义就不能改变，变量的类型检查非常严格，需要明确地进行类型转换。例如，Java 和 C# 都是强类型语言。
1. **弱类型语言**：变量类型可以随时改变，变量的类型检查比较宽松，可以进行隐式类型转换。例如，JavaScript 和 PHP 都是弱类型语言。

强类型语言的优点在于程序员可以更早地发现类型错误，减少程序出错的概率。弱类型语言的优点在于编写代码的灵活性更高，节省了时间和精力。

需要注意的是，强类型语言和静态类型语言是两个不同的概念，不要混淆。强类型语言可以是动态类型语言，例如 JavaScript，而静态类型语言也可以是弱类型语言，例如 PHP。

#### 解释性语言和编译型语言的区别？

解释性语言和编译型语言是两种不同的语言类型。

解释性语言是指在执行程序时，将程序代码一行一行解释成机器代码并立即执行。解释性语言在运行时需要不断解释代码，因此通常执行速度比较慢。代表性的解释性语言有 JavaScript、Python、Ruby 等。

编译型语言则是在运行程序之前需要将程序代码编译成机器语言，并将其存储在可执行文件中。编译型语言在编译时会对代码进行优化，因此在执行时速度通常比解释型语言快。代表性的编译型语言有 C、C++、Java 等。

总体来说，解释型语言更加灵活，开发效率高，但运行速度相对较慢；而编译型语言则更加高效，运行速度快，但开发效率相对较低。

#### includes 比 indexOf 好在哪？

includes 和 indexOf 都是用来检查字符串或数组中是否包含某个元素的方法，但是它们有以下几点不同：

1. **返回值不同**：includes 返回一个布尔值，表示是否包含指定元素；indexOf 返回一个整数值，表示指定元素在数组中的位置，如果不存在则返回 -1。
1. **参数不同**：includes 只接受一个参数，即要检查的元素值；indexOf 还可以接受第二个参数，表示从哪个位置开始检索。
1. **语法简洁性**：使用 includes 的语法更加简洁易读。

相比之下，includes 更加直观易用，代码更加简洁，且在一些特殊情况下性能也更好。但是需要注意的是，includes 是 ES6 新增的方法，在一些老版本浏览器中可能不支持，需要进行兼容性处理。而 indexOf 则是比较常用的数组方法，几乎所有的浏览器和 JS 引擎都支持。因此，具体使用哪种方法应该根据具体的场景和需求来进行选择。

#### 什么是回调函数？回调函数有什么缺点？

回调函数是指在异步操作执行完毕后所需执行的函数。通常，异步操作执行完毕后会调用回调函数，将异步操作的结果作为参数传递给回调函数，然后执行回调函数。回调函数常用于处理异步操作的结果，例如 AJAX 请求、定时器、事件监听等。

回调函数的主要缺点在于，当多个异步操作需要执行时，会出现“回调地狱”的情况。也就是说，回调函数会嵌套在回调函数中，使得代码变得难以阅读、难以维护。此外，回调函数还存在着一些其他的问题，例如容易出现错误、难以处理异步操作的错误等。因此，在开发中，我们可以考虑使用 Promise、async/await 等异步编程的解决方案来避免回调地狱和其他问题。

#### 什么是回调地狱？回调地狱会带来什么问题？如何解决回调地狱问题？

回调地狱指的是多层嵌套的回调函数，形成代码缩进过深、难以维护和理解的情况。

回调地狱会导致代码复杂度上升，难以调试和维护，同时也会影响代码的可读性和可维护性。

解决回调地狱的方法有以下几种：

1. **Promise**：使用 Promise 可以将异步操作封装成 Promise 实例，在 Promise 实例中链式调用 then 方法，避免了多层嵌套的回调函数，使代码更加可读且易于维护。
1. **async/await**：async/await 是在 Promise 基础上的语法糖，可以更加优雅地处理异步操作。使用 async/await 可以将异步操作写成同步代码的形式，避免了回调地狱的问题。
1. **发布/订阅模式**：发布/订阅模式是一种广泛使用的异步编程模式，通过发布者发布消息，订阅者订阅消息，实现了解耦和更好的可维护性。在该模式中，发布者和订阅者通过事件或消息进行交互，而不是通过直接调用回调函数。

综上所述，使用 Promise、async/await 或发布/订阅模式可以避免回调地狱的问题，使代码更加易于维护和扩展。

#### 什么是 ajax？讲一下 ajax readyState 五种状态？

Ajax（Asynchronous JavaScript and XML）指的是一种通过 JavaScript 和 XML 实现异步通信的技术，可以实现在不刷新页面的情况下向服务器请求数据并更新部分页面内容。

XMLHttpRequest 对象是 Ajax 技术的核心，它有五个 readyState 状态：

0: (Uninitialized) the send( ) method has not yet been invoked.
1: (Loading) the send( ) method has been invoked, request in progress.
2: (Loaded) the send( ) method has completed, entire response received.
3: (Interactive) the response is being parsed.
4: (Completed) the response has been parsed, is ready for harvesting.

0 － （未初始化）还没有调用 send()方法
1 － （载入）已调用 send()方法，正在发送请求
2 － （载入完成）send()方法执行完成，已经接收到全部响应内容
3 － （交互）正在解析响应内容
4 － （完成）响应内容解析完成，可以在客户端调用了

每当 XMLHttpRequest.readyState 的状态改变时，都会触发 XMLHttpRequest.onreadystatechange 事件。可以根据不同的状态进行不同的操作，例如：

```
const xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
  if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.open('GET', 'https://example.com/data.json');
xhr.send();
```

以上代码会向服务器发送一个 GET 请求，并在响应完成后打印响应内容。当 readyState 状态为 DONE 且响应状态码为 200 时，表示响应已经完成，可以通过 responseText 属性获取响应内容。

#### 请介绍一下 XMLHTTPRequest 对象？

#### ajax、axios、fetch 的区别？

#### 取消 ajax 请求有什么意义？

#### ES6 更新了哪些新语法？（从你回答的里面挑一个问详细的）

1. Promise 是什么？
1. 介绍一下 Promise 的 3 种状态，怎么改变状态？
1. Promise 有哪些 API？
1. Promise.all、Promise.race、Promise.any 的区别？
1. Promise 有什么缺点？
1. 对 async await 的理解？
1. await 到底在等待啥？
1. await 如何捕获异常？
1. async/await 对比 Promise 的优势
1. 对浅拷贝深拷贝的理解？
1. JSON.stringify 深拷贝的缺点
1. 怎么实现深拷贝？（建议写博客）
1. Object.assign 和扩展运算符是深拷贝还是浅拷贝，两者区别？
1. 深度遍历广度遍历的区别？
1. 知道 lodash 吗？它有哪些常见的 API ？
1. (a == 1 && a == 2 && a == 3) 有可能是 true 吗？
1. 后端返回 1 万条数据，你要怎么进行渲染？
1. 你对虚拟列表的理解？
1. JS 中的数组和函数在内存中是如何存储的？
1. 什么是函数式编程？
1. 函数式编程的优缺点？
1. 什么是纯函数，它有什么优点？
1. 什么是组合函数（compose）？
1. 什么是惰性函数？
1. 什么是高阶函数？
1. 说说你对函数柯里化的理解？
1. 什么是箭头函数，有什么特征？
1. 说说你对递归函数的理解？
1. 什么是尾递归？
1. 函数传参，传递复杂数据类型和简单数据类型有什么区别？
1. 函数声明与函数表达式的区别？
1. 什么是函数缓存，如何实现？
1. 说说面向对象的特性与特点？
1. 说说你对工厂模式的理解？
1. 创建对象有哪几种方式？
1. 宿主对象和原生对象的区别？
1. 说一下 hasOwnProperty、instanceof 方法？
1. 如何实现类？（建议写博客）
1. 如何实现继承？（建议写博客，ES5、ES6 各至少一种）

<!--
 * @Author: Shu Binqi
 * @Date: 2023-02-24 21:04:05
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-02-27 17:11:39
 * @Description: JavaScript 面试题汇总
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\JavaScript.md
-->

#### JavaScript 的数据类型有哪些？

JavaScript 共有 8 种数据类型，具体如下：

1. Number：数值类型，包括整数和浮点数。
1. String：字符串类型。
1. Boolean：布尔类型，只有两个值：true 和 false。
1. Null：表示空值或空对象指针。
1. Undefined：表示未定义或不存在的值。
1. Symbol：表示唯一的标识符，通常用于对象属性的键值。
1. BigInt：用于表示大整数，可以处理超出 Number 类型表示范围的整数。
1. Object：表示一个复杂数据类型，可以存储多个键值对。

其中，前 7 种数据类型为原始类型，都是不可变的，而 Object 则为引用类型，可以存储任意类型的数据。

（回答就 0 分的有：数组、函数、日期，这些是 类 class；不是类型 type）

#### 判断数据类型的方法有哪些？

① 判断多种数据类型

1. typeof：可以判断除 null 外的 ES5 基本数据类型
2. instanceof：可以正确判断对象的类型
3. construter：可以正确判断数据类型（如果创建一个对象并改变他的原型，就不能用 construter 判断类型了）
4. Object.prototype.toString.call()：可以正确判断对象的类型

需要注意的是，typeof null 的结果是 "object"，这是 JavaScript 语言本身的一个 bug，可以通过 typeof value === "object" && value === null 的方式来判断一个值是否为 null。

② 判定单个数据类型

1. Array.isArray()：判断是否是数组类型

③ 判断某个数据

1. isNaN：判断是否是一个非数字（会进行类型转换）
2. Number.isNaN：判断是否是一个非数字（首先判断是否是数字，再进行判断）
   ```
   console.log(isNaN('测试')) //true
   console.log(Number.isNaN('测试')) //false
   ```
3. isFinite() 用来判断被传入的参数值是否为一个有限数值（finite number），如果参数是 NaN，正无穷大或者负无穷大，会返回 false，其他返回 true。

#### null 和 undefined 的区别是什么？

null：空指针对象
undefined：未定义
相同点：都是基本数据类型
不同点：

1. 变量声明了但还没有定义的时候会返回 undefined；null 主要用于赋值给一些可能会返回对象的变量，作为初始化。
2. 使用 typeof 判断类型时 null 会返回 object；undefined 正确返回。（这是一个历史遗留的问题）

#### 判断数组类型有哪几种方法？

1. Array.isArray()：
2. Object.peototype.toString.call()：
3. instanceof：
4. Array.isPrototypeOf()：

#### 什么是事件冒泡？怎么阻止事件冒泡？

事件冒泡是指当一个元素上的事件被触发后，它会向父级元素一层层地逐级触发，直到触发到 document 对象为止。例如，当点击一个子元素时，如果该元素上绑定了事件处理程序，那么点击事件会先触发子元素上的事件处理程序，然后一级一级地向上传递，直到到达 document 对象。

阻止事件冒泡的方法有两种：

1. 使用 event.stopPropagation() 方法，该方法会阻止事件进一步冒泡。在事件处理程序中调用该方法，可以阻止事件向上层元素冒泡。
1. 使用 event.cancelBubble 属性，在 IE 中，该属性可以设置为 true，来阻止事件进一步冒泡。在其他浏览器中，该属性已经被废弃，需要使用 event.stopPropagation() 方法来代替。

#### 什么是事件捕获？如何阻止事件捕获？

事件捕获是指当一个元素触发了某个事件时，事件会从它的祖先元素一层层往下传递，直到到达目标元素并触发该事件。事件捕获的顺序与事件冒泡相反，即从外到内。

在事件捕获的过程中，可以通过调用 Event 对象的 stopPropagation() 方法来阻止事件的继续传递。该方法会停止事件的捕获和冒泡过程，并防止任何父元素或子元素受到影响。

具体来说，stopPropagation() 方法应该在事件处理程序中调用，例如：

```
document.addEventListener('click', function(event) {
  event.stopPropagation();
  // 事件处理逻辑
}, true);
```

在上述代码中，addEventListener() 方法的第三个参数为 true，表示事件使用捕获阶段进行处理。event.stopPropagation() 方法会阻止事件的继续传递，避免影响其他元素。

需要注意的是，虽然 stopPropagation() 方法可以阻止事件的继续传递，但它并不能阻止事件处理程序本身的执行。如果需要完全禁用事件处理程序的执行，可以使用 preventDefault() 方法，它可以阻止事件的默认行为，例如阻止链接的跳转或表单的提交。

#### 什么是事件委托？

事件委托（Event Delegation）是一种常用的优化前端性能的技术，它是利用事件冒泡的特性，将事件处理器绑定到它们的共同祖先节点上，从而减少绑定事件处理器的数量，提高页面的响应速度。
通过事件委托，我们可以将事件处理器绑定到共同祖先元素上，而不是将事件处理器绑定到每个子元素上。这样，当事件触发时，事件会一直冒泡到祖先元素，并在祖先元素上触发相应的事件处理器。这样就可以利用事件冒泡的机制，实现子元素和父元素之间的事件传递。
使用事件委托的好处有：

1. 减少绑定事件的数量，提高性能。
2. 动态添加的元素也可以自动绑定事件，不需要再手动绑定。
3. 可以避免因为动态添加的元素没有绑定事件而导致的事件失效的问题。

事件委托的应用场景包括：

1. 列表元素的点击事件，通过事件委托在列表的父元素上绑定点击事件，而不是在每个列表元素上绑定点击事件。
2. 表单元素的提交事件，通过事件委托在表单的父元素上绑定提交事件，而不是在每个表单元素上绑定提交事件。
3. 动态添加的元素的事件绑定，通过事件委托在它们的共同祖先元素上绑定事件处理器，而不需要在动态添加的元素上手动绑定事件处理器。

#### ES6 有哪些新语法？

ES6（ECMAScript 2015）引入了许多新的语法和特性，其中一些主要的包括：

1. 块级作用域：使用 let 和 const 声明变量时可以创建块级作用域。
1. 箭头函数：使用 => 语法定义匿名函数。
1. 解构赋值：可以从数组和对象中提取值并将其赋给变量。
1. 模板字符串：使用反引号 `` 来创建多行字符串，并且可以在字符串中插入表达式。
1. 默认参数：定义函数参数的默认值。
1. 展开运算符：使用 ... 语法来展开数组或对象。
1. 类和继承：使用 class 和 extends 关键字来定义类和继承。
1. 模块化：使用 import 和 export 关键字来导入和导出模块。
1. Promise：处理异步操作的一种方法，可以通过链式调用来组合多个异步操作。
1. Symbol：引入了一种新的原始数据类型，用于创建唯一的标识符。
1. Map 和 WeakMap：字典，一种新的集合类型，为 ECMAScript 语言带来了真正的键/值存储机制
1. Set 和 WeakSet：集合，一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。
1. 迭代器和生成器：迭代器是一种对象，可以通过 next() 方法按顺序返回值，而生成器是一种函数，可以使用 yield 关键字来定义迭代器。
1. for...in：用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。
1. for...of：用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。

#### Map 和 Object 的区别

1. Object 是 JavaScript 中的内置对象，用于存储键值对，键必须是字符串或符号。而 Map 是 ES6 新增的一种数据结构，也用于存储键值对，键可以是任意数据类型。
1. Map 具有更好的数据结构设计，能更高效地存储大量的键值对，并且提供了更多的方法用于操作键值对，比如 size 属性可以获取 Map 中键值对的数量。

#### Map 和 Set 的区别

1. Set 用于存储唯一值的集合，而 Map 用于存储键值对的映射关系。
1. Set 只存储值，没有键，而 Map 存储键值对。
1. Set 只有一个值，而 Map 可以将任何值用作键或值。

#### Map 和 WeakMap 的区别

1. Map 和 WeakMap 都是用于存储键值对的数据结构。
1. WeakMap 可以使用对象作为键，但是 Map 只能使用任何数据类型作为键。
1. WeakMap 中的键是弱引用，如果只有 WeakMap 对象中的键引用了某个对象，而该对象没有被其他对象引用，那么该对象会被垃圾回收机制回收。
1. WeakMap 没有 size 属性，也没有 clear() 方法，而且不能遍历其中的键或值。

#### Set 和 WeakSet 的区别

1. 对象引用类型：Set 存储的是对象的引用，WeakSet 存储的是对象的弱引用，因此 WeakSet 中的对象都是可被垃圾回收的，当对象被回收后，WeakSet 会自动删除对应的元素。
1. 值唯一性：Set 中的值必须是唯一的，重复的值会被自动过滤掉，而 WeakSet 中的值可以是重复的，因为它们是通过引用来判断是否相等的。
1. 迭代器：Set 是可迭代的，可以通过 for...of 循环来遍历集合中的每一个值，而 WeakSet 是不可迭代的，不能直接遍历 WeakSet 中的元素。
1. 方法：Set 和 WeakSet 有一些不同的方法，如 Set 中的 size 属性用于获取集合中的元素个数，而 WeakSet 中没有 size 属性；Set 中的 delete 方法可以删除集合中指定的元素，而 WeakSet 中没有 delete 方法，因为它的元素是可被自动删除的。

#### for 循环和 forEach 的区别

1. for 循环是 JavaScript 中最常用的循环语句，可以遍历数组和对象等集合数据类型。它的语法结构简单，可以通过控制循环变量来访问集合中的每一个元素。
1. forEach 是数组的一个内置方法，也用于遍历数组中的每一个元素。但是它的语法比较简洁，不需要控制循环变量，而是直接接收一个回调函数作为参数，该函数会被自动调用来处理每一个数组元素。因此，forEach 可以更加简洁和直观地遍历数组，也更适合处理一些数组操作，比如计算数组的总和或平均值等。

> for 循环比较常用，可控制性强，可以用于遍历集合、实现条件语句等多种场景；forEach 可以更加简洁地遍历数组，适用于一些数组操作

#### for...in 和 for...of 的区别

1. for...in 用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。但是，它并不保证属性的访问顺序，也可能访问到一些原型链中的属性。
1. for...of 用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。与 for...in 不同，for...of 遍历的是集合中的元素，而不是属性。

> for...in 适用于遍历对象属性，但是不保证属性访问顺序；for...of 适用于遍历集合中的元素，比如数组、Map、Set 等。

<!--
 * @Author: Shu Binqi
 * @Date: 2023-02-24 21:04:05
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-04 00:15:28
 * @Description: JavaScript 面试题汇总（120题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\JavaScript.md
-->

#### JavaScript 的数据类型有哪些？

JavaScript 共有 8 种数据类型，具体如下：

1. Number：数值类型，包括整数和浮点数。
1. String：字符串类型。
1. Boolean：布尔类型，只有两个值：true 和 false。
1. Null：表示空值或空对象指针。
1. Undefined：表示未定义或不存在的值。
1. Symbol：表示唯一的标识符，通常用于对象属性的键值。
1. BigInt：用于表示大整数，可以处理超出 Number 类型表示范围的整数。
1. Object：表示一个复杂数据类型，可以存储多个键值对。

其中，前 7 种数据类型为原始类型，都是不可变的，而 Object 则为引用类型，可以存储任意类型的数据。

（回答就 0 分的有：数组、函数、日期，这些是 类 class；不是类型 type）

#### 判断数据类型的方法有哪些？

① 判断多种数据类型

1. typeof：可以判断除 null 外的 ES5 基本数据类型
2. instanceof：可以正确判断对象的类型
3. construter：可以正确判断数据类型（如果创建一个对象并改变他的原型，就不能用 construter 判断类型了）
4. Object.prototype.toString.call()：可以正确判断对象的类型

需要注意的是，typeof null 的结果是 "object"，这是 JavaScript 语言本身的一个 bug，可以通过 typeof value === "object" && value === null 的方式来判断一个值是否为 null。

② 判定单个数据类型

1. Array.isArray()：判断是否是数组类型

③ 判断某个数据

1. isNaN：判断是否是一个非数字（会进行类型转换）
2. Number.isNaN：判断是否是一个非数字（首先判断是否是数字，再进行判断）
   ```
   console.log(isNaN('测试')) //true
   console.log(Number.isNaN('测试')) //false
   ```
3. isFinite() 用来判断被传入的参数值是否为一个有限数值（finite number），如果参数是 NaN，正无穷大或者负无穷大，会返回 false，其他返回 true。

#### typeof 判断不同类型时分别返回什么？

在 JavaScript 中，typeof 是一个操作符，用于返回操作数的数据类型，其返回值有以下几种：

1. **undefined**：表示未定义的值，通常是一个未声明的变量或函数中没有返回值。
1. **boolean**：表示布尔值 true 或 false。
1. **number**：表示数字类型，包括整数、浮点数和 NaN。
1. **string**：表示字符串类型，包括单引号、双引号和模板字符串。
1. **symbol**：表示 ES6 中新增的符号类型。
1. **object**：表示对象类型，包括 null、数组、函数、正则表达式等。
1. **function**：表示函数类型。

需要注意的是，typeof null 返回的是 "object"，这是 JavaScript 的历史遗留问题，被认为是一个语言设计上的失误。在 JavaScript 中，null 被视为一个特殊的对象值，但实际上它应该是一个原始值类型。因此，如果需要判断一个值是否为 null，建议使用严格相等运算符 === 来进行判断。

#### typeof null 的结果是什么，为什么？

typeof null 的结果是 "object"。这是因为在 JavaScript 的早期版本中，null 被错误地实现为对象类型，而实际上 null 是一个原始值。这个错误的实现在现代 JavaScript 中仍然存在，为了保持向后兼容性，typeof null 返回 "object"。

需要注意的是，null 和 undefined 是不同的类型，typeof undefined 的结果是 "undefined"。

#### null 和 undefined 的区别是什么？

null：空指针对象
undefined：未定义
相同点：都是基本数据类型
不同点：

1. 变量声明了但还没有定义的时候会返回 undefined；null 主要用于赋值给一些可能会返回对象的变量，作为初始化。
2. 使用 typeof 判断类型时 null 会返回 object；undefined 正确返回。（这是一个历史遗留的问题）

#### 如何获取安全的 undefined 值？

在 JavaScript 中，当访问一个不存在的变量时，会返回 undefined 值。但是在某些情况下，undefined 值可能被意外地赋值为其他值，例如：

```
let undefined = 123;
console.log(undefined); // 输出 123
```

为了避免这种情况，可以使用 void 操作符来获取安全的 undefined 值。void 操作符可以将任何表达式转换为 undefined 值，例如：

```
let a;
console.log(a); // 输出 undefined

let b = void 0;
console.log(b); // 输出 undefined

let c = void 'hello';
console.log(c); // 输出 undefined
```

因此，如果你需要获取安全的 undefined 值，可以使用 void 0 或 void 操作符。

#### 说说你对堆区和栈区的理解？

在计算机内存中，栈区和堆区是两个常用的内存分配区域。

栈区是用来存储函数的参数值、局部变量等在函数执行时需要分配的内存空间。它的特点是分配效率高，但空间较小，由系统自动分配和回收，具有后进先出（LIFO）的特点。

堆区是动态分配内存的区域，用来存储对象、数组等数据。它的特点是空间较大，但分配效率较低。由于需要手动分配和回收内存，所以容易产生内存泄漏等问题。

在 JavaScript 中，堆区用来存储对象、函数等复杂数据类型，栈区则主要用来存储基本数据类型和一些基本变量。在 JavaScript 中，每个对象都有一个原型对象，而原型对象又可以有自己的原型对象，形成原型链。在查找对象的属性时，会在原型链上依次查找，直到找到对应的属性或者查找到原型链的顶端，如果还没有找到则返回 undefined。

总的来说，栈区和堆区都是计算机内存中常用的内存分配区域，分别适用于不同的场景。在 JavaScript 中，原型和原型链则是实现继承和属性查找的重要机制。

#### isNaN 和 Number.isNaN 函数的区别？

isNaN 和 Number.isNaN 函数的主要区别在于它们对于参数的处理方式。

isNaN 函数会尝试将其参数转换为数值类型，如果参数无法被转换为数值类型，则返回 true。这意味着对于非数值类型的参数，isNaN 函数会先尝试将其转换为数值类型，然后再进行判断。例如：

```
isNaN('hello') // true
isNaN(undefined) // true
```

在这个例子中，isNaN 函数尝试将字符串 'hello' 和未定义的值 undefined 转换为数值类型，由于无法转换成功，它们会被判断为 NaN，因此返回 true。

相比之下，Number.isNaN 函数不会尝试将其参数转换为数值类型。如果参数不是 NaN 值，Number.isNaN 函数会直接返回 false。例如：

```
Number.isNaN('hello') // false
Number.isNaN(undefined) // false
```

因此，Number.isNaN 函数只有在参数是 NaN 值时才会返回 true。

总的来说，与 isNaN 函数相比，Number.isNaN 函数更加严格，因为它只会对参数进行类型检查，而不会尝试进行类型转换。

#### 判断数组类型有哪几种方法？

1. Array.isArray()：
   ```
   const arr = [1, 2, 3];
   console.log(Array.isArray(arr)); // true
   ```
2. Object.peototype.toString.call()：
   ```
   const arr = [1, 2, 3];
   console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
   ```
   需要注意的是，在某些情况下， instanceof 和 Array.isArray() 可能会出现错误的结果，特别是当变量跨框架或 Web Worker 时。因此，推荐使用 Object.prototype.toString.call() 来判断变量是否为数组。
3. instanceof：
   ```
   const arr = [1, 2, 3];
   console.log(arr instanceof Array); // true
   console.log(Array.isArray(arr)); // true
   ```
4. Array.isPrototypeOf()：

#### 有哪些方法会改变原数组？（至少 7 种）

JavaScript 中，有一些数组方法会直接修改原始数组，称为“就地方法”或“改变器方法”，这些方法包括：

1. **push()**：在数组末尾添加一个或多个元素。
1. **pop()**：删除并返回数组最后一个元素。
1. **shift()**：删除并返回数组的第一个元素。
1. **unshift()**：在数组开头添加一个或多个元素。
1. **splice()**：删除或替换数组的元素，可以在任何位置添加新元素。
1. **sort()**：对数组进行排序。
1. **reverse()**：将数组元素反转顺序。
1. **fill()**：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。
1. **copyWithin()**：在数组内部将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回修改后的数组。

这些方法会直接修改原始数组，不会创建新的数组。如果不想改变原始数组，可以使用“非就地方法”或“访问器方法”，如 slice()、concat()、filter()、map()、reduce()等。

#### 哪些方法不会改变原数组？（至少 7 种）

JavaScript 中有一些数组方法是不会改变原数组的，包括以下方法：

1. **concat()**: 连接两个或更多数组，并返回结果，原数组不会被修改。
1. **slice()**: 返回选定数组的元素，原数组不会被修改。
1. **join()**: 把数组的所有元素放入一个字符串，原数组不会被修改。
1. **toString()**: 把数组转换为字符串，并返回结果，原数组不会被修改。
1. **indexOf()**: 返回数组中某个元素第一次出现的位置，原数组不会被修改。
1. **lastIndexOf()**: 返回数组中某个元素最后一次出现的位置，原数组不会被修改。
1. **slice()**: 返回数组的一部分，原数组不会被修改。
1. **concat()**: 连接两个或更多数组，并返回结果，原数组不会被修改。
1. **includes()**: 判断一个数组是否包含某个值，原数组不会被修改。
1. **every()**: 检测数组中的所有元素是否满足指定条件，原数组不会被修改。
1. **some()**: 检测数组中的某些元素是否满足指定条件，原数组不会被修改。
1. **filter()**: 创建一个新数组，其中包含通过指定函数测试的所有元素，原数组不会被修改。
1. **map()**: 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后的返回值，原数组不会被修改。
1. **reduce()**: 将数组中的所有元素累加到一个值中，原数组不会被修改。
1. **reduceRight()**: 将数组中的所有元素累加到一个值中，原数组不会被修改。

需要注意的是，这些方法虽然不会改变原数组，但是有些方法会返回一个新的数组，需要将其赋值给一个新的变量使用。

#### 数组有哪些遍历方法？（至少 7 种）

JavaScript 数组有以下遍历方法：

for 循环：常规的 for 循环语句可以遍历数组元素，通过数组的 length 属性可以获取数组的长度。

```
const arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

forEach 方法：遍历数组元素，对每个元素执行回调函数。

```
const arr = [1, 2, 3, 4, 5];
arr.forEach(function(element) {
  console.log(element);
});
```

map 方法：遍历数组元素，对每个元素执行回调函数，将返回值存入新的数组中。

```
const arr = [1, 2, 3, 4, 5];
const newArr = arr.map(function(element) {
  return element * 2;
});
console.log(newArr); // [2, 4, 6, 8, 10]
```

filter 方法：遍历数组元素，对每个元素执行回调函数，根据返回值来过滤元素，将满足条件的元素存入新的数组中。

```
const arr = [1, 2, 3, 4, 5];
const newArr = arr.filter(function(element) {
  return element % 2 === 0;
});
console.log(newArr); // [2, 4]
```

reduce 方法：遍历数组元素，对每个元素执行回调函数，将计算结果累加到一个累加器中，返回累加器的最终结果。

```
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce(function(acc, cur) {
  return acc + cur;
}, 0);
console.log(sum); // 15
```

every 方法：遍历数组元素，对每个元素执行回调函数，当所有元素都满足条件时返回 true，否则返回 false。

```
const arr = [1, 2, 3, 4, 5];
const isAllEven = arr.every(function(element) {
  return element % 2 === 0;
});
console.log(isAllEven); // false
```

some 方法：遍历数组元素，对每个元素执行回调函数，当任意一个元素满足条件时返回 true，否则返回 false。

```
const arr = [1, 2, 3, 4, 5];
const hasEven = arr.some(function(element) {
  return element % 2 === 0;
});
console.log(hasEven); // true
```

for...of 循环：ES6 新增的语法，可以遍历数组元素。

```
const arr = [1, 2, 3, 4, 5];
for (const element of arr) {
  console.log(element);
}
```

#### 什么是事件冒泡？怎么阻止事件冒泡？

事件冒泡是指当一个元素上的事件被触发后，它会向父级元素一层层地逐级触发，直到触发到 document 对象为止。例如，当点击一个子元素时，如果该元素上绑定了事件处理程序，那么点击事件会先触发子元素上的事件处理程序，然后一级一级地向上传递，直到到达 document 对象。

阻止事件冒泡的方法有两种：

1. 使用 event.stopPropagation() 方法，该方法会阻止事件进一步冒泡。在事件处理程序中调用该方法，可以阻止事件向上层元素冒泡。
1. 使用 event.cancelBubble 属性，在 IE 中，该属性可以设置为 true，来阻止事件进一步冒泡。在其他浏览器中，该属性已经被废弃，需要使用 event.stopPropagation() 方法来代替。

#### 什么是事件捕获？如何阻止事件捕获？

事件捕获是指当一个元素触发了某个事件时，事件会从它的祖先元素一层层往下传递，直到到达目标元素并触发该事件。事件捕获的顺序与事件冒泡相反，即从外到内。

在事件捕获的过程中，可以通过调用 Event 对象的 stopPropagation() 方法来阻止事件的继续传递。该方法会停止事件的捕获和冒泡过程，并防止任何父元素或子元素受到影响。

具体来说，stopPropagation() 方法应该在事件处理程序中调用，例如：

```
document.addEventListener('click', function(event) {
  event.stopPropagation();
  // 事件处理逻辑
}, true);
```

在上述代码中，addEventListener() 方法的第三个参数为 true，表示事件使用捕获阶段进行处理。event.stopPropagation() 方法会阻止事件的继续传递，避免影响其他元素。

需要注意的是，虽然 stopPropagation() 方法可以阻止事件的继续传递，但它并不能阻止事件处理程序本身的执行。如果需要完全禁用事件处理程序的执行，可以使用 preventDefault() 方法，它可以阻止事件的默认行为，例如阻止链接的跳转或表单的提交。

#### 什么是事件委托？

事件委托（Event Delegation）是一种常用的优化前端性能的技术，它是利用事件冒泡的特性，将事件处理器绑定到它们的共同祖先节点上，从而减少绑定事件处理器的数量，提高页面的响应速度。
通过事件委托，我们可以将事件处理器绑定到共同祖先元素上，而不是将事件处理器绑定到每个子元素上。这样，当事件触发时，事件会一直冒泡到祖先元素，并在祖先元素上触发相应的事件处理器。这样就可以利用事件冒泡的机制，实现子元素和父元素之间的事件传递。
使用事件委托的好处有：

1. 减少绑定事件的数量，提高性能。
2. 动态添加的元素也可以自动绑定事件，不需要再手动绑定。
3. 可以避免因为动态添加的元素没有绑定事件而导致的事件失效的问题。

事件委托的应用场景包括：

1. 列表元素的点击事件，通过事件委托在列表的父元素上绑定点击事件，而不是在每个列表元素上绑定点击事件。
2. 表单元素的提交事件，通过事件委托在表单的父元素上绑定提交事件，而不是在每个表单元素上绑定提交事件。
3. 动态添加的元素的事件绑定，通过事件委托在它们的共同祖先元素上绑定事件处理器，而不需要在动态添加的元素上手动绑定事件处理器。

#### ES6 有哪些新语法？

ES6（ECMAScript 2015）引入了许多新的语法和特性，其中一些主要的包括：

1. **块级作用域**：使用 let 和 const 声明变量时可以创建块级作用域。
1. **箭头函数**：使用 => 语法定义匿名函数。
1. **解构赋值**：可以从数组和对象中提取值并将其赋给变量。
1. **模板字符串**：使用反引号 `` 来创建多行字符串，并且可以在字符串中插入表达式。
1. **默认参数**：定义函数参数的默认值。
1. **展开运算符**：使用 ... 语法来展开数组或对象。
1. **类和继承**：使用 class 和 extends 关键字来定义类和继承。
1. **模块化**：使用 import 和 export 关键字来导入和导出模块。
1. **Promise**：处理异步操作的一种方法，可以通过链式调用来组合多个异步操作。
1. **Symbol**：引入了一种新的原始数据类型，用于创建唯一的标识符。
1. **Map 和 WeakMap**：字典，一种新的集合类型，为 ECMAScript 语言带来了真正的键/值存储机制
1. **Set 和 WeakSet**：集合，一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。
1. **迭代器和生成器**：迭代器是一种对象，可以通过 next() 方法按顺序返回值，而生成器是一种函数，可以使用 yield 关键字来定义迭代器。
1. **for...in**：用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。
1. **for...of**：用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。

#### Map 和 Object 的区别？

1. Object 是 JavaScript 中的内置对象，用于存储键值对，键必须是字符串或符号。而 Map 是 ES6 新增的一种数据结构，也用于存储键值对，键可以是任意数据类型。
1. Map 具有更好的数据结构设计，能更高效地存储大量的键值对，并且提供了更多的方法用于操作键值对，比如 size 属性可以获取 Map 中键值对的数量。

#### Map 和 Set 的区别？

1. Set 用于存储唯一值的集合，而 Map 用于存储键值对的映射关系。
1. Set 只存储值，没有键，而 Map 存储键值对。
1. Set 只有一个值，而 Map 可以将任何值用作键或值。

#### Map 和 WeakMap 的区别？

1. Map 和 WeakMap 都是用于存储键值对的数据结构。
1. WeakMap 只能使用对象作为键，但是 Map 可以使用任何数据类型作为键。
1. WeakMap 中的键是弱引用，如果只有 WeakMap 对象中的键引用了某个对象，而该对象没有被其他对象引用，那么该对象会被垃圾回收机制回收。
1. WeakMap 没有 size 属性，也没有 clear() 方法，而且不能遍历其中的键或值。

#### Set 和 WeakSet 的区别？

1. 对象引用类型：Set 存储的是对象的引用，WeakSet 存储的是对象的弱引用，因此 WeakSet 中的对象都是可被垃圾回收的，当对象被回收后，WeakSet 会自动删除对应的元素。
1. 值唯一性：Set 中的值必须是唯一的，重复的值会被自动过滤掉，而 WeakSet 中的值可以是重复的，因为它们是通过引用来判断是否相等的。
1. 迭代器：Set 是可迭代的，可以通过 for...of 循环来遍历集合中的每一个值，而 WeakSet 是不可迭代的，不能直接遍历 WeakSet 中的元素。
1. 方法：Set 和 WeakSet 有一些不同的方法，如 Set 中的 size 属性用于获取集合中的元素个数，而 WeakSet 中没有 size 属性；Set 中的 delete 方法可以删除集合中指定的元素，而 WeakSet 中没有 delete 方法，因为它的元素是可被自动删除的。

#### for 循环和 forEach 的区别？

1. for 循环是 JavaScript 中最常用的循环语句，可以遍历数组和对象等集合数据类型。它的语法结构简单，可以通过控制循环变量来访问集合中的每一个元素。
1. forEach 是数组的一个内置方法，也用于遍历数组中的每一个元素。但是它的语法比较简洁，不需要控制循环变量，而是直接接收一个回调函数作为参数，该函数会被自动调用来处理每一个数组元素。因此，forEach 可以更加简洁和直观地遍历数组，也更适合处理一些数组操作，比如计算数组的总和或平均值等。

> for 循环比较常用，可控制性强，可以用于遍历集合、实现条件语句等多种场景；forEach 可以更加简洁地遍历数组，适用于一些数组操作

#### for...in 和 for...of 的区别？

1. for...in 用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。但是，它并不保证属性的访问顺序，也可能访问到一些原型链中的属性。
1. for...of 用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。与 for...in 不同，for...of 遍历的是集合中的元素，而不是属性。

> for...in 适用于遍历对象属性，但是不保证属性访问顺序；for...of 适用于遍历集合中的元素，比如数组、Map、Set 等。

#### 讲一下闭包？闭包的优缺点？闭包的使用场景？（建议写博客）

闭包是指在函数内部创建了一个函数，并且这个函数可以访问到外部函数的局部变量和参数，即使外部函数已经返回，内部函数仍然可以访问和操作这些变量和参数。闭包是 JavaScript 中一个非常重要的概念，它可以用来实现模块化、保存私有变量等。

闭包的优点：

1. 实现函数内部的私有变量，避免全局变量的污染。
1. 可以实现数据的封装和隐藏，确保数据的安全性。
1. 使函数内部的变量长期保存在内存中，方便以后的调用。

闭包的缺点：

1. 过度使用闭包可能会导致内存泄漏，因为闭包会使得函数中的变量被长期占用，无法被垃圾回收器回收。
1. 可能会导致性能问题，因为闭包中涉及到了变量的查找，会比普通的函数调用消耗更多的时间和内存。
1. 对于不慎使用闭包的开发者来说，可能会出现变量覆盖等问题。

闭包的使用场景包括但不限于以下几个方面：

1. **模块化开发**：通过闭包来实现模块化开发，将模块中需要暴露的接口通过返回函数的形式暴露出去，同时保护模块中的私有变量。
1. **私有变量**：闭包可以用来实现 JavaScript 中的私有变量，将需要保护的变量封装在一个函数内部，通过返回一个访问该变量的函数，从而控制对变量的访问和修改。
1. **延迟执行**：利用闭包来延迟函数的执行，在函数外部创建一个闭包，然后将需要延迟执行的函数作为参数传入，从而实现延迟执行的效果。
1. **计数器**：闭包可以用来实现一个简单的计数器，每次调用计数器函数都会返回一个新的计数值。
1. **缓存**：利用闭包来实现缓存机制，将需要缓存的数据存储在闭包中，从而提高访问速度。
1. **回调函数**：利用闭包来实现回调函数，将回调函数作为参数传入，从而实现函数之间的协作。

需要注意的是，闭包会占用内存，并且可能会导致内存泄漏，因此在使用闭包时需要注意内存管理。

#### 闭包的执行过程？

闭包是指有权访问另一个函数作用域中变量的函数，即使外部函数已经执行结束，内部函数依然可以访问外部函数的作用域。

当一个函数被调用时，都会创建一个执行环境，包含函数的参数、局部变量、this 等。在执行环境中，会创建一个变量对象（VO），用于存储变量和函数声明，并将其放入作用域链中。

当函数执行完毕时，其执行环境会被销毁，但是其作用域链中的变量对象依然存在，因为闭包函数依然引用了该变量对象，所以该变量对象不能被销毁，直到闭包函数被销毁时才会一起销毁。

下面是一个简单的闭包例子：

```
function outer() {
  var count = 0;
  return function inner() {
    count++;
    console.log(count);
  }
}

var counter = outer();
counter(); // 输出1
counter(); // 输出2
counter(); // 输出3
```

在上面的例子中，调用 outer 函数返回一个内部函数 inner，该内部函数引用了 outer 函数中的变量 count。当执行完 outer 函数后，其执行环境被销毁，但是变量 count 依然存在，因为内部函数 inner 引用了它。所以每次调用 counter 函数时，count 都会累加并输出。

这就是闭包的执行过程：当函数执行完毕后，其执行环境会被销毁，但是变量对象依然存在于作用域链中，直到闭包函数被销毁时才会一起销毁。

#### 讲一下原型、原型链？

在 JavaScript 中，每个对象都有一个内部属性 \[[Prototype]]，通常称为“原型”，它引用另一个对象。这个被引用的对象也可以有自己的原型，并且可能还有自己的原型，这样形成了一个“原型链”。

当我们访问一个对象的属性或方法时，JavaScript 引擎会先在对象自身中查找是否存在该属性或方法，如果没有找到，则会到对象的原型中查找，如果还没找到，会继续在原型的原型中查找，直到找到该属性或者找到原型链的末尾为止。

JavaScript 中，函数对象具有 prototype 属性，而普通对象没有。当我们创建一个函数时，该函数的 prototype 属性指向一个新的对象。这个对象被称为该函数的原型对象。

使用构造函数创建对象时，通过 new 关键字创建的对象会自动继承构造函数的 prototype 属性所指向的原型对象，形成了一个“原型链”。

通过原型链，我们可以实现对象的属性和方法的继承。如果我们尝试访问一个对象的属性或方法，而该对象本身并没有定义该属性或方法，JavaScript 引擎就会在该对象的原型对象中查找，一直到找到为止。

需要注意的是，原型链的层次越深，访问属性的速度就会越慢，因此应该尽量保持原型链的简洁。另外，由于 JavaScript 中对象是动态的，因此在运行时可以随时修改对象的原型，这也是 JavaScript 中比较灵活的特性之一。

#### 原型链的终点是什么？如何打印出原型链的终点？

在 JavaScript 中，原型链的终点是 null，因为 Object.prototype 是所有对象的基类，而 null 不是对象。因此，当一个对象的原型链上一直查找到 Object.prototype 后，再继续查找其原型链，就会返回 null。

要打印出对象的原型链的终点，可以使用以下方法：

1. 使用 while 循环和 Object.getPrototypeOf() 方法。从当前对象开始，每次通过 Object.getPrototypeOf() 获取其原型，直到获取到 null。代码示例如下：

```
let obj = {};
while (obj !== null) {
  console.log(obj);
  obj = Object.getPrototypeOf(obj);
}
```

2. 使用递归函数，每次调用函数时传入当前对象的原型，直到传入的原型为 null。代码示例如下：

```
function printPrototypeChain(obj) {
  console.log(obj);
  const proto = Object.getPrototypeOf(obj);
  if (proto !== null) {
    printPrototypeChain(proto);
  }
}
printPrototypeChain({});
```

无论是使用 while 循环还是递归函数，都会从对象本身开始打印出原型链上的所有对象，直到终点 null。

如果一个对象没有原型，那么 Object.getPrototypeOf(obj) 返回的就是 null。所以循环应该在遍历到 null 之前结束。

#### == 和 === 的区别？

== 和 === 都是比较运算符，主要用于比较两个值的相等性。它们的区别在于以下几点：

- == 运算符会在比较之前进行类型转换，而 === 运算符不会进行类型转换，只有在两个值类型相同的情况下才会返回 true。
- == 运算符在比较时，如果两个值类型不同，会将其中一个值转换为另一个值的类型，然后再比较它们的值。例如，如果比较一个字符串和一个数字，== 运算符会将字符串转换为数字，然后再比较它们的值。而 === 运算符不会进行类型转换，因此如果比较一个字符串和一个数字，它们的类型不同，会直接返回 false。
- === 运算符比 == 运算符更严格，因为它不会进行类型转换，所以在比较时需要注意两个值的类型是否相同。如果类型不同，=== 运算符会直接返回 false。

举个例子：

```
let x = 1;
let y = "1";
console.log(x == y);  // true，因为 "1" 被转换成了数字 1
console.log(x === y); // false，因为类型不同
```

#### `Object.is()` 与比较操作符 “`===`”、“`==`” 的区别？

在 JavaScript 中，Object.is() 方法和比较操作符 === 和 == 都可以用于比较两个值是否相等，但它们之间有一些细微的差别：

=== 和 == 的比较规则是基于相等性运算符（`==`）和严格相等性运算符（`===`）的算法规则。=== 会先判断类型是否相同，再判断值是否相等。== 则会对操作数进行类型转换，再进行比较。因此，=== 是严格相等，要求类型和值都相等，而 == 则允许类型转换后值相等即可。

Object.is() 比较规则不同于 === 和 ==，它认为以下情况是相等的：

1. 两个值都是 undefined
1. 两个值都是 null
1. 两个值都是 true 或都是 false
1. 两个值引用同一个对象
1. 两个值都是数字且具有相同的值，但是区分 +0 和 -0，以及 NaN 和 NaN。

因此，使用 Object.is() 可以更准确地比较两个值是否相等。

#### 什么是 JavaScript 中的包装类型？

JavaScript 中的包装类型是指基本数据类型（如字符串、数字和布尔值）对应的对象类型。当对基本类型的值进行属性和方法的访问时，JavaScript 会自动将基本类型转换为对应的包装类型，执行完操作后再将其转换回基本类型。

举个例子，当我们对字符串 'hello' 调用其 toUpperCase() 方法时，实际上 JavaScript 隐式地将字符串转换为 String 类型的对象，调用对象上的方法，然后再将其转换回字符串类型。

```
let str = 'hello';
console.log(str.toUpperCase()); // 'HELLO'
```

这里的 str 是基本数据类型的字符串，但在调用 toUpperCase() 方法时，JavaScript 自动将其转换为 String 对象类型，因为 toUpperCase() 方法只存在于 String 对象的原型链中。

包装类型的存在是为了在需要使用对象时方便地操作基本数据类型。然而，由于基本数据类型和包装类型之间的自动转换，有时会导致一些意外的问题和性能问题。

#### 为什么 0.1+0.2 ! == 0.3，如何让其相等（精度丢失）

在 JavaScript 中，0.1+0.2 不等于 0.3 是由于浮点数在计算机中的存储方式导致的。由于计算机使用二进制进行存储和计算，无法精确地表示某些十进制数，比如 0.1 和 0.2，所以在计算时会出现精度误差。

要让 0.1+0.2 等于 0.3，一种方法是使用 toFixed() 方法，另一种是将浮点数转换成整数进行计算。例如：

```
const result = (0.1 * 10 + 0.2 * 10) / 10;
console.log(result); // 0.3
```

另外，也可以使用第三方库如 decimal.js、big.js 等来解决浮点数计算精度问题。

#### 执行上下文的类型？执行上下文栈是什么？

执行上下文是 JavaScript 中非常重要的概念之一，它定义了函数在执行过程中的环境。执行上下文可以理解为一个对象，包含了当前执行函数的所有变量、函数、参数等信息。

JavaScript 中有三种执行上下文类型：

1. **全局执行上下文**：在脚本文件中执行的代码会被包含在全局执行上下文中。
1. **函数执行上下文**：每次调用函数都会创建一个新的函数执行上下文。
1. **Eval 函数执行上下文**：在 eval 函数中执行的代码会被包含在 Eval 函数执行上下文中。

执行上下文栈是 JavaScript 中的一个栈结构，它用于存储当前代码执行的所有执行上下文。当 JavaScript 引擎遇到一个函数调用时，会将该函数的执行上下文添加到执行上下文栈的顶部。当函数执行结束时，执行上下文会从栈中弹出，控制权交回上一个执行上下文。

在 JavaScript 中，执行上下文栈的运作机制可以解释函数调用和返回的原理，也能帮助我们更好地理解作用域链、闭包等概念。

#### 执行上下文的三个阶段？

执行上下文可以分为以下三个阶段：

1. **创建阶段（Creation Phase）**：创建阶段是执行上下文的第一个阶段，会在代码执行前进行。在这个阶段，JavaScript 引擎会创建变量对象（Variable Object），建立作用域链（Scope Chain）和确定 this 的指向。其中变量对象包括函数声明、函数的形参和变量声明等。
1. **执行阶段（Execution Phase）**：执行阶段是执行上下文的第二个阶段，会在创建阶段后执行。在这个阶段，JavaScript 引擎会按照顺序执行代码，并根据代码操作变量对象、作用域链和 this 对象等。
1. **销毁阶段（Termination Phase）**：当代码执行完成后，JavaScript 引擎会销毁当前执行上下文。在这个阶段，会释放当前执行上下文所占用的内存空间，并将上下文从执行上下文栈中弹出。

以上三个阶段构成了执行上下文的完整生命周期。

#### 讲一下作用域？什么是作用域链？

作用域（Scope）指的是变量或函数的可访问范围，JavaScript 中有全局作用域和函数作用域两种类型的作用域。

1. **全局作用域**：指的是在函数外部声明的变量和函数，它们可以被代码中的任何地方访问到。
1. **函数作用域**：指的是在函数内部声明的变量和函数，它们只能在函数内部访问到，外部无法访问。
1. **块级作用域**：指的是使用花括号 {} 包围起来的代码块，例如 if 语句、for 循环、函数等。

作用域链（Scope Chain）指的是当 JavaScript 引擎在查找变量的值时，从当前作用域开始查找，如果在当前作用域中找不到该变量，则会一层层向上查找，直到找到该变量或查找到全局作用域为止。

当 JavaScript 引擎在执行函数时，会创建一个执行上下文（Execution Context），每个执行上下文都有一个与之对应的作用域链。在创建执行上下文时，JavaScript 引擎会将当前作用域链保存在执行上下文的内部属性中，当查找变量时，JavaScript 引擎会先查找当前执行上下文的变量，如果找不到则会向上查找作用域链中的上一级执行上下文，直到找到为止。

作用域链的顶端是全局执行上下文，作用域链的底端是当前函数执行上下文，函数执行上下文中的变量和函数可以通过作用域链访问到全局作用域中的变量和函数，但全局作用域中的变量和函数无法通过作用域链访问到函数执行上下文中的变量和函数。

#### 如何延长作用域链？

在 JavaScript 中，作用域链的长度取决于函数定义的位置和嵌套关系。作用域链由当前执行上下文的变量对象（包括该函数的参数、内部变量和函数）和其外部环境的变量对象（如全局环境变量对象）组成。作用域链的主要作用是用于查找变量和函数的值。

在函数内部通过 with 语句或者 eval() 函数创建新的变量对象时，也会延长作用域链。使用 with 语句时，将指定对象添加到作用域链的前端。使用 eval() 函数时，将传入的字符串解析为 JavaScript 代码并将其执行，并将其变量和函数定义添加到当前作用域链的前端。

需要注意的是，with 语句和 eval() 函数会降低代码的可读性和可维护性，同时也可能引发安全问题，应该尽量避免使用。

#### 作用域链应用场景有哪些？

作用域链是 JavaScript 中非常重要的概念，它决定了变量和函数在代码中的可见性和可访问性。下面介绍一些作用域链应用场景：

1. **实现闭包**：在 JavaScript 中，函数内部可以访问外部函数的变量和函数，这就是闭包。闭包的实现依赖于作用域链，即内部函数可以访问外部函数的变量是因为内部函数的作用域链包含了外部函数的作用域链。
1. **模块化开发**：作用域链可以用来实现模块化开发，即将代码拆分成多个模块，每个模块都有自己的作用域，不同模块之间的变量和函数不会互相干扰。这可以通过立即执行函数表达式（IIFE）等方式实现。
1. **变量查找**：作用域链可以决定变量的查找顺序。当需要查找某个变量时，JavaScript 引擎会沿着作用域链依次查找变量，直到找到该变量或者到达全局作用域。这个过程是自动进行的，我们不需要显式地指定变量的查找路径。
1. **作用域隔离**：作用域链可以实现作用域隔离，即在不同的作用域中定义同名变量不会相互影响。这可以有效地避免变量名冲突的问题。

总之，作用域链是 JavaScript 中非常重要的概念，可以用来实现许多复杂的功能，也是理解 JavaScript 闭包和模块化开发的基础。

#### 变量提升与函数提升的区别？

变量提升和函数提升都是 JavaScript 中的预解析机制。它们的区别在于变量提升只会将声明提升至作用域的顶部，而不会将赋值也提升至作用域的顶部，而函数提升则会将整个函数声明提升至作用域的顶部。

具体来说，变量提升会将变量声明提升至作用域的顶部，但是不会将变量的赋值也提升。例如：

```
console.log(a);  // undefined
var a = 1;
```

上述代码中，变量 a 在 console.log 语句之前被声明了，但是由于变量提升只将声明提升至作用域的顶部，所以此时 a 的值为 undefined。

而函数提升会将整个函数声明提升至作用域的顶部，包括函数名和函数体。例如：

```
foo();  // "Hello, world!"
function foo() {
  console.log("Hello, world!");
}
```

上述代码中，函数 foo 的声明被提升至作用域的顶部，因此在函数调用之前就已经可以访问到它。

需要注意的是，使用 let 和 const 声明的变量不会存在变量提升，因此不能在声明之前使用这些变量。同时，使用 const 声明的常量必须在声明时就赋值，否则会报错。

### var、let 和 const 的区别？

在 ES6 中，引入了 let 和 const 关键字，可以用来定义块级作用域的变量，也就是只在当前代码块内有效，出了代码块就无法访问。与之不同的是，使用 var 关键字定义的变量是函数作用域的，如果在函数内部使用 var 定义的变量，那么这个变量在整个函数内部都是可访问的。

总结一下 var、let、const 的区别：

1. var 定义的变量是函数作用域的，而 let 和 const 定义的变量是块级作用域的。
1. var 定义的变量可以被重新赋值和重新声明，而 let 定义的变量可以被重新赋值但不能被重新声明，const 定义的变量既不能被重新赋值也不能被重新声明。
1. 在全局作用域下使用 let 和 const 定义变量时不会将其挂在全局对象下，而 var 定义的变量会。

需要注意的是，由于 JavaScript 中存在变量提升的机制，在使用 var 声明变量时，变量会被提升到函数作用域的顶部，因此在变量声明之前访问该变量不会报错，但是其值为 undefined。而使用 let 和 const 声明变量时，则不存在变量提升的情况，访问未声明的变量会直接报错。

#### 说说 JS 中的预解析？

JavaScript 中的预解析（Hoisting）是指在代码执行之前，JavaScript 引擎会先扫描整个代码，将所有的变量声明和函数声明提前到当前作用域的顶部，这个过程就称为预解析。

在预解析过程中，变量声明会被提前到作用域顶部，但是变量的赋值不会被提前。函数声明会被整个提前，包括函数体内的代码。而函数表达式只会被提前函数名，不会被提前函数体内的代码。

例如：

```
console.log(a); // undefined
var a = 1;

console.log(b); // Uncaught ReferenceError: b is not defined
let b = 2;

foo(); // "hello"
function foo() {
  console.log("hello");
}

bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log("world");
};
```

在上面的代码中，变量 a 被预解析并被赋予了默认值 undefined，所以第一次 console.log 输出 undefined，而变量 b 是用 let 声明的，它不存在变量提升，所以在声明之前访问会报错。

函数 foo() 是函数声明，因此整个函数会被提前，所以在函数声明之前调用函数不会报错。而变量 bar 是一个函数表达式，只有函数名被提前，函数体内的代码不会被提前，所以在声明之前调用会报错。

因此，了解 JavaScript 中的预解析对于理解变量作用域和函数作用域都是非常重要的。

#### 讲一下异步编程？异步编程的实现方式？

异步编程是指在代码执行过程中可以同时处理多个任务，而不必等待前一个任务结束才能执行下一个任务的编程方式。在 JavaScript 中，异步编程可以通过回调函数、Promise 和 async/await 等方式来实现。

1. 回调函数

回调函数是一种最简单的异步编程方式。它通过在函数调用时传递一个回调函数来实现异步操作。当异步操作完成后，回调函数会被调用。

例如，读取文件是一个异步操作，可以通过 Node.js 的 fs 模块的 readFile 方法来实现：

```
const fs = require('fs');

fs.readFile('file.txt', 'utf8', function(err, data) {
  if (err) throw err;
  console.log(data);
});
```

2. Promise

Promise 是一种更加先进的异步编程方式，它可以解决回调函数存在的一些问题，例如回调地狱和错误处理。

Promise 有三个状态：pending（等待状态）、fulfilled（已完成状态）和 rejected（已失败状态）。当异步操作完成时，Promise 会从等待状态转变为已完成状态或已失败状态。

Promise 提供了 then 和 catch 方法来处理异步操作的结果。then 方法用于处理已完成状态的结果，catch 方法用于处理已失败状态的结果。

例如，可以通过 Promise 实现读取文件：

```
const fs = require('fs/promises');

fs.readFile('file.txt', 'utf8')
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

3. async/await

async/await 是一种基于 Promise 的异步编程方式，它可以让异步代码看起来像同步代码，提高了代码的可读性和可维护性。

async/await 在函数前加上 async 关键字，使函数返回一个 Promise。在函数内部，使用 await 关键字来等待异步操作的完成，然后使用 try/catch 来捕获错误。

例如，可以通过 async/await 实现读取文件：

```
const fs = require('fs/promises');

async function readFile() {
  try {
    const data = await fs.readFile('file.txt', 'utf8');
    console.log(data);
  } catch (err) {
    console.error(err);
  }
}

readFile();
```

异步编程的实现方式多种多样，不同的场景适合不同的实现方式。需要根据实际情况选择合适的方式。

#### 并发与并行的区别？同步任务和异步任务的区别？

并发与并行

1. 并发（concurrency）指的是在一段时间内，多个任务同时在执行，但是不一定是在同一时刻在执行，可能是交替执行，因此对于用户来说是同时在执行。
1. 并行（parallelism）指的是在同一时刻多个任务在同时执行，因此对于用户来说是真正意义上的同时执行。

同步任务和异步任务

1. 同步任务（synchronous task）指的是在主线程上排队执行的任务，只有当前面的任务执行完毕，后面的任务才能执行。同步任务是阻塞式的，只有等待前面的任务执行完毕，才能执行下一个任务。
1. 异步任务（asynchronous task）指的是不在主线程上排队执行的任务，而是在任务完成后将结果通知到任务队列中，等待主线程空闲后再来执行。异步任务是非阻塞式的，可以在任务执行的同时执行其他的任务。常见的异步任务包括定时器、事件监听、Ajax 请求等。

#### setTimeout、setInterval、requestAnimationFrame 的区别？

setTimeout、setInterval 和 requestAnimationFrame 都是 JavaScript 中常见的定时器 API，但它们的使用场景和工作原理有所不同。

1. **setTimeout**：setTimeout 函数是在指定的时间间隔后执行一次回调函数。它可以用于实现延迟执行某个任务或定时触发某个事件。
1. **setInterval**：setInterval 函数是在指定的时间间隔内重复执行一个回调函数。它可以用于实现周期性执行某个任务或定时轮询某个事件。
1. **requestAnimationFrame**：requestAnimationFrame 是浏览器提供的一个 API，它的作用是在下一次浏览器重绘之前执行指定的回调函数。requestAnimationFrame 可以实现平滑的动画效果，避免了由于帧率过低导致的卡顿和画面撕裂等问题。

区别如下：

1. setTimeout 和 setInterval 在执行回调函数时，不考虑浏览器是否正在执行其他任务，因此可能会因为浏览器执行任务过多而出现卡顿、延迟等问题，而 requestAnimationFrame 会在浏览器空闲时执行回调函数，因此能够更好地保证性能和用户体验。
1. setTimeout 和 setInterval 可以自由控制执行时间间隔，而 requestAnimationFrame 则是根据浏览器的刷新率自动调整回调函数的执行时间。
1. 在不同的场景下，这三个 API 的使用方式也有所不同。setTimeout 和 setInterval 适用于周期性执行某个任务或延迟执行某个任务的场景，而 requestAnimationFrame 则适用于实现平滑的动画效果。

#### setTimeout、Promise、async/await 的区别？

setTimeout、Promise、async/await 都是 JavaScript 中用于处理异步编程的机制，它们之间有以下的区别：

1. **setTimeout**：setTimeout 是一种在指定时间后执行一次的异步调用方法，它将回调函数加入到任务队列中，等待执行。setTimeout 可以用于实现定时器和一些简单的异步操作。
1. **Promise**：Promise 是一种可以表示异步操作的对象，它可以让我们更方便地进行异步编程。Promise 对象表示一个异步操作的最终完成或失败，并返回一个结果值或错误。Promise 有三种状态，分别为 Pending、Resolved 和 Rejected。在异步操作成功时，会调用 resolve 函数，将 Promise 对象的状态设置为 Resolved，否则调用 reject 函数，将 Promise 对象的状态设置为 Rejected。Promise 可以通过 then 和 catch 方法进行链式调用。
1. **async/await**：async/await 是一种使用 Promise 进行异步编程的语法糖，它可以让异步代码看起来像同步代码一样易于理解和编写。async/await 在语言层面提供了异步编程的支持，它使得异步代码的执行顺序更加明确，避免了回调函数嵌套带来的问题。async/await 是基于 Promise 实现的，async 函数返回一个 Promise 对象，可以通过 await 关键字等待异步操作的完成，并获取异步操作的结果。

#### 说说你对 this 的理解？如何判断 this 的指向？

在 JavaScript 中，this 是一个关键字，用来指向当前函数的上下文对象。this 的指向会根据函数的调用方式而变化。

通常情况下，this 的指向可以通过函数的调用方式来判断。以下是常见的几种情况：

1. **默认绑定**：当函数直接调用时，this 指向全局对象（非严格模式）或 undefined（严格模式）。
1. **隐式绑定**：当函数作为对象的方法调用时，this 指向该对象。
1. **显示绑定**：当使用 call、apply 或 bind 方法时，可以显式指定函数的 this 指向。
1. **new 绑定**：当使用 new 关键字调用构造函数时，this 指向新创建的对象。

在判断 this 的指向时，可以先排除掉默认绑定的情况，再根据函数的调用方式来确定 this 的指向。

需要注意的是，在箭头函数中，this 的指向是在定义时确定的，指向外层函数的 this，而不是在调用时确定的。

此外，还有一些特殊情况，例如使用 bind 方法绑定 this 后返回一个新的函数时，新函数中的 this 仍然指向原来的对象，而不是 bind 方法中指定的对象。

综上所述，判断 this 的指向需要结合具体的场景来分析。通常可以先排除掉默认绑定的情况，再根据函数的调用方式来确定 this 的指向。如果还存在不确定的情况，可以使用一些工具或方法来辅助判断，例如调试工具、箭头函数等。

#### 有哪些方法可以改变 this 指向？call、apply 和 bind 的区别？

在 JavaScript 中，有几种方法可以改变函数的 this 指向，包括 call()、apply()、bind() 和 使用变量保存 this 四种方式。

call() 和 apply() 可以将函数中的 this 指向指定的对象，并立即执行函数。两者的区别在于参数传递的方式不同，call() 采用逐个传递参数，而 apply() 则通过数组的形式传递参数。

bind() 方法也可以改变函数的 this 指向，但与 call() 和 apply() 不同的是，它不会立即执行函数，而是返回一个新的函数，需要调用返回的函数才能执行原来的函数。

箭头函数在定义时会捕获当前上下文的 this 值，并且该值在函数生命周期内不会发生变化。这意味着在箭头函数中无法通过 call()、apply() 或 bind() 方法来改变函数的 this 指向。

使用对象方法调用函数时，函数的 this 指向该对象。

要判断函数中的 this 指向，可以根据函数的调用方式和定义方式来确定。如果函数是作为对象的方法调用，则 this 指向该对象；如果是作为普通函数调用，则 this 指向全局对象；如果使用 call()、apply() 或 bind() 方法改变函数的 this 指向，则 this 指向指定的对象；如果使用箭头函数定义函数，则 this 指向定义时的上下文。

####

在 JavaScript 中，使用 new 关键字创建一个对象时，发生了以下步骤：

1. 创建一个新的空对象。
1. 将该对象的原型指向构造函数的 prototype 属性。
1. 使用指定的参数列表调用函数，并将 this 绑定到新创建的对象上。
1. 如果构造函数没有返回任何对象，则返回新创建的对象；否则，返回构造函数返回的对象。

举个例子，假设有以下构造函数：

```
function Person(name, age) {
  this.name = name;
  this.age = age;
}
```

使用 new 关键字创建一个 Person 实例的过程如下：

```
const person = new Person('John', 30);
```

1. 创建一个空对象 {}。
1. 将该对象的原型指向 Person.prototype。
1. 调用 Person 函数，并将 this 绑定到新创建的对象上，即执行 this.name = 'John'; this.age = 30;。
1. 返回新创建的对象 { name: 'John', age: 30 }。

在这个过程中，Person 函数就充当了一个类的角色，而通过 new 关键字创建的对象就是该类的一个实例。

#### 怎么判断一个对象是否是空对象？

可以使用 Object.keys() 或 Object.getOwnPropertyNames() 方法来判断一个对象是否是空对象，这两个方法都可以获取对象自身属性的属性名，如果返回的数组长度为 0，则说明对象没有自身属性，即为空对象。

例如：

```
const obj1 = {};
const obj2 = { foo: 'bar' };

console.log(Object.keys(obj1).length === 0); // true
console.log(Object.keys(obj2).length === 0); // false
console.log(Object.getOwnPropertyNames(obj1).length === 0); // true
console.log(Object.getOwnPropertyNames(obj2).length === 0); // false
```

上面的代码中，obj1 是空对象，obj2 不是空对象。可以使用 Object.keys() 或 Object.getOwnPropertyNames() 方法判断它们是否为空对象。

#### 说说你对 JSON 的理解？

JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它基于 JavaScript 语法的子集，具有易于理解和编写、易于解析和生成、易于扩展和使用等优点。JSON 可以表示简单的值，例如字符串和数字，还可以表示复杂的结构，例如对象和数组。

JSON 的语法和 JavaScript 对象的语法非常相似，由于 JavaScript 的普及，JSON 已经成为了很多应用程序中的标准数据格式之一。JSON 支持的数据类型包括字符串、数字、布尔值、null、对象和数组，其中对象和数组可以嵌套使用。

在 JavaScript 中，可以使用 JSON 对象的 parse() 方法将 JSON 字符串转换为 JavaScript 对象，使用 stringify() 方法将 JavaScript 对象转换为 JSON 字符串。通过使用 JSON，应用程序可以方便地传递和处理数据，与传统的 XML 数据格式相比，JSON 更加简单、轻量和易于使用。

#### 什么是伪数组（类数组）？伪数组（类数组）和数组的区别？

伪数组（或称类数组）是一种类似于数组的对象，它具有以下特点：

1. 有从 0 开始的数字索引
1. 拥有 length 属性
1. 没有数组所具有的方法（如 push、pop、forEach 等）
1. 常见的伪数组包括函数的 arguments 对象、DOM 元素的 NodeList、HTMLCollection 等。

尽管伪数组看起来像是数组，但它们不是真正的数组，因为它们没有数组的原型。因此，如果要对伪数组进行数组操作，需要使用一些方法将其转换为真正的数组，比如使用 Array.from 或 Array.prototype.slice.call 方法。

**伪数组（类数组）和数组的区别**

伪数组（类数组）是指具有数组特性，但实际上不是数组的对象，例如 DOM 元素集合、函数的参数 arguments 对象等，它们不可以使用数组的方法，也没有数组的一些属性和方法，比如 length、slice、push、pop、shift、unshift 等。可以使用 for...in 来遍历它们。

数组是具有 length 属性和一系列可枚举属性的对象，可以使用数组的属性和方法，例如 push、pop、shift、unshift、slice、splice、sort 等。

在 JavaScript 中，可以通过 Array.from() 或者扩展运算符 (...) 等方法将伪数组转换成真正的数组。

```
Array.prototype.slice.call(fakeArray)
```

#### 类数组转换成数组的方法有哪些？

类数组指的是具有数组的 length 属性和索引值的对象，但是没有数组的原型方法（如 push、pop、splice 等）。将类数组转换成数组有以下几种方法：

Array.from()：ES6 新增的方法，可以将类数组对象或可迭代对象转换成真正的数组。

```
const arrayLike = {0: 'a', 1: 'b', 2: 'c', length: 3};
const arr = Array.from(arrayLike); // ['a', 'b', 'c']
```

Array.prototype.slice.call()：可以将一个类数组对象转换成一个新的数组，常用于将 arguments 转换成数组。

```
function foo() {
  const arr = Array.prototype.slice.call(arguments); // 将 arguments 转换成数组
  console.log(arr);
}
foo(1, 2, 3); // [1, 2, 3]
```

扩展运算符（...）：同样可以将一个类数组对象转换成一个新的数组。

```
const arrayLike = {0: 'a', 1: 'b', 2: 'c', length: 3};
const arr = [...arrayLike]; // ['a', 'b', 'c']
```

Array.prototype.concat.apply()：与第二种方法类似，将类数组对象转换成一个新的数组。

```
const arrayLike = {0: 'a', 1: 'b', 2: 'c', length: 3};
const arr = Array.prototype.concat.apply([], arrayLike); // ['a', 'b', 'c']
```

需要注意的是，以上几种方法都是将类数组对象转换成一个新的数组，原始的类数组对象并没有改变。

#### Unicode、UTF-8、UTF-16、UTF-32 的区别？

Unicode 是一种字符集，定义了每个字符对应的唯一编号，可以看作是字符和数字的映射关系。UTF（Unicode Transformation Format）是一种编码方式，将 Unicode 中的数字编码为字节序列，以便存储和传输。

UTF-8 是一种可变长度的编码方式，使用 1-4 个字节表示每个字符，适用于存储英文、数字、符号等单字节字符，也能够表示中文、日文等多字节字符。UTF-8 最大的优点是向后兼容 ASCII 编码，它的前 128 个字符与 ASCII 编码完全相同。

UTF-16 也是一种可变长度的编码方式，使用 2 或 4 个字节表示每个字符，适用于存储英文、数字、符号等单字节字符，以及中文、日文等多字节字符。与 UTF-8 不同，UTF-16 对于字符的编码方式是固定的，不存在字节序列的问题。

UTF-32 是一种固定长度的编码方式，使用 4 个字节表示每个字符，适用于存储所有字符。UTF-32 对于每个字符都分配了固定的空间，因此可以快速访问任何一个字符，但相应的存储空间会更大。

总之，Unicode 定义了字符集，UTF 定义了字符集到字节序列的映射方式，不同的 UTF 编码方式决定了字符集到字节序列的具体实现方式，每种编码方式都有自己的优缺点，需要根据实际情况进行选择。

#### escape、encodeURI、encodeURIComponent 的区别？

在 JavaScript 中，escape、encodeURI 和 encodeURIComponent 都是用来对字符串进行编码的方法，但它们的具体实现和编码规则有所不同，因此在使用时需要根据具体的情况选择合适的方法。

1. **escape**: 对字符串进行编码，将字符串中的非 ASCII 字符全部转义为 %xx 的格式，其中 xx 表示字符的 16 进制编码值。需要注意的是，该方法已经被废弃，不建议在实际开发中使用。
1. **encodeURI**: 对整个 URL 进行编码，主要用于编码 URL 中的查询参数部分。与 escape 不同，该方法只会对非 ASCII 字符进行编码，将其转义为 %xx 的格式。此外，该方法不会对一些特殊字符进行编码，例如冒号、正斜杠、问号等。
1. **encodeURIComponent**: 用于对 URI 的组成部分进行编码，主要用于编码 URI 中的路径部分和查询参数部分。与 encodeURI 不同，该方法会对所有非 ASCII 字符进行编码，并将其转义为 %xx 的格式。同时，该方法还会对一些特殊字符进行编码，例如冒号、正斜杠、问号等。

需要注意的是，无论是哪种编码方法，都可以使用对应的解码方法进行解码，例如 unescape、decodeURI 和 decodeURIComponent。

#### 什么是尾调用，使用尾调用有什么好处？

尾调用是指函数调用语句中的函数调用是另一个函数的最后一条语句。当一个函数在执行完自己的任务后，调用另外一个函数并将其结果返回时，如果该调用语句满足一定的条件，那么这个调用语句就是一个尾调用。尾调用不会在当前函数创建一个新的栈帧，而是可以复用当前函数的栈帧，从而达到优化内存使用的目的。

使用尾调用可以避免函数调用栈过深，从而提高性能和减少内存消耗。对于一些需要频繁调用的函数，使用尾调用可以有效地减少内存消耗和栈溢出的风险。

需要注意的是，尾调用优化不是 ECMAScript 规范中必须实现的，实现也存在兼容性问题，因此在编写代码时需要谨慎使用。

#### use strict; 是什么? 它有什么作用？

"use strict" 是 JavaScript 的一个指令，用于告诉浏览器或 Node.js，启用严格模式（strict mode）。在严格模式下，JavaScript 引擎会进行额外的检查，以帮助开发人员避免一些常见的错误，从而提高代码的安全性和可靠性。

使用 "use strict" 可以带来以下好处：

1. 严格模式禁止使用一些不安全的语法，如未声明变量、删除变量等，这可以避免一些潜在的错误。
1. 严格模式中禁止使用 with 语句，这可以防止代码中出现一些奇怪的行为，提高代码的可读性和可维护性。
1. 在严格模式下，函数中的 this 关键字会被绑定到 undefined，而不是全局对象，这可以避免一些奇怪的行为。
1. 严格模式中的 eval 函数不能修改当前作用域中的变量或声明函数，这可以减少一些潜在的安全风险。

总之，使用 "use strict" 可以使代码更加安全、可靠和易于维护。

#### 如何判断一个对象是否属于某个类？

在 JavaScript 中，我们可以使用 instanceof 操作符来判断一个对象是否属于某个类。instanceof 操作符需要两个操作数，一个是待判断的对象，一个是目标类构造函数。

语法如下：

```
object instanceof constructor
```

如果 object 是 constructor 的实例，返回 true，否则返回 false。

例如，判断 obj 是否是 Array 类的实例：

```
var obj = [1, 2, 3];
console.log(obj instanceof Array); // true
```

需要注意的是，instanceof 判断的是对象是否是由目标类构造函数创建的实例，而不是判断对象的类型。如果对象是通过字面量或 Object.create() 创建的，instanceof 会返回 false。

此外，如果一个类的原型链中包含了目标类的原型对象，也会返回 true。因此，instanceof 可以用来实现继承。

#### 强类型语言和弱类型语言的区别？

强类型语言和弱类型语言是编程语言的两个重要概念，它们的区别在于变量的类型检查和类型转换方面：

1. **强类型语言**：变量类型一旦定义就不能改变，变量的类型检查非常严格，需要明确地进行类型转换。例如，Java 和 C# 都是强类型语言。
1. **弱类型语言**：变量类型可以随时改变，变量的类型检查比较宽松，可以进行隐式类型转换。例如，JavaScript 和 PHP 都是弱类型语言。

强类型语言的优点在于程序员可以更早地发现类型错误，减少程序出错的概率。弱类型语言的优点在于编写代码的灵活性更高，节省了时间和精力。

需要注意的是，强类型语言和静态类型语言是两个不同的概念，不要混淆。强类型语言可以是动态类型语言，例如 JavaScript，而静态类型语言也可以是弱类型语言，例如 PHP。

#### 解释性语言和编译型语言的区别？

解释性语言和编译型语言是两种不同的语言类型。

解释性语言是指在执行程序时，将程序代码一行一行解释成机器代码并立即执行。解释性语言在运行时需要不断解释代码，因此通常执行速度比较慢。代表性的解释性语言有 JavaScript、Python、Ruby 等。

编译型语言则是在运行程序之前需要将程序代码编译成机器语言，并将其存储在可执行文件中。编译型语言在编译时会对代码进行优化，因此在执行时速度通常比解释型语言快。代表性的编译型语言有 C、C++、Java 等。

总体来说，解释型语言更加灵活，开发效率高，但运行速度相对较慢；而编译型语言则更加高效，运行速度快，但开发效率相对较低。

#### includes 比 indexOf 好在哪？

includes 和 indexOf 都是用来检查字符串或数组中是否包含某个元素的方法，但是它们有以下几点不同：

1. **返回值不同**：includes 返回一个布尔值，表示是否包含指定元素；indexOf 返回一个整数值，表示指定元素在数组中的位置，如果不存在则返回 -1。
1. **参数不同**：includes 只接受一个参数，即要检查的元素值；indexOf 还可以接受第二个参数，表示从哪个位置开始检索。
1. **语法简洁性**：使用 includes 的语法更加简洁易读。

相比之下，includes 更加直观易用，代码更加简洁，且在一些特殊情况下性能也更好。但是需要注意的是，includes 是 ES6 新增的方法，在一些老版本浏览器中可能不支持，需要进行兼容性处理。而 indexOf 则是比较常用的数组方法，几乎所有的浏览器和 JS 引擎都支持。因此，具体使用哪种方法应该根据具体的场景和需求来进行选择。

#### 什么是回调函数？回调函数有什么缺点？

回调函数是指在异步操作执行完毕后所需执行的函数。通常，异步操作执行完毕后会调用回调函数，将异步操作的结果作为参数传递给回调函数，然后执行回调函数。回调函数常用于处理异步操作的结果，例如 AJAX 请求、定时器、事件监听等。

回调函数的主要缺点在于，当多个异步操作需要执行时，会出现“回调地狱”的情况。也就是说，回调函数会嵌套在回调函数中，使得代码变得难以阅读、难以维护。此外，回调函数还存在着一些其他的问题，例如容易出现错误、难以处理异步操作的错误等。因此，在开发中，我们可以考虑使用 Promise、async/await 等异步编程的解决方案来避免回调地狱和其他问题。

#### 什么是回调地狱？回调地狱会带来什么问题？如何解决回调地狱问题？

回调地狱指的是多层嵌套的回调函数，形成代码缩进过深、难以维护和理解的情况。

回调地狱会导致代码复杂度上升，难以调试和维护，同时也会影响代码的可读性和可维护性。

解决回调地狱的方法有以下几种：

1. **Promise**：使用 Promise 可以将异步操作封装成 Promise 实例，在 Promise 实例中链式调用 then 方法，避免了多层嵌套的回调函数，使代码更加可读且易于维护。
1. **async/await**：async/await 是在 Promise 基础上的语法糖，可以更加优雅地处理异步操作。使用 async/await 可以将异步操作写成同步代码的形式，避免了回调地狱的问题。
1. **发布/订阅模式**：发布/订阅模式是一种广泛使用的异步编程模式，通过发布者发布消息，订阅者订阅消息，实现了解耦和更好的可维护性。在该模式中，发布者和订阅者通过事件或消息进行交互，而不是通过直接调用回调函数。

综上所述，使用 Promise、async/await 或发布/订阅模式可以避免回调地狱的问题，使代码更加易于维护和扩展。

#### Promise 是什么？解决了什么问题？

Promise 是一种用于异步编程的 JavaScript 对象，它可以更好地管理和组织异步操作。Promise 提供了一种解决 Ajax 回调地狱（Callback Hell）的方案，使得异步代码可以更加清晰和易于维护。

Promise 具有三个状态：Pending（等待状态）、Fulfilled（已完成状态）和 Rejected（已失败状态）。

1. 当异步操作尚未完成时，Promise 的状态为 Pending；
1. 当异步操作成功完成时，Promise 的状态为 Fulfilled；
1. 当异步操作失败时，Promise 的状态为 Rejected。

使用 Promise 我们可以通过链式调用 then 方法来处理异步操作的结果，也可以使用 catch 方法来处理异步操作的错误。

Promise 的出现大大简化了异步编程，使得异步代码的可读性和可维护性都有了很大的提升。

例如，可以通过 Promise 实现读取文件：

```
const fs = require('fs/promises');

fs.readFile('file.txt', 'utf8')
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

#### async/await 是什么？解决了什么问题

async/await 是一种异步编程的解决方案，可以让 JavaScript 代码在不阻塞其他操作的情况下等待异步操作的结果。在语言层面上，它是基于 Promise 实现的一种语法糖，可以更加方便地处理异步操作。

通过使用 async/await，可以让异步操作看起来像是同步的，避免了回调地狱等问题，提高了代码的可读性和可维护性。同时，它也简化了异常处理，可以通过 try/catch 语句捕获异步操作的错误，并进行相应的处理。

具体来说，async 用于定义一个异步函数，它会返回一个 Promise 对象。在异步函数中，可以使用 await 等待一个异步操作的完成，并且异步操作的结果会被解析为一个值返回。如果异步操作出现错误，则会抛出异常，可以使用 try/catch 来处理异常。

总之，async/await 帮助我们更加方便地处理异步操作，避免了回调地狱和复杂的异常处理，让代码更加简洁易读。

#### Promise 有哪些 API？

Promise 是 JavaScript 中一种处理异步操作的方法，它可以在异步操作完成后通过回调函数来处理异步结果。以下是 Promise 的常用 API：

1. **Promise.all(iterable)**：接受一个可迭代对象作为参数，返回一个新的 Promise 对象，只有所有的 Promise 都成功才会返回成功结果，否则返回失败结果。
1. **Promise.race(iterable)**：接受一个可迭代对象作为参数，返回一个新的 Promise 对象，只要其中有一个 Promise 成功或失败，就会返回相应的结果。
1. **Promise.resolve(value)**：将一个值包装成 Promise 对象并立即返回，返回的 Promise 对象状态为成功。
1. **Promise.reject(reason)**：将一个错误信息包装成 Promise 对象并立即返回，返回的 Promise 对象状态为失败。
1. **Promise.prototype.then(onFulfilled, onRejected)**：绑定成功和失败的回调函数，如果当前 Promise 对象为成功状态，执行 onFulfilled 回调函数，否则执行 onRejected 回调函数，返回一个新的 Promise 对象。
1. **Promise.prototype.catch(onRejected)**：绑定失败的回调函数，相当于 then(null, onRejected)。
1. **Promise.prototype.finally(onFinally)**：绑定 finally 的回调函数，无论 Promise 对象状态为成功或失败，都会执行 onFinally 回调函数，返回一个新的 Promise 对象。

#### 什么是 Ajax？有什么优缺点？

Ajax（Asynchronous Javascript And XML），是一种用于创建交互式网页应用的技术，用于提高浏览器和服务器之间的交互效率，快速创建动态网页。Ajax 是一种在浏览器与服务器之间的异步通信方式，可以异步地向服务器发送请求，在等待响应的过程中，不会阻塞当前页面，直到成功获取响应后，浏览器才开始处理响应数据。XML 是前后端数据通信时传输数据的一种格式，而 JSON 比 XML 更加轻量，作为 Javascript 的一部分，目前 JSON 的使用比 XML 更加普遍。Ajax 可以在浏览器不重新加载网页的情况下，对页面的某部分进行更新。Ajax 的应用场景包括注册页面、搜索提示等。在 Ajax 模型中，XMLHttpRequest 是最重要的技术之一，可以使用 Fetch API 设置 XMLHttpRequest 对象的 responseType 属性以改变从服务器端获取数据的类型。Ajax 应用程序独立于浏览器和平台，使用的 Web 标准包括 JavaScript、XML、HTML 与 CSS。

优点：

- 实现无刷新更新数据：Ajax 可以在不刷新整个页面的情况下与服务器通信，维护数据，使得 Web 应用程序更为迅捷地响应用户交互，减少用户等待时间，带来非常好的用户体验。
- 异步与服务器通信：Ajax 使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。它优化了 Browser 和 Server 之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。
- 前端和后端负载平衡：Ajax 可以把一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。

缺点：

- 不支持浏览器 back 按钮：因为 Ajax 不会改变浏览器的 URL，所以在使用浏览器的 back 按钮时，会导致用户回到上一个页面，但是页面内容并未更新，造成用户体验上的不便。
- 安全问题：Ajax 暴露了与服务器交互的细节，可能会被黑客利用，攻击应用程序。同时，Ajax 应用程序中的安全性较低，因为所有文件都是在客户端下载的。
- 对搜索引擎的支持比较弱：因为 Ajax 不会改变浏览器的 URL，所以搜索引擎无法获取到 Ajax 请求的内容，影响 SEO。
- 破坏了程序的异常机制：Ajax 的异步请求可能破坏程序的异常机制，因为它不会像同步请求一样抛出异常。

总之，Ajax 技术能够带来更好的用户体验，提高性能和速度，但是也存在一些安全和兼容性问题，需要在开发过程中注意。

#### 讲一下 XMLHttpRequest 对象 readyState 的五种状态？

XMLHttpRequest 对象是 Ajax 技术的核心，它有五个 readyState 状态：

- **0 - UNSENT**：已创建 XMLHttpRequest 对象，但尚未调用 open（）方法。这意味着对象存在，但尚未初始化。
- **1 - OPENED**：已调用 open（）方法，XMLHttpRequest 对象已准备好向服务器发送请求。在这个阶段，您可以使用 setRequestHeader（）方法向请求添加头。
- **2 - HEADERS_RECEIVED**：已调用 send（）方法，请求已发送到服务器。服务器已开始发回响应，并且已收到响应的标头。
- **3 - LOADING**：正在从服务器接收响应主体。如果 responseType 属性设置为“text”或空字符串，responseText 属性将在加载时包含一些响应数据。
- **4 - DONE**：已收到整个响应，请求已完成。在此阶段，您可以访问 XHR 对象的 responseText 或 response XML 财产以获取响应数据。

每当 XMLHttpRequest.readyState 的状态改变时，都会触发 XMLHttpRequest.onreadystatechange 事件。可以根据不同的状态进行不同的操作，例如：

```
const xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
  if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.open('GET', 'https://example.com/data.json');
xhr.send();
```

以上代码会向服务器发送一个 GET 请求，并在响应完成后打印响应内容。当 readyState 状态为 DONE 且响应状态码为 200 时，表示响应已经完成，可以通过 responseText 属性获取响应内容。

#### 请介绍一下 XMLHTTPRequest 对象？

XMLHttpRequest 对象是 JavaScript 的一个核心 API，用于在浏览器中发起 HTTP 请求，并获取服务器返回的数据，实现异步数据交换（AJAX）。

XMLHttpRequest 对象的基本用法如下：

1. **创建 XMLHttpRequest 实例**：通过 new XMLHttpRequest() 创建 XMLHttpRequest 对象。
1. **配置请求参数**：通过 open() 方法设置请求的方法、URL 和是否异步等。
1. **发送请求**：通过 send() 方法发送请求。
1. **监听状态变化**：通过 onreadystatechange 属性指定当 readyState 属性发生变化时的回调函数，可以在回调函数中通过 status 和 responseText 等属性获取服务器返回的数据。

XMLHttpRequest 对象的常见用法包括：

1. 发送 GET 请求：通过将请求参数拼接在 URL 后面，然后调用 send() 方法发送 GET 请求，如：xhr.open('GET', 'https://example.com/api/data?id=1', true); xhr.send();
1. 发送 POST 请求：通过设置请求头和请求体，然后调用 send() 方法发送 POST 请求，如：

```
xhr.open('POST', 'https://example.com/api/data', true);
xhr.setRequestHeader('Content-type', 'application/json');
xhr.send(JSON.stringify({id: 1, name: 'example'}));
```

XMLHttpRequest 对象的属性和方法比较多，还包括 abort()、getAllResponseHeaders()、getResponseHeader()、timeout 等。

#### ajax、axios、fetch 的区别？

Ajax、Axios 和 Fetch 都是用于发送异步请求的 JavaScript 库。

Ajax 是一种基于原生 XMLHttpRequest 对象实现的技术，用于在不刷新页面的情况下与服务器进行数据交互。

Axios 是一个基于 Promise 的 HTTP 库，可以用于浏览器和 Node.js，支持拦截请求和响应，自动转换 JSON 数据，取消请求等特性。

Fetch 是浏览器原生提供的一个基于 Promise 的网络请求 API，支持 Request 和 Response 对象，可以更灵活地控制请求和响应。相比于 Ajax 和 Axios，Fetch 更加简洁，并且默认不会发送或接收任何 cookies。

它们的主要区别在于实现方式、特性支持和兼容性等方面。Ajax 是比较老的技术，虽然功能强大但需要手动处理请求和响应等细节，而 Axios 和 Fetch 对这些细节进行了更好的封装和处理，使用起来更加方便快捷。但 Fetch 在某些浏览器上的兼容性不如 Ajax 和 Axios，所以需要在具体场景下进行选择和使用。

#### 取消 ajax 请求有什么意义？

取消 ajax 请求的主要目的是避免不必要的资源浪费和提升用户体验。在网络不稳定或者用户操作频繁的情况下，可能会发生多次请求的情况，而这些请求并不一定都是有用的。如果不及时取消这些无用请求，就会浪费网络资源和服务器资源，导致应用的响应速度变慢，用户体验下降。同时，如果请求是基于用户的操作触发的，用户可能会感到困惑或者不满意，因为他们并不知道这些无用请求会占用他们的带宽或者延长应用的响应时间。因此，及时取消无用请求可以减少不必要的资源浪费和提升用户体验。

#### ES6 更新了哪些新语法？（从你回答的里面挑一个问详细的）

ES6（ECMAScript 2015）引入了许多新的语法和特性，其中一些主要的包括：

1. **块级作用域**：使用 let 和 const 声明变量时可以创建块级作用域。
1. **箭头函数**：使用 => 语法定义匿名函数。
1. **解构赋值**：可以从数组和对象中提取值并将其赋给变量。
1. **模板字符串**：使用反引号 `` 来创建多行字符串，并且可以在字符串中插入表达式。
1. **默认参数**：定义函数参数的默认值。
1. **展开运算符**：使用 ... 语法来展开数组或对象。
1. **类和继承**：使用 class 和 extends 关键字来定义类和继承。
1. **模块化**：使用 import 和 export 关键字来导入和导出模块。
1. **Promise**：处理异步操作的一种方法，可以通过链式调用来组合多个异步操作。
1. **Symbol**：引入了一种新的原始数据类型，用于创建唯一的标识符。
1. **Map 和 WeakMap**：字典，一种新的集合类型，为 ECMAScript 语言带来了真正的键/值存储机制
1. **Set 和 WeakSet**：集合，一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。
1. **迭代器和生成器**：迭代器是一种对象，可以通过 next() 方法按顺序返回值，而生成器是一种函数，可以使用 yield 关键字来定义迭代器。
1. **for...in**：用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。
1. **for...of**：用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。

#### Promise 是什么？有哪几种状态？怎么改变状态？

Promise 是 JavaScript 中的一种异步编程解决方案，可以避免回调地狱，简化异步操作的代码编写和维护。

Promise 有三种状态：pending（等待）、fulfilled（已完成）和 rejected（已拒绝）。Promise 对象的状态只能由 pending 转变为 fulfilled 或 rejected，一旦状态变化，就不会再改变。

Promise 对象的状态转变由 resolve 和 reject 函数来改变。resolve 函数用于将 Promise 对象的状态从 pending 转变为 fulfilled，reject 函数用于将 Promise 对象的状态从 pending 转变为 rejected。可以将 resolve 和 reject 函数作为参数传递给 Promise 构造函数。

例如，下面的代码演示了如何创建一个 Promise 对象，并使用 resolve 和 reject 函数改变其状态：

```
let promise = new Promise((resolve, reject) => {
  // 异步操作
  setTimeout(() => {
    // 异步操作成功
    resolve('成功');
  }, 1000);
});

promise.then(value => {
  console.log(value); // 输出：成功
});
```

在上面的代码中，Promise 构造函数接受一个回调函数作为参数，该回调函数有两个参数，分别是 resolve 和 reject 函数。在回调函数中，进行了一个异步操作，当异步操作成功时，调用 resolve 函数将 Promise 对象的状态从 pending 转变为 fulfilled，并将操作结果作为参数传递给 then 方法；当异步操作失败时，调用 reject 函数将 Promise 对象的状态从 pending 转变为 rejected，并将错误信息作为参数传递给 catch 方法。

Promise 对象的状态一旦改变，就不会再次改变。因此，可以通过链式调用 then 和 catch 方法，依次处理异步操作成功和失败的情况。例如：

```
let promise = new Promise((resolve, reject) => {
  // 异步操作
  setTimeout(() => {
    // 异步操作成功
    resolve('成功');
  }, 1000);
});

promise.then(value => {
  console.log(value); // 输出：成功
  return value.toUpperCase();
}).then(value => {
  console.log(value); // 输出：成功
}).catch(error => {
  console.error(error);
});
```

在上面的代码中，通过链式调用 then 方法，依次处理异步操作成功的情况，并将操作结果转换为大写字母。如果链式调用 then 方法时出现异常，会立即调用 catch 方法。

#### Promise 有哪些 API？

Promise 是 ES6 中新增的一种异步编程解决方案，提供了更加简洁、直观的异步编程写法，并且也为异步编程的错误处理提供了更好的支持。

Promise 提供了一些 API 来处理异步操作的状态和结果：

1. **Promise.prototype.then()**：注册异步操作成功时的回调函数，可以链式调用多个 then() 方法；
1. **Promise.prototype.catch()**：注册异步操作失败时的回调函数，可以捕获异步操作过程中的错误；
1. **Promise.prototype.finally()**：无论异步操作成功或失败，都会执行的回调函数；
1. **Promise.all(iterable)**：接收一个可迭代对象，返回一个 Promise 实例，当可迭代对象中所有的 Promise 实例都成功执行时，返回的 Promise 实例才会成功执行，否则失败；
1. **Promise.race(iterable)**：接收一个可迭代对象，返回一个 Promise 实例，当可迭代对象中任意一个 Promise 实例执行成功或失败时，返回的 Promise 实例就会立即执行并返回这个 Promise 实例的状态和结果。

除了以上几个 API，Promise 还提供了一些静态方法来创建 Promise 实例或执行 Promise 相关操作：

1. **Promise.resolve(value)**：返回一个 Promise 实例，状态为已解决，结果为指定的值；
1. **Promise.reject(reason)**：返回一个 Promise 实例，状态为已拒绝，结果为指定的错误原因；
1. **Promise.allSettled(iterable)**：接收一个可迭代对象，返回一个 Promise 实例，当可迭代对象中所有的 Promise 实例都执行完毕时，返回一个 Promise 实例，其状态总是已解决，结果是一个对象数组，数组中每个对象表示一个 Promise 实例的状态和结果；
1. **Promise.any(iterable)**：接收一个可迭代对象，返回一个 Promise 实例，当可迭代对象中任意一个 Promise 实例成功执行时，返回的 Promise 实例就会立即执行并返回这个 Promise 实例的状态和结果，如果可迭代对象中所有 Promise 实例都失败，则返回的 Promise 实例也失败。

#### Promise.all、Promise.race、Promise.any 的区别？

Promise.all、Promise.race、Promise.any 都是 Promise 提供的方法，它们的区别如下：

1. **Promise.all**：接收一个可迭代对象，比如数组，里面的所有 Promise 对象都 fulfilled 后才会将所有的结果封装成一个新的数组返回，如果有一个 Promise 被 rejected，那么 Promise.all 返回的 Promise 对象也会 reject，并且 reject 的是第一个被 reject 的 Promise 的返回值。
1. **Promise.race**：和 Promise.all 一样，接收一个可迭代对象，但是它的返回值是第一个完成的 Promise 对象的返回值，不管是 fulfilled 还是 rejected。
1. **Promise.any**：和 Promise.all 类似，接收一个可迭代对象，只要其中一个 Promise 对象状态变为 fulfilled，就会将这个 Promise 对象的返回值封装成一个新的 Promise 对象返回，如果所有的 Promise 对象都是 rejected 状态，则返回的 Promise 对象也是 rejected，返回的是所有 rejected 的 Promise 对象的返回值数组。

需要注意的是，Promise.any 是 ES2021 新增的方法，在一些浏览器或环境中可能不支持。

#### Promise 有什么优缺点？

Promise 是 JavaScript 中处理异步编程的一种解决方案，它具有以下优点和缺点：

优点：

1. **简化异步编程流程**：Promise 使得异步操作可以像同步操作一样流程化，提高代码可读性。
1. **避免回调地狱**：Promise 的链式调用可以避免回调地狱，使代码更加易于理解和维护。
1. **可以进行错误处理**：通过 .catch() 方法或者 Promise 的第二个参数，可以捕获异常并进行处理。
1. **支持并发**：可以使用 Promise.all() 方法将多个异步操作并发执行，并在所有操作完成后获取结果。

缺点：

1. **学习成本高**：Promise 作为一种异步编程解决方案，需要一定的学习成本和适应时间。
1. **无法取消 Promise**：一旦 Promise 被创建，就无法取消它，这可能会导致资源的浪费。
1. **不支持同步操作**：Promise 只支持异步操作，无法处理同步操作，这可能会导致一些问题。
1. **无法捕获 Promise 中的异常**：如果在 Promise 中抛出异常，而没有进行处理，可能会导致程序的崩溃。

#### async/await 是什么？解决了什么问题？

async/await 是一种异步编程的解决方案，可以让 JavaScript 代码在不阻塞其他操作的情况下等待异步操作的结果。在语言层面上，它是基于 Promise 实现的一种语法糖，可以更加方便地处理异步操作。

通过使用 async/await，可以让异步操作看起来像是同步的，避免了回调地狱等问题，提高了代码的可读性和可维护性。同时，它也简化了异常处理，可以通过 try/catch 语句捕获异步操作的错误，并进行相应的处理。

具体来说，async 用于定义一个异步函数，它会返回一个 Promise 对象。在异步函数中，可以使用 await 等待一个异步操作的完成，并且异步操作的结果会被解析为一个值返回。如果异步操作出现错误，则会抛出异常，可以使用 try/catch 来处理异常。

总之，async/await 帮助我们更加方便地处理异步操作，避免了回调地狱和复杂的异常处理，让代码更加简洁易读。

#### await 到底在等待啥？await 如何捕获异常？

在使用 await 关键字时，它会等待一个 Promise 对象（或者任何值都可以，但是如果不是 Promise 对象，那么它就会立即 resolve 成这个值）。当 Promise 对象 resolve 后，await 关键字会返回 Promise resolve 的值。

在 async/await 中捕获异常的方式，可以使用 try/catch 语句块。当使用 await 等待的 Promise 对象 reject 时，会抛出一个异常，然后这个异常会被传递给下一个可以捕获它的 catch 语句块，从而进行错误处理。例如：

```
async function example() {
  try {
    const result = await someAsyncFunction();
    console.log(result);
  } catch (error) {
    console.error(error);
  }
}
```

在上面的例子中，await 关键字等待 someAsyncFunction() 的结果，如果该函数 resolve，那么结果会被赋值给 result 变量，否则会抛出一个异常，然后被 catch 语句块捕获并打印出来。

#### async/await 对比 Promise 的优势？

async/await 相比 Promise 有以下几个优势：

1. **更直观**：async/await 更加直观和易于理解，代码的可读性更好。
1. **更简洁**：async/await 可以用更少的代码实现 Promise 的功能，避免了 Promise 的回调地狱问题。
1. **更易于调试**：async/await 可以像同步代码一样使用调试工具进行调试，方便定位问题。
1. **更易于捕获错误**：使用 try/catch 可以很方便地捕获错误，而使用 Promise 时需要通过 .catch() 处理错误。

需要注意的是，async/await 是基于 Promise 实现的，实质上也是一种 Promise 的语法糖，但可以更方便地编写异步代码。

#### 对浅拷贝深拷贝的理解？

在 JavaScript 中，对象和数组都是引用类型，也就是说，对对象和数组的操作会对其原始引用进行更改。当我们想要对一个对象或者数组进行拷贝时，会有浅拷贝和深拷贝两种方式。

浅拷贝是指复制对象或者数组本身，而不是复制对象或者数组中所包含的所有元素。当我们进行浅拷贝时，被拷贝的对象或数组中的基本数据类型元素会被复制，而引用类型的元素仍然指向原始的引用。这意味着，如果我们对原始对象或数组进行更改，浅拷贝后的对象或数组也会受到影响。常见的浅拷贝方式有对象展开运算符（{...obj}）和 Object.assign()方法。

深拷贝是指复制对象或者数组以及其中的所有元素。当我们进行深拷贝时，被拷贝的对象或数组中的所有基本数据类型元素和引用类型元素都会被复制，从而得到一个全新的对象或数组。这样就不会影响原始对象或数组的值。常见的深拷贝方式有递归复制、JSON.parse(JSON.stringify())、lodash 库中的深拷贝方法等。

浅拷贝的优点是效率高，缺点是不够完整，容易出现问题。深拷贝的优点是能够完整复制对象或数组以及其中的所有元素，缺点是效率比浅拷贝低。在实际开发中，我们应该根据具体的情况来选择浅拷贝还是深拷贝。

#### Object.assign 是深拷贝吗？JSON.stringify 深拷贝的缺点？

Object.assign 不是深拷贝，它是浅拷贝，即只会拷贝对象的第一层属性。如果对象中某个属性的值是一个对象或数组，那么只会拷贝这个对象或数组的引用，而不是实际的值。这意味着如果原对象和拷贝后的对象中的引用类型属性被修改，两个对象中的对应属性都会被修改。

JSON.stringify 可以将一个 JavaScript 对象序列化为一个 JSON 字符串，实现简单方便。但是它有一些缺点：

1. 不能处理循环引用的对象，会抛出异常。
1. 不能序列化函数、正则表达式等特殊类型。
1. 对于 Date 类型，只能序列化为 ISO 格式字符串，不能还原为 Date 对象。
1. 对于 NaN、Infinity、-Infinity 和 undefined，序列化后的结果都是 null。

因此，当需要深拷贝一个对象时，通常需要使用其他方式，比如递归拷贝。

#### 怎么实现深拷贝？（建议写博客）

实现深拷贝有多种方法，以下是其中几种：

1. **递归实现**：遍历源对象的每一个属性，如果是对象或数组，递归调用深拷贝函数。

```
function deepClone(obj) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  const newObj = obj instanceof Array ? [] : {};
  for (let key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      newObj[key] = deepClone(obj[key]);
    }
  }
  return newObj;
}
```

2. **JSON.parse(JSON.stringify(obj))**：将源对象序列化成 JSON 字符串，再通过 JSON.parse() 方法解析成一个新对象，这样可以实现深拷贝。但是，这种方法也有一些缺点，比如无法拷贝函数、循环引用会出错等。

```
const newObj = JSON.parse(JSON.stringify(obj));
```

2. **使用第三方库**：比如 Lodash 中的 \_.cloneDeep() 方法，可以实现深拷贝。

```
const newObj = _.cloneDeep(obj);
```

需要注意的是，在实际使用中，应该根据需求选择合适的深拷贝方法，比如对于需要拷贝函数、循环引用等情况，递归实现可能更适合。同时，深拷贝也可能导致性能问题，应该谨慎使用。

#### Object.assign 和扩展运算符是深拷贝还是浅拷贝，两者区别？

Object.assign 和扩展运算符都是浅拷贝。

浅拷贝指的是只拷贝对象的第一层属性，如果对象中的属性是引用类型，则只是将这个属性的引用拷贝了一份。因此，如果原对象中的引用类型属性被修改，拷贝后的对象中对应的属性也会被修改。

深拷贝则是将原对象的所有属性全部拷贝到新对象中，包括引用类型属性。因此，深拷贝不会改变原对象或拷贝对象中的属性，即它们是独立的。

如果需要进行深拷贝操作，可以使用 JSON.parse(JSON.stringify(object)) 或第三方库（如 lodash 的 cloneDeep 方法等）来实现。但是需要注意，使用 JSON.parse(JSON.stringify(object)) 进行深拷贝的时候，对象中不能有循环引用，否则会出现无限递归的问题。

#### 深度优先遍历、广度优先遍历的区别？

深度优先遍历和广度优先遍历都是常用的遍历算法，它们的区别在于遍历的顺序和策略。

1. **深度优先遍历**（Depth First Search，DFS）是一种优先遍历策略，从起点开始一直走到最深处，直到无法继续为止，然后返回上一个分叉点，再继续尝试走其他分支。具体来说，DFS 从一个起点开始，先访问它的一个相邻节点，然后递归地访问该节点的相邻节点，直到没有未访问的相邻节点，然后返回上一层继续遍历其他相邻节点。
1. **广度优先遍历**（Breadth First Search，BFS）是一种平等遍历策略，按照从起点开始，先访问起点的所有相邻节点，然后再访问这些节点相邻的所有节点，依此类推，直到遍历完所有可到达的节点。具体来说，BFS 从一个起点开始，先访问它的所有相邻节点，然后依次访问这些节点的相邻节点，直到遍历完所有可到达的节点。

总的来说，DFS 的优点在于能够深入探索每个节点，适合用于寻找目标节点深处的情况，缺点是可能会陷入无限循环中。而 BFS 的优点在于能够按照距离优先遍历节点，适合用于寻找目标节点离起点比较近的情况，缺点是空间复杂度较高。

#### 知道 lodash 吗？它有哪些常见的 API ？

是的，我知道 Lodash。Lodash 是一个 JavaScript 工具库，提供了很多方便的函数，用于简化 JavaScript 编程。以下是 Lodash 常见的 API：

1. **集合处理函数**：each、map、filter、reduce 等；
1. **数组处理函数**：chunk、difference、flatten、uniq 等；
1. **字符串处理函数**：trim、toUpper、snakeCase、kebabCase 等；
1. **对象处理函数**：get、set、omit、merge 等；
1. **函数处理函数**：debounce、throttle、memoize、curry 等；
1. **工具函数**：isEqual、cloneDeep、isEmpty、isNil 等。

这些函数涵盖了很多常见的编程场景，可以大大提高 JavaScript 编程效率。

#### (a == 1 && a == 2 && a == 3) 有可能是 true 吗？

在 JavaScript 中，由于类型的隐式转换，我们可以通过自定义对象的 valueOf() 或 toString() 方法来改变对象与原始类型的比较行为。因此，可以构造一个对象，使得在逻辑表达式中看起来像是 a 变量分别等于 1、2、3。

例如：

```
const a = {
  value: 1,
  valueOf: function() {
    return this.value++;
  }
};

console.log(a == 1 && a == 2 && a == 3); // true
```

这里的 valueOf() 方法会在 a 被用于与原始类型进行比较时自动调用。每次调用时，value 的值会自增 1。因此，在逻辑表达式中，第一次比较时，a 被转换成了 1，第二次比较时，a 被转换成了 2，第三次比较时，a 被转换成了 3，因此整个逻辑表达式的结果是 true。

虽然这种技巧可以被用来构造一些奇怪的行为，但在实际开发中并不应该使用，因为这种行为容易引起代码维护上的困扰。

#### 后端返回 1 万条数据，你要怎么进行渲染？

如果后端返回的数据量较大，直接进行渲染会影响页面性能，可能导致页面卡顿甚至崩溃。因此需要进行分页和懒加载等优化。

具体的方案可以有以下几种：

1. **分页**：将数据分为多个页面进行展示，每次只加载一页的数据，当用户需要查看其他页面时再去加载，这样可以减轻页面渲染的压力，提高页面的性能。
1. **懒加载**：先渲染当前视窗中的部分数据，当用户滚动页面到底部时，再异步加载下一批数据并渲染，这样可以避免一次性加载过多数据对页面性能的影响。
1. **虚拟滚动**：通过动态计算并渲染页面上展示的数据，而非全部的数据，从而提高页面性能，避免页面卡顿。
1. **数据分块**：将大量数据分为多个块进行渲染，可以通过分块、分段的方式来减少页面的渲染压力。例如，可以先渲染前面几百条数据，当用户滚动到底部时再渲染后面的数据。

总之，针对不同的应用场景和数据量大小，可以采用不同的方案进行优化，以提高页面性能和用户体验。

#### 你对虚拟列表的理解？怎么实现虚拟列表？

虚拟列表是一种优化长列表渲染性能的技术，通过只渲染当前视图区域内的列表项，减少不必要的 DOM 操作和渲染次数，从而提高性能和用户体验。

虚拟列表的实现方式一般有两种：

1. 根据滚动位置计算可视区域内需要渲染的列表项，仅渲染这些列表项，非可视区域的列表项不进行渲染。
1. 将整个列表分为多个等高的块（block），只渲染当前可视块及其相邻的一些块，非当前可视块的块不进行渲染。同时，使用占位符（placeholder）占据非可视块的位置，保持整个列表的高度不变。

在 Vue 中实现虚拟列表可以使用第一种方式。可以使用 scroll 事件监听滚动位置的变化，根据滚动位置计算当前可视区域内需要渲染的列表项，然后只渲染这些列表项。

以下是一个简单的实现示例：

具体实现方式如下：

1. 获取列表容器的高度和每个元素的高度。
1. 计算列表容器可显示的元素个数。
1. 根据可显示元素个数动态计算容器的高度，避免容器滚动条出现或者空白区域出现。
1. 监听滚动事件，计算当前可视区域的数据范围。
1. 将可视区域的数据渲染到 DOM 中，同时移除不可视区域的数据。
1. 列表容器滚动时，重新计算当前可视区域的数据范围，并更新可视区域的数据。

实现虚拟列表的关键在于计算可视区域的数据范围，这可以通过列表容器的 scrollTop 和每个元素的高度来计算得出。同时，还需要在列表容器滚动时实时更新可视区域的数据，保证数据的正确性和完整性。

```
<template>
  <div class="list-container" ref="listContainer" @scroll="handleScroll">
    <div class="list-item" v-for="item in visibleList" :key="item.id">
      {{ item.text }}
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      list: [], // 所有列表项数据
      visibleList: [], // 可视区域内渲染的列表项
      startIndex: 0, // 可视区域内第一个列表项的索引
      endIndex: 0, // 可视区域内最后一个列表项的索引
      itemHeight: 50, // 单个列表项的高度
      containerHeight: 0, // 可视区域的高度
    }
  },
  mounted() {
    // 初始化列表数据，这里假设有 10000 条数据
    for (let i = 0; i < 10000; i++) {
      this.list.push({
        id: i,
        text: `Item ${i}`,
      })
    }

    // 获取可视区域的高度
    this.containerHeight = this.$refs.listContainer.clientHeight

    // 初始化可视区域内的列表项
    this.updateVisibleList()
  },
  methods: {
    handleScroll() {
      // 计算可视区域内的起始索引和结束索引
      const scrollTop = this.$refs.listContainer.scrollTop
      const start = Math.floor(scrollTop / this.itemHeight)
      const end = start + Math.ceil(this.containerHeight / this.itemHeight)

      // 如果起始索引和结束索引发生变化，更新可视区域内的列表项
      if (start !== this.startIndex || end !== this.endIndex) {
        this.startIndex = start
        this.endIndex = end
        this.updateVisibleList()
      }
    },
    updateVisibleList() {
      // 根据起始索引和结束索引截取可视区域内的列表项
      this.visibleList = this.list.slice(this.startIndex, this.endIndex);
    }
  }
}
</script>

<style>
.list-container {
  height: 500px;
  overflow: auto;
}
.list-item {
  height: 500px;
}
</style>
```

#### JS 中的数组和函数在内存中是如何存储的？

在 JavaScript 中，数组和函数是两种不同的数据类型，它们在内存中的存储方式也不同。

数组是一个有序的数据集合，它在内存中的存储方式是连续的，即数组中的元素在内存中是连续存储的，每个元素占用相同的空间大小。这种存储方式使得数组在访问元素时具有 O(1) 的时间复杂度，但是在插入、删除元素时需要移动其他元素，时间复杂度为 O(n)。

函数是一段可执行的代码，它在内存中的存储方式是以函数对象的形式存在。函数对象包含了函数的代码和相关的属性，如函数名、参数列表、作用域链等。当函数被调用时，会创建一个执行上下文（Execution Context），该执行上下文会在内存中分配一块区域，用来保存函数的局部变量、函数参数、函数调用堆栈等信息。

总的来说，数组和函数在内存中的存储方式是不同的，数组是连续的存储方式，而函数是以函数对象的形式存在。这种不同的存储方式也决定了它们在访问、修改时的时间复杂度和操作方式。

#### 什么是函数式编程？

函数式编程是一种编程范式，它将计算视为函数求值，通过组合函数来创建程序。函数式编程强调使用不可变数据和无副作用函数来编写程序，避免共享状态和可变数据，从而减少了程序的复杂性和出错的可能性。

函数式编程的优点：

1. **没有副作用**：函数不会修改传入的参数，也不会修改外部状态，这使得函数具有可预测性，方便进行调试和测试。
1. **可复用性强**：函数式编程将复杂的问题分解成多个简单的函数，每个函数都只实现一个功能，这使得函数可以被复用，减少了代码的冗余。
1. **可扩展性好**：函数式编程支持高阶函数、柯里化和函数组合等技术，这些技术使得函数可以被组合和重用，提高了程序的可扩展性。

函数式编程的缺点：

1. **性能问题**：函数式编程中常常会创建新的数据结构，这会导致频繁的内存分配和垃圾回收，影响程序的性能。
1. **学习成本高**：函数式编程需要使用新的语言特性和函数库，需要学习新的概念和语法，学习成本较高。
1. **可读性差**：函数式编程中使用匿名函数和函数组合等技术，代码可读性较差，不易于理解和维护。

#### 什么是纯函数，它有什么优点？

纯函数是指输入相同，输出也必定相同，并且没有副作用的函数。也就是说，纯函数不会修改传入的参数，也不会对程序的状态造成任何影响。

纯函数的优点如下：

1. **可缓存性**：由于纯函数对于给定的输入总是返回相同的输出，因此可以将其结果缓存起来，避免重复计算，提高性能。
1. **可测试性**：由于纯函数没有副作用，所以可以轻松地编写测试用例来验证其正确性，减少测试的成本。
1. **并行代码**：由于纯函数没有副作用，可以并行地执行，因此可以更好地利用多核 CPU 的性能。
1. **可移植性**：由于纯函数不依赖于外部状态，所以可以在不同的环境中进行移植，例如客户端和服务器端。
1. **可组合性**：由于纯函数没有副作用，因此可以方便地组合成更复杂的函数，提高代码的可复用性。

总之，纯函数具有可预测性、可重用性和可维护性等优点。但是，由于纯函数不能修改传入的参数和程序状态，因此不能用来实现一些需要修改状态的功能，例如 IO 操作和事件处理等。

#### 什么是组合函数（compose）？

组合函数，也称为函数组合，是指将多个函数组合成一个新的函数。它可以让我们在编程过程中更加模块化和抽象化，使代码更加简洁、易于阅读和维护。

函数组合有两种实现方式：从左到右和从右到左。从左到右的组合函数称为 compose，从右到左的组合函数称为 pipe。

在函数式编程中，组合函数是一个很重要的概念，它可以将多个小函数组合成一个更加复杂的函数，并且保证整个过程是无副作用的。这使得代码更加简洁、可读性更强，也更加容易测试和调试。

组合函数的优点包括：

1. **简化代码**：通过将多个小函数组合成一个更加复杂的函数，可以使代码更加简洁、易于维护和阅读。
1. **减少副作用**：组合函数可以保证整个过程是无副作用的，这使得代码更加可靠、可测试和可调试。
1. **提高代码复用性**：组合函数可以将多个函数抽象成一个函数，这提高了代码的复用性和可扩展性。
1. 可以用于实现函数式编程中的一些常见模式，例如函数柯里化、函数节流、函数防抖等。

总之，组合函数是函数式编程中非常重要的概念，可以使我们更加方便地编写高质量、可读性高的代码。

#### 什么是惰性函数？

惰性函数是指在函数第一次被调用时才进行初始化并执行计算的函数。它通常用于在需要多次调用的情况下避免重复计算和多余的初始化，以提高性能。

一般来说，惰性函数的特点包括：

1. 只有在必要时才会进行初始化和计算，以避免不必要的计算和内存消耗。
1. 会缓存计算结果以供下一次调用使用，以避免重复计算。
1. 通常使用闭包或函数属性来保存状态或缓存结果，以避免对全局变量的污染。

例如，下面的代码展示了一个简单的惰性函数实现，它将一个对象的属性名列表缓存起来，在后续的调用中直接使用缓存结果：

```
function getPropertyNames(obj) {
  if (!getPropertyNames.namesCache) {
    console.log('Initializing property names cache...');
    getPropertyNames.namesCache = Object.keys(obj);
  }
  return getPropertyNames.namesCache;
}
```

在第一次调用 getPropertyNames() 时，函数会初始化缓存并执行计算，然后将结果保存在 namesCache 属性中。在后续的调用中，函数会直接使用缓存结果，而不必重新计算。这种方式可以有效地减少不必要的计算和内存消耗，提高代码的性能和可维护性。

#### 什么是高阶函数？

高阶函数指的是可以接收一个或多个函数作为参数，或者返回一个函数的函数。这意味着在高阶函数中，函数可以作为值进行传递和操作，而不仅仅是简单的数据类型。

JavaScript 中的许多内置函数就是高阶函数，比如 Array.prototype.map()、Array.prototype.filter()、Array.prototype.reduce() 等等。在使用这些函数时，我们可以将其它函数传递作为参数，或者将其作为返回值进行使用。

使用高阶函数的优点包括：

1. **增强代码的复用性**：通过接收或返回函数，高阶函数可以更加灵活地处理数据，从而增强代码的复用性。
1. **使代码更加简洁**：高阶函数可以使代码更加简洁，减少冗余代码的编写。
1. **更加灵活地处理数据**：高阶函数可以接收不同类型的函数作为参数，从而使得数据处理更加灵活，可以根据具体情况进行动态调整。

总之，高阶函数是函数式编程中非常重要的概念，能够使代码更加灵活、可复用、简洁。

#### 说说你对函数柯里化的理解？

函数柯里化是一种将接受多个参数的函数转换为接受单一参数的函数并返回新函数的技术。柯里化的过程是不断地将原函数分解为多个只有一个参数的函数。这个过程可以通过返回一个嵌套的函数来实现，每次嵌套函数只接受一个参数，最后一个嵌套函数执行并返回最终的结果。

函数柯里化的优点在于：

1. **增加代码的复用性**：柯里化可以将一个函数转换成一个接受单一参数的函数，这样可以将通用部分的代码抽离出来，实现代码的复用。
1. **函数参数的延迟计算**：柯里化可以将函数参数的计算延迟到函数调用时进行，可以灵活地控制参数的计算时机，提高程序的性能。
1. **提高代码的可读性**：柯里化将复杂的函数拆分成一系列简单的函数，提高了代码的可读性。

函数柯里化在实际开发中的应用比较广泛，比如对于一个需要传入多个参数的函数，我们可以先通过柯里化将其转换成接受单一参数的函数，然后将其保存下来，以后再次使用时直接传入需要的参数即可。

#### 什么是箭头函数，有什么特点？

箭头函数是 ES6 中的一种新的函数声明方式，它有以下特点：

1. 箭头函数使用箭头 (=>) 来代替传统的 function 关键字声明函数。
1. 箭头函数是匿名函数，可以通过变量或者作为参数传递给其他函数使用。
1. 箭头函数没有自己的 this 对象，它的 this 对象是继承而来的，指向函数被创建时的上下文对象。
1. 箭头函数不能用作构造函数，不能使用 new 关键字调用，否则会抛出错误。
1. 箭头函数省略了函数体的花括号 {}，如果函数体只有一条语句，则连同该语句的分号 ; 也可以省略。

箭头函数相对于传统函数的优点是简洁和方便，可以更好地处理 this 作用域和避免了不必要的代码。

#### 说说你对递归函数的理解？

递归函数是指在函数内部调用自身的一种函数，通常适用于需要重复执行相同或类似操作的场景。递归函数在代码实现上比较简单，可以让代码更加优雅、简洁，并且对于一些算法问题，使用递归函数更加符合数学模型，更容易理解。

递归函数通常分为两种，一种是“线性递归”，另一种是“尾递归”。

线性递归是指在递归过程中每次都需要重新分配内存空间，存储函数的参数、返回地址等信息，这样的递归函数容易导致内存溢出，影响程序的性能。而尾递归则是一种特殊的递归方式，它是指递归函数在递归过程中不会再产生新的函数调用，因此不会出现内存溢出的问题。

递归函数的实现需要注意的问题包括：

1. 定义好递归的结束条件，否则递归可能会无限执行下去；
1. 递归函数的参数和返回值应该明确，避免出现不必要的错误；
1. 对于线性递归函数，需要考虑如何优化代码，避免内存溢出。

在实际开发中，递归函数可以用于实现一些树形结构的数据操作，例如文件目录、网站导航、组织结构等，也可以用于解决一些算法问题，例如斐波那契数列、汉诺塔等。

#### 什么是尾递归？有什么作用？

尾递归是指在函数的最后一步操作是调用自身函数的递归形式。在尾递归中，递归调用是函数的最后一条语句，因此不会再次创建新的堆栈帧，从而减少了堆栈帧的数量，避免了爆栈的情况，提高了代码的执行效率。

尾递归的作用主要在于优化递归算法的性能，能够有效地减少堆栈的开销。在一些需要大量递归计算的场景中，使用尾递归可以大大减少堆栈的使用，从而提高程序的运行效率。

需要注意的是，并非所有的递归函数都可以转化为尾递归形式。只有在满足尾递归的条件下，才能够使用尾递归来优化算法性能。

#### 函数传参，传递复杂数据类型和简单数据类型有什么区别？

函数传参时，传递的是变量的值，而不是变量本身。对于简单数据类型（如数字、字符串、布尔值等），传递的是变量的值，这些值是直接存储在栈中的简单数据类型值。而对于复杂数据类型（如对象、数组等），传递的是变量的引用，实际上传递的是指向存储在堆内存中的对象的指针。

因此，对于简单数据类型，函数内部修改参数的值不会影响外部变量的值，因为传递的是值的副本，而非原值；而对于复杂数据类型，函数内部修改参数的值会影响外部变量的值，因为传递的是指向对象的指针，指向的是同一个对象。这就是简单数据类型和复杂数据类型之间的区别。

需要注意的是，在 JavaScript 中，字符串、数字和布尔值也是对象，但它们被称为原始值，它们并不是对象。虽然原始值在传递时也是传递副本，但它们是不可变的，因此函数内部不能改变它们的值。

#### 函数声明与函数表达式的区别？

在 JavaScript 中，函数可以通过函数声明和函数表达式来创建。它们有以下区别：

1. 语法上的区别：

函数声明语法：

```
function functionName(parameter1, parameter2, parameter3) {
  // function body
}
```

函数表达式语法：

```
var functionName = function(parameter1, parameter2, parameter3) {
  // function body
};
```

2. **变量提升**：函数声明会被提升到作用域的顶部，可以在声明之前调用函数。而函数表达式不会被提升，只有在定义之后才能调用函数。
3. **函数名**：函数声明会自动获得函数名，并且该函数名可以在整个作用域中使用。而函数表达式需要通过变量名来调用函数。
4. **用法**：函数声明适用于需要在整个作用域中使用函数的情况。函数表达式适用于只在某个表达式中需要使用函数的情况。
5. **匿名函数**：函数表达式可以是匿名的，即没有函数名。而函数声明必须要有函数名。

总之，函数声明与函数表达式都可以创建函数，但它们在语法、变量提升、函数名和用法等方面有所不同。

#### 什么是函数缓存，如何实现？

函数缓存指的是缓存函数的计算结果，以便在下一次同样的输入时能够直接返回缓存结果，避免重复计算。这种技术通常被用于提高函数执行的效率。

实现函数缓存的一种简单方法是使用闭包。我们可以将函数的参数作为缓存结果的键，将计算结果作为值存储在一个对象中，并返回一个新的函数，该函数会首先检查缓存是否存在相应的结果，如果存在则直接返回缓存结果，否则计算函数的值并将结果存储在缓存中。下面是一个使用闭包实现函数缓存的例子：

```
function memoize(func) {
  const cache = {};
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache[key]) {
      return cache[key];
    }
    const result = func.apply(this, args);
    cache[key] = result;
    return result;
  };
}

// 示例函数
function add(x, y) {
  console.log('calculating...');
  return x + y;
}

const memoizedAdd = memoize(add);

console.log(memoizedAdd(2, 3)); // "calculating..." 输出 5
console.log(memoizedAdd(2, 3)); // 直接输出 5，不再计算
```

在这个例子中，memoize 函数接收一个函数作为参数，并返回一个新的函数。新函数使用闭包来维护一个缓存对象 cache，存储计算结果。新函数首先将参数转换成一个唯一的键 key，然后检查缓存中是否存在相应的结果，如果存在则直接返回缓存结果，否则调用原始函数 func 计算结果，并将结果存储在缓存中。这样，在下一次调用相同参数的函数时，就可以直接返回缓存结果，避免重复计算，提高函数执行效率。

需要注意的是，这种方法只适用于参数为简单类型的函数，如果函数的参数是复杂类型，如对象或数组，需要使用特殊的方法来转换参数为字符串键。此外，使用函数缓存可能会占用较多的内存，因此需要注意缓存的大小和清理策略。

#### 说说面向对象的特性与特点？

面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它将数据和操作数据的方法封装在一起，通过创建对象来表示现实世界中的事物。面向对象编程有以下特性和特点：

1. **封装**（Encapsulation）：将数据和操作数据的方法封装在一起，隐藏对象的内部细节，只暴露必要的接口给外部使用。这样可以提高代码的可维护性和复用性。
1. **继承**（Inheritance）：定义一个基类（父类），派生出子类。子类可以继承父类的属性和方法，也可以覆盖或扩展父类的方法，减少了代码的重复。
1. **多态**（Polymorphism）：不同对象对同一消息的响应方式不同，即同一个方法可以有不同的实现方式。这样可以提高代码的灵活性和可扩展性。
1. **抽象**（Abstraction）：抽象出对象共同的特征和行为，形成一个抽象类或接口，减少代码的冗余和耦合性。

面向对象编程强调的是对象和对象之间的交互和合作，使得程序结构更加清晰，可读性和可维护性更好。但也存在一些缺点，如代码量大、执行效率低等。

#### 说说你对工厂模式的理解？

工厂模式是一种创建对象的设计模式，它通过一个工厂方法来创建对象，而不是直接使用 new 操作符去创建对象。它将对象的创建与使用分离开来，从而使得代码更加灵活，能够应对不同的需求。

在工厂模式中，我们通常会定义一个工厂函数，该函数接受一些参数，并根据这些参数来创建相应的对象。例如，我们可以定义一个汽车工厂，它接受一个型号参数，然后根据不同的型号来创建不同的汽车对象。

工厂模式有以下几个优点：

1. 可以将对象的创建和使用分离开来，从而使得代码更加灵活。
1. 可以根据不同的参数来创建不同的对象，从而实现对象的定制化。
1. 可以封装对象的创建过程，从而提高代码的复用性和可维护性。

当然，工厂模式也有一些缺点：

1. 工厂模式会增加代码的复杂度，需要定义多个工厂函数。
1. 工厂模式会增加代码的抽象程度，可能会使得代码更难理解和调试。

总的来说，工厂模式是一种非常实用的设计模式，它可以帮助我们更好地组织和管理对象的创建过程。

#### 创建对象有哪几种方式？

在 JavaScript 中，创建对象有多种方式，常见的包括：

1. 使用对象字面量 {}，例如：

```
const person = { name: 'Alice', age: 25 };
```

2. 使用 new Object()，例如：

```
const person = new Object();
person.name = 'Bob';
person.age = 30;
```

3. 使用构造函数模式（constructor），例如：

```
function Person(name, age) {
  this.name = name;
  this.age = age;
}
const person = new Person('Charlie', 35);
```

4. 使用原型模式（prototype），例如：

```
function Person() {}
Person.prototype.name = 'David';
Person.prototype.age = 40;
const person = new Person();
```

5. 使用 ES6 的 class 关键字，例如：

```
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
const person = new Person('Eve', 45);
```

还有一些不常用的方式，如工厂模式、动态原型、寄生构造函数、稳妥构造函数等。每种方式都有其适用的场景，需要根据具体的需求选择合适的方式。

#### 宿主对象和原生对象的区别？

- 原生对象是独立于宿主环境的 ECMAScript 实现提供的对象，而宿主对象则是由 ECMAScript 实现的宿主环境提供的对象。
- 原生对象包含的对象有：Object、Function、String、Array、Boolean、Number、Date、RegExp、Promise、Map、WeakMap、Set、WeakSet、XMLHttpRequest、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。内置对象就是原生对象，但是 ECMA-262 只定义了两个内置对象，即 Global 和 Math。
- 宿主对象包含的对象有：所有非内置对象，即由 ECMAScript 实现的宿主环境提供的对象。所有 BOM 和 DOM 对象都是宿主对象。宿主对象的具体内容因不同的宿主环境而异。例如在浏览器环境中，window 对象就是宿主对象之一。
- ECMAScript 中的本地对象是指独立于宿主环境的 ECMAScript 实现提供的对象，包括原生对象和内置对象。本地对象的具体内容包括：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。

总的来说，原生对象和内置对象都是本地对象的一种，而宿主对象则是 ECMAScript 实现的宿主环境提供的对象。需要特别注意的是，宿主对象的具体内容因不同的宿主环境而异，而本地对象的内容是固定的。

#### 说一下 hasOwnProperty、instanceof 方法？

hasOwnProperty 和 instanceof 是 JavaScript 中两个常用的方法，用于判断对象的属性和类型。hasOwnProperty 用于判断某个属性是否属于自身对象，该方法仅用于判断自身对象，不会查找原型链。instanceof 是从原型链上寻找是否有此实例，返回的是原型链最顶点的数据类型。下面是一些具体的解释和使用方法：

hasOwnProperty 方法

hasOwnProperty 方法是用来判断某个属性是否是属于自身对象的，该方法仅用于判断自身对象，不会查找原型链。

示例：

```
var obj = {a: 1, b: 2};
console.log(obj.hasOwnProperty('a'));  // true
console.log(obj.hasOwnProperty('toString'));  // false
```

注意：即使属性的值是 null 或 undefined，只要属性存在，hasOwnProperty 依旧会返回 true。

示例：

```
var o = new Object();
o.lisi = null;
o.hasOwnProperty('lisi'); // 返回 true
o.lizi = undefined;
o.hasOwnProperty('lizi'); // 返回 true
```

示例：

```
var o = new Object();
o.hasOwnProperty('prop'); // 返回 false
o.prop = 'exists';
o.hasOwnProperty('prop'); // 返回 true
delete o.prop;
o.hasOwnProperty('prop'); // 返回 false
```

示例：

```
var o = new Object();
o.prop = 'exists';
o.hasOwnProperty('prop');             // 返回 true
o.hasOwnProperty('toString');         // 返回 false
o.hasOwnProperty('hasOwnProperty');   // 返回 false
```

示例：

```
var foo = {
  hasOwnProperty: function() {
    return false;
  },
  bar: 'Here be dragons'
};
foo.hasOwnProperty('bar'); // 始终返回 false
// 如果担心这种情况，
// 可以直接使用原型链上真正的 hasOwnProperty 方法
({}).hasOwnProperty.call(foo, 'bar'); // true
// 也可以使用 Object 原型上的 hasOwnProperty 属性
Object.prototype.hasOwnProperty.call(foo, 'bar'); // true
```

instanceof 方法

instanceof 是从原型链上寻找是否有此实例，返回的是原型链最顶点的数据类型。

示例：

```
function Foo() {}
var f = new Foo();
console.log(f instanceof Foo); // true
console.log(f instanceof Object); // true
```

注意：instanceof 是不能判断基本类型的，例如：

```
var str = "hello world";
console.log(str instanceof String); // false
```

另外，instanceof 也不能判断 null 和 undefined 类型，会抛出异常：

```
var a = null;
console.log(a instanceof Object); // TypeError
```

以上是 hasOwnProperty 和 instanceof 方法的基本概念和使用方法。此外，还有其他的继承和构造函数的相关知识，例如原型链继承

#### 如何实现类？（建议写博客）

JavaScript 是一种基于对象的语言，但是它没有提供传统面向对象语言中的类的概念。但是，JavaScript 中可以使用闭包和原型链来模拟类的概念。下面是一些实现类的方法：

1. 使用构造函数和原型链

- 定义一个构造函数，使用 this 关键字来定义实例变量和方法。
- 使用 prototype 关键字来定义类的共有属性和方法。

例如:

```
function Shape(x, y) {
  this.x = x;
  this.y = y;
}

Shape.prototype.move = function(x, y) {
  this.x += x;
  this.y += y;
};

var shape = new Shape(1, 2);
shape.move(2, 3);
```

2. 使用 ES6 的 class 关键字

- 使用 class 关键字来定义类。
- 使用 constructor 方法来定义类的构造函数。
- 使用 extends 关键字来继承一个类。

例如：

```
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name);
  }
  speak() {
    console.log(`${this.name} barks.`);
  }
}

let d = new Dog('Mitzie');
d.speak(); // 'Mitzie barks.'
```

3. 使用静态方法

使用 static 关键字来定义静态方法。

- 静态方法只能被类本身调用，而不能被类的实例调用。

例如：

```
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  static displayName = "Point";
  static distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.hypot(dx, dy);
  }
}
const p1 = new Point(5, 5);
const p2 = new Point(10,10);
console.log(Point.displayName);
console.log(Point.distance(p1, p2));
```

4. 使用匿名类

使用 let 或 const 关键字创建一个匿名类。

例如：

```
let Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);

let Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
```

#### 如何实现继承？（建议写博客，ES5、ES6 各至少一种）

1. **原型链继承**

关键：子类构造函数的原型为父类构造函数的实例对象

缺点：

- 子类构造函数无法向父类构造函数传参。
- 所有的子类实例共享着一个原型对象，一旦原型对象的属性发生改变，所有子类的实例对象都会收影响
- 如果要给子类的原型上添加方法，必须放在 Son.prototype = new Father() 语句后面

```
function Father(name) {
  this.name = name
}
Father.prototype.showName = function () {
  console.log(this.name);
}
function Son(age) {
  this.age = 20
}
// 原型链继承，将子函数的原型绑定到父函数的实例上，子函数可以通过原型链查找到复函数的原型，实现继承
Son.prototype = new Father()
// 将 Son 原型的构造函数指回 Son，否则 Son 实例的 constructor 会指向 Father
Son.prototype.constructor = Son
Son.prototype.showAge = function () {
  console.log(this.age);
}
let son = new Son(20, '张三') // 无法向父构造函数里传参
// 子类构造函数的实例继承了父类构造函数原型的属性,所以可以访问到父类构造函数原型里的 showName 方法
// 子类构造函数的实例继承了父类构造函数的属性,但是无法传参赋值,所以是 this.name 是 undefined
son.showName() // undefined
son.showAge()  // 20
```

2. **借用构造函数继承**

关键：用 .call() 和 .apply() 方法，在子类构造函数中，调用父类构造函数

缺点：

- 只继承了父类构造函数的属性，没有继承父类原型的属性。
- 无法实现函数复用，如果父类构造函数里面有一个方法，会导致每一个子类实例上面都有相同的方法。

```
function Father(name) {
  this.name = name
}
Father.prototype.showName = function () {
  console.log(this.name);
}
function Son(name, age) {
  Father.call(this, name) // 在 Son 中借用了 Father 函数,只继承了父类构造函数的属性，没有继承父类原型的属性。
  // 相当于 this.name = name
  this.age = age
}
let s = new Son('张三', 20) // 可以给父构造函数传参
console.log(s.name); // '张三'
console.log(s.showName); // undefined
```

3. **组合继承**

关键：原型链继承+借用构造函数继承

缺点：使用组合继承时，父类构造函数会被调用两次，子类实例对象与子类的原型上会有相同的方法与属性，浪费内存。

```
function Father(name) {
  this.name = name
  this.say = function () {
    console.log('hello,world');
  }
}
Father.prototype.showName = function () {
  console.log(this.name);
}
function Son(name, age) {
  Father.call(this, name) // 借用构造函数继承
  this.age = age
}
// 原型链继承
Son.prototype = new Father()  // Son 实例的原型上,会有同样的属性,父类构造函数相当于调用了两次
// 将 Son 原型的构造函数指回 Son, 否则 Son 实例的 constructor 会指向 Father
Son.prototype.constructor = Son
Son.prototype.showAge = function () {
  console.log(this.age);
}
let p = new Son('张三', 20) // 可以向父构造函数里传参
// 也继承了父函数原型上的方法
console.log(p);
p.showName() // '张三'
p.showAge()  // 20
```

4. **原型式继承**

关键：创建一个函数，将要继承的对象通过参数传递给这个函数，最终返回一个对象，它的隐式原型指向传入的对象。 (Object.create()方法的底层就是原型式继承)

缺点：只能继承父类函数原型对象上的属性和方法，无法给父类构造函数传参

```
function createObj(obj) {
  function F() { }   // 声明一个构造函数
  F.prototype = obj   // 将这个构造函数的原型指向传入的对象
  F.prototype.construct = F   // construct 属性指回子类构造函数
  return new F        // 返回子类构造函数的实例
}
function Father() {
  this.name = '张三'
}
Father.prototype.showName = function () {
  console.log(this.name);
}
const son = createObj(Father.prototype)
son.showName() // undefined  继承了原型上的方法，但是没有继承构造函数里的 name 属性
```

5. **寄生式继承**

关键：在原型式继承的函数里，给继承的对象上添加属性和方法，增强这个对象

缺点：只能继承父类函数原型对象上的属性和方法，无法给父类构造函数传参

```
function createObj(obj) {
  function F() { }
  F.prototype = obj
  F.prototype.construct = F
  F.prototype.age = 20  // 给 F 函数的原型添加属性和方法,增强对象
  F.prototype.showAge = function () {
    console.log(this.age);
  }
  return new F
}
function Father() {
  this.name = '张三'
}
Father.prototype.showName = function () {
  console.log(this.name);
}
const son = createObj(Father.prototype)
son.showName() // undefined
son.showAge()  // 20
```

6. **寄生组合继承**

关键：原型式继承 + 构造函数继承

Js 最佳的继承方式，只调用了一次父类构造函数

```
function Father(name) {
  this.name = name
  this.say = function () {
    console.log('hello,world');
  }
}
Father.prototype.showName = function () {
  console.log(this.name);
}
function Son(name, age) {
  Father.call(this, name)
  this.age = age
}
Son.prototype = Object.create(Father.prototype) // Object.create 方法返回一个对象，它的隐式原型指向传入的对象。
Son.prototype.constructor = Son
const son = new Son('张三', 20)
console.log(son.prototype.name); // 原型上已经没有 name 属性了,所以这里会报错
```

7. **混入继承**

关键：利用 Object.assign 的方法多个父类函数的原型拷贝给子类原型

```
function Father(name) {
  this.name = name
}
Father.prototype.showName = function () {
  console.log(this.name);
}
function Mather(color) {
  this.color = color
}
Mather.prototype.showColor = function () {
  console.log(this.color);
}
function Son(name, color, age) {
  // 调用两个父类函数
  Father.call(this, name)
  Mather.call(this, color)
  this.age = age
}
Son.prototype = Object.create(Father.prototype)
Object.assign(Son.prototype, Mather.prototype)  // 将 Mather 父类函数的原型拷贝给子类函数
const son = new Son('张三', 'red', 20)
son.showColor()  // red
```

8. **class 继承**

关键：class 里的 extends 和 super 关键字，继承效果与寄生组合继承一样

```
class Father {
  constructor(name) {
    this.name = name
  }
  showName() {
    console.log(this.name);
  }
}
class Son extends Father {  // 子类通过 extends 继承父类
  constructor(name, age) {
    super(name)    // 调用父类里的 constructor 函数,等同于 Father.call(this,name)
    this.age = age
  }
  showAge() {
    console.log(this.age);
  }
}
const son = new Son('张三', 20)
son.showName()  // '张三'
son.showAge()   // 20
```

<!--
 * @Author: Shu Binqi
 * @Date: 2023-02-24 21:10:46
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-03 02:11:42
 * @Description: WEB 性能优化（22题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\ComputerNetwork\WEB性能优化.md
-->

#### 前端可以进行哪些性能优化？

前端性能优化是一个很广泛的话题，可以从很多方面来考虑。以下是一些前端性能优化的方向：

1. **资源压缩合并**，减少 http 请求：可以将一些小于 30k 的图片转换为 base64，或者将多个 CSS 和 JS 文件合并为一个文件，从而减少 HTTP 请求次数，提高页面加载速度。
2. **非核心代码异步加载**：将一些不必要首屏渲染的内容（如广告、统计代码等）使用异步加载的方式，可以减少首屏渲染时间，提高页面加载速度。
3. **利用浏览器缓存**：使用浏览器缓存可以减少 HTTP 请求次数，提高页面加载速度。可以将一些静态资源（如 CSS、JS、图片等）设置缓存时间，从而在下次访问时直接从缓存中获取。
4. **使用 CDN**：使用 CDN 可以将静态资源分布在全球各地的服务器上，从而减少网络延迟，提高页面加载速度。
5. **减少 HTTP 请求**：每个 HTTP 请求都需要经过一系列的步骤，如 DNS 查找、TCP 握手、浏览器发出 HTTP 请求、服务器接收请求、服务器处理请求并返回响应、浏览器接收响应等。因此，减少 HTTP 请求次数可以显著提高页面加载速度。可以通过以下方式减少 HTTP 请求次数：
   - 将多个 CSS 和 JS 文件合并为一个文件。
   - 将一些小于 30k 的图片转换为 base64。
   - 使用 CSS Sprites 技术将多个小图片合并为一个大图片。
   - 使用字体图标替代小图片。
6. **压缩静态资源**：可以使用 Gzip 等工具对静态资源进行压缩，从而减少文件大小，提高页面加载速度。
7. **长列表性能优化**：对于需要展示大量数据的页面，可以考虑使用虚拟滚动、懒加载等技术，从而减少 DOM 操作次数，提高页面渲染速度。

需要注意的是，性能优化是一个双刃剑，过度的优化可能会增加代码复杂度和维护成本。因此，在进行性能优化时，需要权衡利弊，选择适合当前项目的优化方案。

#### 可以使用哪些工具来分析和优化网站性能？

1. **Chrome DevTools Performance 工具**：该工具可以记录一段时间内的代码执行情况，如 Main 线程的 Event Loop、每个 Event loop 的 Task、每个 Task 的调用栈、每个函数的耗时等，还可以定位到源码位置。性能优化的目标就是找到 Task 中的 long task，消除它。Chrome DevTools Performance 工具是网页性能分析的利器。
2. **Lighthouse：Lighthouse** 是一个开源工具，可以自动化运行 Web 应用程序的质量检查，包括性能、可访问性、最佳实践等方面。它作为 Chrome 插件或命令行工具运行。Chrome 插件提供了更友好的界面，方便阅读报告。命令行工具允许将 Lighthouse 集成到持续集成系统中。它可以量化测试网站的表现，如首字节加载时间、渲染时间等，并自动给出前端性能优化改进建议报告。
3. **Google Page Speed Insight（PSI）**：它是一款旨在优化所有设备上的网页、提高网页加载速度的工具。它提供免费服务，可以分析网页的内容，提出建议，加快网页的速度。它为您提供了关键指标，如第一个内容绘制，总阻塞时间等，并将度量标准分类为 Field Data、Origin Summary、Lab Data、Opportunities、Diagnostics 和 Passed Audits。
4. **Sitespeed.io**：它是开源的 Web 性能测试工具，用来衡量 Web 网站的综合性能，帮助开发和测试人员分析网页的加载速度和渲染性能。它通过驱动浏览器（如 Chrome、Firefox）进行测试，然后从开发者的站点收集多个页面的数据，并根据优秀实践等规则来分析这些网页，然后将结果以 HTML 报告的形式输出。

总之，以上工具都可以帮助开发人员分析和优化网站性能，找出长任务，定位性能瓶颈，并提供优化建议。

#### 怎么减少 HTTP 请求？

减少 HTTP 请求是提高网站性能和用户体验的重要方法。以下是一些可行的方法：

1. **使用图片地图**：如果网页上有多个图片链接，可以将它们合并成一个图片地图，从而减少 HTTP 请求。这可以通过在一个图片上关联多个 URL 来实现。点击图片的不同区域会触发不同的链接。使用图片地图将减少多个 HTTP 请求，提高页面加载速度。
2. **CSS Sprites**：CSS Sprites 是一种将多个图片合并成一个大图片的技术。通过使用 CSS 中的背景定位来显示所需的图片。这样可以减少 HTTP 请求，提高性能。
3. **删除不必要的图像和文件**：在网站中使用的图像和文件越多，就需要发送越多的 HTTP 请求。因此，删除不必要的图像和文件是减少 HTTP 请求的有效方法。可以清理媒体库并删除所有不必要的图像和文件。但是，不应该为了减少 HTTP 请求而牺牲图像质量。
4. **使用 webRequest API 拦截和修改 HTTP 请求**：webRequest API 允许开发人员在浏览器中植入一个侦听器，以侦听各个阶段的 HTTP 请求。可以使用该 API 拦截和修改 HTTP 请求，从而减少 HTTP 请求的数量。
5. **使用 CDN（内容分发网络）**：CDN 可以将网站内容分发到多个服务器上，从而减少单个服务器的负载和 HTTP 请求的数量。CDN 使用户可以从离他们更近的服务器获取内容，从而加快网站加载速度。
6. **压缩和合并文件**：将多个 CSS 或 JavaScript 文件合并成一个文件，并使用压缩算法压缩文件大小，可以减少 HTTP 请求的数量。
7. **缓存静态资源**：将静态资源（如图片、CSS 和 JavaScript 文件）缓存到用户的浏览器中，可以减少 HTTP 请求的数量。浏览器会从缓存中加载这些资源，而不是从服务器重新获取它们。
8. **使用 HTTP/2 协议**：HTTP/2 协议支持多路复用，可以在单个连接上同时发送多个请求和响应。这样可以减少 HTTP 请求的数量，并提高性能。

#### CDN 是什么？CDN 的优化原理？

CDN（Content Delivery Network，内容分发网络）是一种将源服务器内容分发到全球各地的网络架构，可以更快地将内容提供给用户，降低网络拥塞和延迟。

CDN 的优化原理如下：

1. **建立全球节点**：CDN 服务商在全球建立多个服务器节点，将源站内容分发到这些节点，用户可以从离自己较近的节点获取内容，从而提高访问速度。
1. **动态选择最优节点**：CDN 服务商会根据用户的 IP 地址、网络状况、服务器负载等因素，动态地选择离用户最近、负载较小的节点，将内容分发给用户，提高用户体验。
1. **缓存静态资源**：CDN 服务商会缓存网站的静态资源，如图片、CSS、JS 等，用户在访问网站时可以直接从缓存中获取这些资源，减少对源站的请求，从而提高网站的访问速度。
1. **负载均衡和高可用**：CDN 服务商会使用负载均衡技术，将请求分配到不同的服务器节点上，从而实现高可用。

总之，CDN 的优化原理是将用户的请求分配到最近、负载较小的节点上，缓存静态资源，从而提高网站的访问速度和用户体验。

#### CDN 的优点？有哪些使用场景？

CDN（Content Delivery Network）即内容分发网络，是指一种通过在网络各处放置节点服务器来缓存和提供静态和动态内容的技术，目的是加速用户对网站、应用程序、音视频等内容的访问速度，提高访问质量和用户体验。

CDN 的优点包括：

1. 提高网站的访问速度和性能，加强用户体验，降低网站的跳出率。
1. 减轻源站的压力，提高源站的访问速度和稳定性，避免单点故障。
1. 支持高并发的访问，提供更好的网站稳定性和可靠性。
1. 支持全球分发，提供更好的地理位置优化和网络质量保障。
1. 提供完善的统计和监控功能，帮助用户了解网站的访问情况，及时发现问题并解决。

CDN 的使用场景包括：

1. **网站加速**：通过将网站的静态资源（如图片、CSS、JS 文件等）缓存到 CDN 服务器上，加快用户访问速度，提高用户体验。
1. **视频点播**：将视频文件缓存在 CDN 服务器上，用户可以从就近的 CDN 节点访问，避免了传输过程中的网络拥塞和延迟问题。
1. **直播加速**：将直播流通过 CDN 分发到多个节点上，用户可以从就近的节点访问，实现了低延迟、高并发的在线直播。
1. **全站加速**：通过 CDN 对整个网站的内容进行加速，从而提高网站的访问速度和性能，减少服务器负载。

#### 负载均衡是什么？是如何实现的？

负载均衡是指在网络服务中，将网络请求分摊到多个服务器资源上，以达到优化资源利用、提高系统性能、提高可用性、增加系统的伸缩性等目的的一种技术手段。它通过在服务器之间平衡负载来消除单点故障，增加并发处理能力，提高整个系统的性能和可用性。

负载均衡器是实现负载均衡的核心组件，它可以根据负载均衡算法将请求分发给后端多个服务器。常见的负载均衡算法包括：轮询（Round Robin）、最少连接（Least Connections）、IP hash 等等。

#### 懒加载的概念？懒加载的实现原理？

懒加载是一种延迟加载的技术，即在需要用到某个对象时再去加载它，而不是在一开始就加载所有的对象。这种技术可以提高页面的加载速度和性能，减轻服务器的压力，节约流量，并增加用户体验度。懒加载通常通过重写对象的 getter 方法来实现，当系统或者开发者调用对象的 getter 方法时，再去加载对象。下面是懒加载的一些实现原理和方法：

- React 懒加载：React 的懒加载可以使用 React.lazy 和 Suspense 来实现。React.lazy 函数可以接受一个函数作为参数，这个函数需要动态地调用 import()函数并返回一个动态加载的组件。Suspense 组件可以包裹需要懒加载的组件，并且在组件加载完成之前渲染 fallback 组件。这样，在需要渲染懒加载组件时，React 会自动地异步加载并渲染这个组件。具体实现可以参考以下代码：

```
import React, { Suspense } from 'react';
const OtherComponent = React.lazy(() => import('./OtherComponent'));
function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

JavaScript 懒加载：JavaScript 的懒加载可以使用动态创建 script 标签来实现。具体实现可以参考以下代码：

```
function import(url) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    const tempGlobal = "__tempModuleLoadingVariable" + Math.random().toString(32).substring(2);
    script.type = "module";
    script.textContent = `import * as m from "${url}"; window.${tempGlobal} = m;`;
    script.onload = () => {
      resolve(window[tempGlobal]);
      delete window[tempGlobal];
      script.remove();
    };
    script.onerror = () => {
      reject(new Error("Failed to load module script with URL " + url));
      delete window[tempGlobal];
      script.remove();
    };
    document.documentElement.appendChild(script);
  });
}
```

图片懒加载：图片懒加载可以通过将图片的 src 属性设置为一个占位符，然后在滚动到图片所在区域时再将 src 属性设置为真实的图片地址来实现。

#### 预加载是什么？懒加载和预加载的区别？

预加载是指提前加载需要使用的资源，如图片、视频、音频等，以便在用户需要访问时可以直接从本地缓存中渲染，减少加载时间和服务器压力。懒加载则是一种延迟加载技术，即在需要使用资源时才进行加载，可以减少页面加载时间和请求数，对服务器前端有一定的缓解压力作用。

以下是懒加载和预加载的区别：

1. **行为本质**：懒加载是迟缓甚至不加载资源，而预加载是提前加载资源。
1. **对服务器前端的压力**：懒加载可以减少请求数或延迟请求数，对服务器前端有一定的缓解压力作用，而预加载则会增加服务器前端压力。
1. **实现方式**：懒加载通常有两种实现方式，一种是纯粹的延迟加载，使用 setTimeout 或 setInterval 进行加载延迟；另一种是条件加载，符合某些条件或触发某些事件才开始异步下载。预加载的实现方式可以使用 CSS 和 JavaScript、仅使用 JavaScript 或使用 Ajax 来实现。

实现预加载的方法有多种，包括使用 CSS 和 JavaScript、仅使用 JavaScript 或使用 Ajax。以下是一些预加载的实现方式：

1. **使用 CSS 和 JavaScript**：通过 CSS 设置需要预加载的资源，然后使用 JavaScript 动态加载资源，可以使用 Image 对象或创建 link 和 script 标签来实现。
1. **仅使用 JavaScript**：使用 JavaScript 创建 Image 对象并设置 src 属性来实现预加载，也可以使用 XMLHttpRequest 对象来预加载资源。
1. **使用 Ajax**：使用 XMLHttpRequest 对象来异步加载资源，可以将资源存储在缓存中，以便在需要使用时可以直接从缓存中获取。

总之，懒加载和预加载都是优化网页性能的技术，可以减少页面加载时间和服务器压力。选择使用哪种技术取决于具体情况，如需要加载的资源类型、访问量等。

#### 什么是回流？哪些会导致回流？怎么避免回流？

回流（Reflow）是指浏览器为了重新渲染部分或全部文档而进行的一系列计算过程。回流通常会造成页面的重绘，是性能问题的重要来源。

以下情况会导致回流：

1. 改变窗口大小（resize）
1. 改变字体大小
1. 添加或删除样式表
1. 内容的改变，比如用户在 input 框中输入文字
1. 元素的位置、尺寸、内容等发生改变
1. 初始化渲染时

为了避免回流，可以采取以下措施：

1. 避免频繁操作样式：将需要改变的样式放到一起进行修改，或者一次性更改元素的 class
1. 使用 translate 替代 top、left 等属性
1. 使用 flexbox 进行布局
1. 避免使用 table 进行布局
1. 将动画效果应用到 position 属性为 fixed 或 absolute 的元素上
1. 避免使用 document.write，因为它会触发文档的重新解析和渲染

以上措施并不能完全避免回流，但可以有效减少回流的次数和影响。

#### 什么是重绘？哪些会导致重绘？怎么避免重绘？

重绘是指元素样式的改变并不影响其在文档流中的位置，重新渲染元素的可视化外观。重绘的成本比回流低，因为它不涉及元素位置和布局的计算，但仍然会影响性能。

会导致重绘的操作包括修改元素的颜色、背景、边框、阴影、文字的样式等。以下是常见的导致重绘的操作：

1. 修改元素样式，如 color、background、visibility、opacity 等；
1. 修改元素的 className；
1. 修改元素内文本的样式；
1. 添加或移除样式表；
1. 浏览器窗口大小变化。

避免重绘的方法包括：

1. 尽量避免在 DOM 树中的多个节点频繁交换位置，这会导致重排和重绘；
1. 避免频繁读取布局信息，这会迫使浏览器强制重新计算布局；
1. 避免在 JavaScript 中频繁读取或设置样式，因为这会强制浏览器进行样式计算和布局；
1. 如果需要多次进行样式修改，可以先将元素的 display 属性设置为 none，然后再进行样式修改，最后再将 display 属性设置为原来的值，这样可以将多次修改合并为一次；
1. 避免使用 CSS 表达式，因为它们会在每次重绘时都被重新计算。

#### 对节流与防抖的理解？

防抖和节流都是控制函数执行频率的方法，但是它们的实现方式和应用场景不同。具体来说：

**防抖**

- 防抖的目的是防止函数在短时间内被频繁调用，以避免重复执行或者浪费资源。
- 在防抖的实现中，当触发事件后，会设置一个定时器，等待一段时间后再执行函数。如果在等待时间内再次触发事件，就会清除之前的定时器并重新设置一个新的定时器。如果在等待时间内没有再次触发事件，则会执行函数。
- 适用于需要等待用户停止操作后才进行操作的场景，比如搜索框输入查询，用户输入过程中，只有输入完成后才会触发查询，避免了用户每次输入都进行一次查询。

下面是一个使用防抖函数的例子：

```
function debounce(func, delay = 1000, immediate = false) {
  let timer = null;
  return function () {
    if (timer) {
      clearTimeout(timer);
    }
    if (immediate && !timer) {
      func.apply(this, arguments);
    }
    timer = setTimeout(() => {
      func.apply(this, arguments);
    }, delay);
  };
}
```

**节流**

节流的目的是控制函数在一定时间内只能执行一次，以减少函数的执行次数，避免重复执行或者浪费资源。

- 在节流的实现中，当触发事件后，会设置一个定时器，等待一段时间后再执行函数。如果在等待时间内再次触发事件，就会忽略该事件，直到执行完之前的函数后，才会重新设置定时器。
- 适用于需要控制函数执行频率的场景，比如滚动事件、窗口大小变化事件等。

下面是一个使用节流函数的例子：

```
function throttle(fn, delay = 1000) {
  let lastTime = 0;
  return function () {
    let _this = this;
    let _arguments = arguments;
    let now = new Date().getTime();
    if (now - lastTime > delay) {
      fn.apply(_this, _arguments);
      lastTime = now;
    }
  };
}
```

#### 对虚拟列表的理解？实现原理？

虚拟列表是一种长列表优化解决方案，它只呈现列表的可见部分。虚拟列表不是呈现列表中的所有项目，而是根据用户的滚动位置计算要呈现的项目。该技术用于通过减少在任何给定时间需要呈现的数据量来提高具有数千或数百万项的长列表的性能。下面是虚拟列表的工作原理：

- 列表的可见区域称为可见区域。
- 可滚动区域是可滚动的区域。
- 虚拟列表基于当前滚动位置计算可见区域的开始和结束索引。
- 然后将可见区域的数据呈现到页面上。
- 然后，虚拟列表计算渲染数据的开始和结束偏移，并将其设置在列表上。

虚拟列表的实现包括以下步骤：

- 计算可见区域的起始索引。
- 计算可见区域的结束索引。
- 将可见区域的数据呈现到页面。
- 计算渲染数据的起始偏移量，并将其设置在列表上。
- 计算渲染数据的结束偏移，并将其设置在列表上。

要实现虚拟列表，需要定义 startIndex 和 endIndex 等变量。这些变量用于根据用户的滚动位置确定要渲染的项目。此外，startOffset 和 endOffset 变量用于设置列表的正确滚动位置。

使用虚拟列表有几个好处，包括：

- **改进的性能**：仅渲染列表的可见部分可以显著减少需要渲染的数据量，从而加快加载时间和平滑滚动。
- **减少内存使用**：由于只渲染列表的可见部分，因此渲染列表所需的内存量减少。
- **改进的用户体验**：通过仅呈现列表的可见部分，用户可以快速浏览长列表，而不会出现延迟或延迟。

总的来说，虚拟列表是一种强大的技术，可以优化包含数千或数百万项的长列表。通过仅呈现列表的可见部分，虚拟列表可以显著提高性能，减少内存使用，并提供更好的用户体验。

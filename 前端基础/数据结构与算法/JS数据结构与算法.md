<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-19 14:37:28
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-19 19:43:20
 * @Description: JS 数据结构
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\前端基础\数据结构与算法\JS数据结构与算法.md
-->

> 参考书籍：《学习 JavaScript 数据结构与算法》

### 一、算法复杂度（大 O 表示法）

#### 时间复杂度

#### 空间复杂度

### 二、数据结构

#### JS 有哪些数据结构？

JavaScript 有以下几种内置的数据结构：

1. **数组（Array）**：一组**有序的**数据集合，可以通过索引来访问其中的元素，数组长度可变。
1. **栈（Stack）**：一种**后进先出**（LIFO）的数据结构，只能在栈顶进行插入和删除操作。
1. **队列（Queue）**：一种**先进先出**（FIFO）的数据结构，只能在队列尾进行插入操作，在队列头进行删除操作。
   - **双端队列**：（简写：deque 或者 double-ended queue）是一种允许同时从前端和后端添加和移除元素的特殊队列
1. **链表（LinkedList）**：由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，可以插入、删除任意位置的元素。
   - **双向链表**：在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。
   - **循环链表**：循环链表和链表的区别在于，最后一个元素指向下一个元素的指针不是引用 undefined，而是指向第一个元素。
   - **有序链表**：指保持元素有序的链表结构。
1. **集合（Set）**：一组**无序的、唯一的**数据集合，其中的元素不能重复，可以进行去重操作。
   - **并集**：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。
   - **交集**：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。
   - **差集**：对于给定的两个集合，返回一个包含两个集合中所有存在于第一个集合且不存在于第二个集合的元素的新集合。
   - **子集**：验证一个给定集合是否是另一集合的子集。
1. **字典（Map）**：（字典也叫映射、符号表或关联数组）一组**键值对的无序集合**，其中的键和值可以是任意类型，键不能重复，可以根据键来访问对应的值。
   - **散列表（Hash table）**：是一种数据结构，它通过将关键码值映射到表中的某个位置来访问记录，方便加快查找速度。散列表在 JavaScript 中也称为哈希表，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。
1. **树（Tree）**：由**节点组成的层级结构**，每个节点有一个父节点和零个或多个子节点，用于表示具有层级关系的数据结构，如文件系统、DOM 树等。
   - **二叉树（Binary Tree）**：二叉树是一种树形结构，它的特点是每个节点最多只有两个分支节点，一棵二叉树通常由根节点、分支节点、叶子节点组成。而每个分支节点也常常被称作为一棵子树。
   - **二叉搜索树（BST）**：是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。
   - **自平衡树（AVL）**：自平衡二叉搜索树，任何一个节点左右两侧子树的高度之差最多为 1。添加或移除节点时，AVL 树会可能尝试转换为完全树。
   - **红黑树**：红黑树也是一个自平衡二叉搜索树，红黑树的时间复杂度为 O(logn)，因此可以用于处理大量数据的查找、排序等问题。与 AVL 树相比，红黑树的旋转操作较少，因此在插入和删除操作比较频繁的场景下，红黑树的性能更优。
1. **堆（Heap）**：通常情况下，堆指的是**二叉堆**，堆是一种特殊的完全二叉树。所有的节点都大于等于（最大堆）或最小等于（最小堆）它的子节点。
1. **图（Graph）**：由**节点和边组成的网络结构**，节点之间通过边相连，可以用来表示各种复杂的关系，如社交网络、地图等。

### 三、算法思想

#### JavaScript 常见算法思想

JavaScript 中常见的算法思想包括：

1. **分治算法**：将问题划分成更小的子问题，然后递归解决这些子问题，最后合并结果。
1. **贪心算法**：在每一步选择中，选择最优解，从而得到全局最优解。
1. **动态规划**：将复杂问题分解成小问题，通过子问题的解来推导出原问题的解，从而得到最优解。
1. **回溯算法**：从问题的解空间树上搜索所有可能的解，直到找到最终解。
1. **模拟算法**：通过模拟真实世界的过程，来解决问题。
1. **排序算法**：将一组数据按照特定规则进行排序的算法，包括冒泡排序、快速排序、归并排序等。
1. **查找算法**：在一组数据中查找指定元素的算法，包括线性查找、二分查找等。
1. **图算法**：解决图结构中的问题的算法，包括深度优先搜索、广度优先搜索等。

以上算法思想可以用来解决各种计算问题，包括数据处理、图像处理、人工智能等。在前端开发中，例如在编写算法和数据结构的库、处理大量数据、优化性能等方面，这些算法思想也会有所应用。

### 四、常见算法

#### JS 算法题有哪些？

JavaScript 算法题种类繁多，可以根据具体的分类方式进行划分。下面列举几种比较常见的 JS 算法题：

1. **排序算法**：对一组数据按照某种规则进行排序，如冒泡排序、快速排序、归并排序、插入排序、选择排序、堆排序等；
1. **查找算法**：在一组数据中查找指定元素，如二分查找、线性查找、哈希查找等；
1. **字符串算法**：如字符串匹配、字符串翻转、字符串排序等；
1. **字符串匹配算法**：在字符串中查找子串的算法，包括朴素算法、KMP 算法、Boyer-Moore 算法等。
1. **数组算法**：如数组去重、数组求交集、并集、差集、最大子数组和、最大公共子序列等；
1. **树算法**：如二叉树的遍历、搜索二叉树、红黑树等；
1. **图算法**：如最短路径、最小生成树、拓扑排序等；
1. **图论算法**：解决图结构中的问题的算法，包括深度优先搜索、广度优先搜索、最短路径算法、最小生成树算法等。
1. **动态规划算法**：将复杂问题分解成小问题，通过子问题的解来推导出原问题的解，从而得到最优解。如最长公共子序列、背包问题等。
1. **递归算法**：函数内部调用自身的算法，可以用于解决问题的分治思想。
1. **贪心算法**：在每一步选择中，选择最优解，从而得到全局最优解。

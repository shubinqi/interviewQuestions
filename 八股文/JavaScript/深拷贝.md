<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-01 22:32:58
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-04 01:18:56
 * @Description: 八股文：浅拷贝、深拷贝（3题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\JavaScript\深拷贝.md
-->

#### 浅拷贝、深拷贝是什么？如何实现深拷贝？

浅拷贝和深拷贝都是对象的复制方式。浅拷贝是指只复制对象的第一层属性，而深拷贝是指递归地复制所有属性，包括对象中的对象。

实现深拷贝的方法有很多种，下面列举几种常用的方法：

1. 使用 JSON 序列化和反序列化

使用 JSON.stringify() 将对象序列化为字符串，再使用 JSON.parse() 将字符串反序列化为新对象。这种方法只能序列化对象的可枚举属性，并且不能处理函数和循环引用的情况。

```
const obj = {a: 1, b: {c: 2}};
const newObj = JSON.parse(JSON.stringify(obj));
```

2. 递归地复制对象

使用递归函数遍历对象的所有属性，复制每个属性。这种方法可以处理函数和循环引用的情况。

```
function deepClone(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  const newObj = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      newObj[key] = deepClone(obj[key]);
    }
  }
  return newObj;
}
const obj = {a: 1, b: {c: 2}};
const newObj = deepClone(obj);
```

3. 使用第三方库（Lodash）

可以使用第三方库如 Lodash 的 \_.cloneDeep() 方法来实现深拷贝。

```
const _ = require('lodash');
const obj = {a: 1, b: {c: 2}};
const newObj = _.cloneDeep(obj);
```

需要注意的是，深拷贝会消耗较多的资源和时间，应该根据实际情况选择合适的方法。

#### 递归实现深拷贝如何解决循环引用的情况？

在递归实现深拷贝时，如果出现循环引用，会导致死循环，需要在代码中加以处理。常见的解决方式有两种：

引入一个“已拷贝”集合，在递归过程中，判断当前对象是否已经被拷贝过，如果是，则直接返回该对象的拷贝，否则将该对象添加到“已拷贝”集合中，然后递归拷贝该对象的属性。这种方式能够解决循环引用的问题，但是需要额外的空间来存储“已拷贝”集合。

在拷贝过程中，对于已经拷贝过的对象，不再递归拷贝其属性，而是直接将其引用赋值给新的对象。这种方式不需要额外的空间来存储“已拷贝”集合，但是可能会导致拷贝后的对象出现属性共享的情况，因为新对象中的某个属性仍然引用着原对象中的同一个属性。

下面是第一种方式的示例代码：

```
function deepCopy(obj, copied = new Set()) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  if (copied.has(obj)) {
    return obj;
  }
  let copy = Array.isArray(obj) ? [] : {};
  copied.add(obj);
  for (let key in obj) {
    copy[key] = deepCopy(obj[key], copied);
  }
  return copy;
}
```

在调用 deepCopy() 函数时，可以不传第二个参数 copied，它会在递归过程中被初始化为空集合。例如：

```
let obj = {
  a: 1,
  b: {
    c: null,
    d: [1, 2],
  }
};
obj.b.c = obj.b;
let copy = deepCopy(obj);
console.log(copy.b.c === copy.b); // true
```

#### 说说你对递归函数的理解？

递归函数是指在函数内部调用自身的一种函数，通常适用于需要重复执行相同或类似操作的场景。递归函数在代码实现上比较简单，可以让代码更加优雅、简洁，并且对于一些算法问题，使用递归函数更加符合数学模型，更容易理解。

递归函数通常分为两种，一种是“线性递归”，另一种是“尾递归”。

线性递归是指在递归过程中每次都需要重新分配内存空间，存储函数的参数、返回地址等信息，这样的递归函数容易导致内存溢出，影响程序的性能。而尾递归则是一种特殊的递归方式，它是指递归函数在递归过程中不会再产生新的函数调用，因此不会出现内存溢出的问题。

递归函数的实现需要注意的问题包括：

1. 定义好递归的结束条件，否则递归可能会无限执行下去；
1. 递归函数的参数和返回值应该明确，避免出现不必要的错误；
1. 对于线性递归函数，需要考虑如何优化代码，避免内存溢出。

在实际开发中，递归函数可以用于实现一些树形结构的数据操作，例如文件目录、网站导航、组织结构等，也可以用于解决一些算法问题，例如斐波那契数列、汉诺塔等。

#### 什么是线性递归？有什么作用？

JS 线性递归是指递归函数的调用过程为一条直线，即每个递归函数只会直接调用一次自己，不会出现多个递归调用的情况。

作用：

- **解决数学问题**：线性递归可以用于求解数学问题，例如求阶乘。
- **代码简化**：线性递归可以用于简化代码，减少重复代码。例如，如果需要对一个多层嵌套的对象进行深度遍历，可以使用递归函数来简化代码，避免重复编写相同的代码。
- **代码复杂度控制**：线性递归可以控制代码复杂度，使得代码更加清晰易懂。例如，如果需要对一个多层嵌套的对象进行深度遍历，可以使用递归函数来控制代码复杂度，避免代码过于复杂难以维护。

需要注意的是，在使用线性递归时需要加上退出条件，否则可能会导致栈溢出错误。同时，递归需要避免出现死循环，为了确保递归正确工作，递归程序应该包含基本情况，基本情况用于保证程序调用及时返回，不在继续递归，保证了程序可终止。

示例代码：

```
function sum(n) {
  if (n <= 0) {
    return 0;
  } else {
    return n + sum(n - 1);
  }
}

console.log(sum(5)); // 输出15
```

这个例子中，sum 函数实现了对 1 到 n 的整数求和。当 n 小于等于 0 时，返回 0；当 n 大于 0 时，调用自身计算 n-1 到 1 的整数和，并将结果加上 n 返回。这里的递归调用只出现了一次，符合 JS 线性递归的定义。

#### 什么是尾递归？有什么作用？

尾递归是指在函数的最后一步操作是调用自身函数的递归形式。在尾递归中，递归调用是函数的最后一条语句，因此不会再次创建新的堆栈帧，从而减少了堆栈帧的数量，避免了爆栈的情况，提高了代码的执行效率。

尾递归的作用主要在于优化递归算法的性能，能够有效地减少堆栈的开销。在一些需要大量递归计算的场景中，使用尾递归可以大大减少堆栈的使用，从而提高程序的运行效率。

需要注意的是，并非所有的递归函数都可以转化为尾递归形式。只有在满足尾递归的条件下，才能够使用尾递归来优化算法性能。

示例代码：

```
function sum(n, acc = 0) {
  if (n === 0) {
    return acc;
  }
  return sum(n - 1, acc + n);
}

console.log(sum(100000)); // 5000050000
```

在这个示例中，函数 sum 通过尾递归的方式计算了从 1 到 n 的和。在每次递归调用时，都将累加器（acc）加上当前的值（n），并将 n 减 1 作为下一次递归的参数。当 n 等于 0 时，直接返回累加器的值。由于这个递归调用是整个函数体中的最后一步操作，并且返回值不需要再进行额外的操作，因此这是一个尾递归。

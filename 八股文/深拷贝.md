<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-01 22:32:58
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-02 00:52:08
 * @Description: 八股文：浅拷贝、深拷贝
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\深拷贝.md
-->

#### 浅拷贝、深拷贝是什么？如何实现深拷贝？

浅拷贝和深拷贝都是对象的复制方式。浅拷贝是指只复制对象的第一层属性，而深拷贝是指递归地复制所有属性，包括对象中的对象。

实现深拷贝的方法有很多种，下面列举几种常用的方法：

1. 使用 JSON 序列化和反序列化

使用 JSON.stringify() 将对象序列化为字符串，再使用 JSON.parse() 将字符串反序列化为新对象。这种方法只能序列化对象的可枚举属性，并且不能处理函数和循环引用的情况。

```
const obj = {a: 1, b: {c: 2}};
const newObj = JSON.parse(JSON.stringify(obj));
```

2. 递归地复制对象

使用递归函数遍历对象的所有属性，复制每个属性。这种方法可以处理函数和循环引用的情况。

```
function deepClone(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  const newObj = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      newObj[key] = deepClone(obj[key]);
    }
  }
  return newObj;
}
const obj = {a: 1, b: {c: 2}};
const newObj = deepClone(obj);
```

3. 使用第三方库（Lodash）

可以使用第三方库如 Lodash 的 \_.cloneDeep() 方法来实现深拷贝。

```
const _ = require('lodash');
const obj = {a: 1, b: {c: 2}};
const newObj = _.cloneDeep(obj);
```

需要注意的是，深拷贝会消耗较多的资源和时间，应该根据实际情况选择合适的方法。

#### 递归实现深拷贝如何解决循环引用的情况？

在递归实现深拷贝时，如果出现循环引用，会导致死循环，需要在代码中加以处理。常见的解决方式有两种：

引入一个“已拷贝”集合，在递归过程中，判断当前对象是否已经被拷贝过，如果是，则直接返回该对象的拷贝，否则将该对象添加到“已拷贝”集合中，然后递归拷贝该对象的属性。这种方式能够解决循环引用的问题，但是需要额外的空间来存储“已拷贝”集合。

在拷贝过程中，对于已经拷贝过的对象，不再递归拷贝其属性，而是直接将其引用赋值给新的对象。这种方式不需要额外的空间来存储“已拷贝”集合，但是可能会导致拷贝后的对象出现属性共享的情况，因为新对象中的某个属性仍然引用着原对象中的同一个属性。

下面是第一种方式的示例代码：

```
function deepCopy(obj, copied = new Set()) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  if (copied.has(obj)) {
    return obj;
  }
  let copy = Array.isArray(obj) ? [] : {};
  copied.add(obj);
  for (let key in obj) {
    copy[key] = deepCopy(obj[key], copied);
  }
  return copy;
}
```

在调用 deepCopy() 函数时，可以不传第二个参数 copied，它会在递归过程中被初始化为空集合。例如：

```
let obj = {
  a: 1,
  b: {
    c: null,
    d: [1, 2],
  }
};
obj.b.c = obj.b;
let copy = deepCopy(obj);
console.log(copy.b.c === copy.b); // true
```

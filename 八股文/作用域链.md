<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-01 22:31:44
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-02 00:58:16
 * @Description: 八股文：作用域、作用域链（7题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\作用域链.md
-->

#### 讲一下作用域？什么是作用域链？

作用域（Scope）指的是变量或函数的可访问范围，JavaScript 中有全局作用域和函数作用域两种类型的作用域。

1. **全局作用域**：指的是在函数外部声明的变量和函数，它们可以被代码中的任何地方访问到。
1. **函数作用域**：指的是在函数内部声明的变量和函数，它们只能在函数内部访问到，外部无法访问。
1. **块级作用域**：指的是使用花括号 {} 包围起来的代码块，例如 if 语句、for 循环、函数等。

作用域链（Scope Chain）指的是当 JavaScript 引擎在查找变量的值时，从当前作用域开始查找，如果在当前作用域中找不到该变量，则会一层层向上查找，直到找到该变量或查找到全局作用域为止。

当 JavaScript 引擎在执行函数时，会创建一个执行上下文（Execution Context），每个执行上下文都有一个与之对应的作用域链。在创建执行上下文时，JavaScript 引擎会将当前作用域链保存在执行上下文的内部属性中，当查找变量时，JavaScript 引擎会先查找当前执行上下文的变量，如果找不到则会向上查找作用域链中的上一级执行上下文，直到找到为止。

作用域链的顶端是全局执行上下文，作用域链的底端是当前函数执行上下文，函数执行上下文中的变量和函数可以通过作用域链访问到全局作用域中的变量和函数，但全局作用域中的变量和函数无法通过作用域链访问到函数执行上下文中的变量和函数。

#### 如何延长作用域链？

在 JavaScript 中，作用域链的长度取决于函数定义的位置和嵌套关系。作用域链由当前执行上下文的变量对象（包括该函数的参数、内部变量和函数）和其外部环境的变量对象（如全局环境变量对象）组成。作用域链的主要作用是用于查找变量和函数的值。

在函数内部通过 with 语句或者 eval() 函数创建新的变量对象时，也会延长作用域链。使用 with 语句时，将指定对象添加到作用域链的前端。使用 eval() 函数时，将传入的字符串解析为 JavaScript 代码并将其执行，并将其变量和函数定义添加到当前作用域链的前端。

需要注意的是，with 语句和 eval() 函数会降低代码的可读性和可维护性，同时也可能引发安全问题，应该尽量避免使用。

#### 作用域链应用场景有哪些？

作用域链是 JavaScript 中非常重要的概念，它决定了变量和函数在代码中的可见性和可访问性。下面介绍一些作用域链应用场景：

1. **实现闭包**：在 JavaScript 中，函数内部可以访问外部函数的变量和函数，这就是闭包。闭包的实现依赖于作用域链，即内部函数可以访问外部函数的变量是因为内部函数的作用域链包含了外部函数的作用域链。
1. **模块化开发**：作用域链可以用来实现模块化开发，即将代码拆分成多个模块，每个模块都有自己的作用域，不同模块之间的变量和函数不会互相干扰。这可以通过立即执行函数表达式（IIFE）等方式实现。
1. **变量查找**：作用域链可以决定变量的查找顺序。当需要查找某个变量时，JavaScript 引擎会沿着作用域链依次查找变量，直到找到该变量或者到达全局作用域。这个过程是自动进行的，我们不需要显式地指定变量的查找路径。
1. **作用域隔离**：作用域链可以实现作用域隔离，即在不同的作用域中定义同名变量不会相互影响。这可以有效地避免变量名冲突的问题。

总之，作用域链是 JavaScript 中非常重要的概念，可以用来实现许多复杂的功能，也是理解 JavaScript 闭包和模块化开发的基础。

#### 变量提升与函数提升的区别？

变量提升和函数提升都是 JavaScript 中的预解析机制。它们的区别在于变量提升只会将声明提升至作用域的顶部，而不会将赋值也提升至作用域的顶部，而函数提升则会将整个函数声明提升至作用域的顶部。

具体来说，变量提升会将变量声明提升至作用域的顶部，但是不会将变量的赋值也提升。例如：

```
console.log(a);  // undefined
var a = 1;
```

上述代码中，变量 a 在 console.log 语句之前被声明了，但是由于变量提升只将声明提升至作用域的顶部，所以此时 a 的值为 undefined。

而函数提升会将整个函数声明提升至作用域的顶部，包括函数名和函数体。例如：

```
foo();  // "Hello, world!"
function foo() {
  console.log("Hello, world!");
}
```

上述代码中，函数 foo 的声明被提升至作用域的顶部，因此在函数调用之前就已经可以访问到它。

需要注意的是，使用 let 和 const 声明的变量不会存在变量提升，因此不能在声明之前使用这些变量。同时，使用 const 声明的常量必须在声明时就赋值，否则会报错。

### var、let 和 const 的区别？

在 ES6 中，引入了 let 和 const 关键字，可以用来定义块级作用域的变量，也就是只在当前代码块内有效，出了代码块就无法访问。与之不同的是，使用 var 关键字定义的变量是函数作用域的，如果在函数内部使用 var 定义的变量，那么这个变量在整个函数内部都是可访问的。

总结一下 var、let、const 的区别：

1. var 定义的变量是函数作用域的，而 let 和 const 定义的变量是块级作用域的。
1. var 定义的变量可以被重新赋值和重新声明，而 let 定义的变量可以被重新赋值但不能被重新声明，const 定义的变量既不能被重新赋值也不能被重新声明。
1. 在全局作用域下使用 let 和 const 定义变量时不会将其挂在全局对象下，而 var 定义的变量会。

需要注意的是，由于 JavaScript 中存在变量提升的机制，在使用 var 声明变量时，变量会被提升到函数作用域的顶部，因此在变量声明之前访问该变量不会报错，但是其值为 undefined。而使用 let 和 const 声明变量时，则不存在变量提升的情况，访问未声明的变量会直接报错。

#### 说说 JS 中的预解析？

JavaScript 中的预解析（Hoisting）是指在代码执行之前，JavaScript 引擎会先扫描整个代码，将所有的变量声明和函数声明提前到当前作用域的顶部，这个过程就称为预解析。

在预解析过程中，变量声明会被提前到作用域顶部，但是变量的赋值不会被提前。函数声明会被整个提前，包括函数体内的代码。而函数表达式只会被提前函数名，不会被提前函数体内的代码。

例如：

```
console.log(a); // undefined
var a = 1;

console.log(b); // Uncaught ReferenceError: b is not defined
let b = 2;

foo(); // "hello"
function foo() {
  console.log("hello");
}

bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log("world");
};
```

在上面的代码中，变量 a 被预解析并被赋予了默认值 undefined，所以第一次 console.log 输出 undefined，而变量 b 是用 let 声明的，它不存在变量提升，所以在声明之前访问会报错。

函数 foo() 是函数声明，因此整个函数会被提前，所以在函数声明之前调用函数不会报错。而变量 bar 是一个函数表达式，只有函数名被提前，函数体内的代码不会被提前，所以在声明之前调用会报错。

因此，了解 JavaScript 中的预解析对于理解变量作用域和函数作用域都是非常重要的。

<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-03 14:41:29
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-04 01:42:14
 * @Description: 八股文：常见的 JavaScript 排序算法（3题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\算法\常见排序算法.md
-->

#### 常见的 JavaScript 排序算法有哪些？

常见的 JavaScript 排序算法包括：

1. **冒泡排序**：通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。时间复杂度最好为 O(n)，最坏和平均为 O(n²)。
2. **选择排序**：每次从未排序的数组中选出最小的元素，放在已排序的末尾。时间复杂度为 O(n²)。
3. **插入排序**：将未排序的元素依次插入到已排序的合适位置。时间复杂度最好为 O(n)，最坏和平均为 O(n²)。
4. **快速排序**：选择一个枢纽元素，将数组分为两部分，一部分比枢纽元素小，一部分比枢纽元素大，然后递归地对两部分进行快速排序。时间复杂度最好为 O(nlogn)，最坏为 O(n²)，平均为 O(nlogn)。
5. **归并排序**：将数组分为两部分，对每部分进行归并排序，然后将两部分合并。时间复杂度为 O(nlogn)。
6. **桶排序**：将数组中的元素按照一定的规则划分到不同的桶中，然后对每个桶中的元素进行排序，最后将所有桶中的元素合并。时间复杂度为 O(n)。
7. **基数排序**：根据元素的每一位进行排序，先按照最低位排序，再按照次低位排序，直到按照最高位排序。时间复杂度为 O(d(n+r))，其中 d 为位数，r 为基数。
8. **计数排序**：统计每个元素出现的次数，然后按照元素的大小顺序输出。时间复杂度为 O(n+k)，其中 k 为元素的范围。
9. **希尔排序**：将数组分为若干个子数组，对每个子数组进行插入排序，然后逐步减少子数组的规模。时间复杂度为 O(nlogn)。
10. **堆排序**：将数组构建成一个大根堆或小根堆，然后依次将堆顶元素与最后一个元素进行交换，再调整堆。时间复杂度为 O(nlogn)。

#### 写一下冒泡排序算法？

冒泡排序是一种简单直观的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。下面是 JS 实现冒泡排序的步骤和代码实现：

1. 遍历数组，比较相邻两个元素的大小，如果前一个元素大于后一个元素，则交换两个元素的位置。
2. 重复步骤 1，直到没有元素需要交换为止。

在 JS 中实现冒泡排序，可以通过以下代码：

```
var arr = [3, 10, 6, 3, 2];

for (var i = 0; i < arr.length - 1; i++) {
    for (var j = 0; j < arr.length - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            var num = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = num;
        }
    }
}

console.log(arr); // [2, 3, 3, 6, 10]
```

#### 写一下快速排序算法？

快速排序是一种常用的排序算法，适用于大数据量的排序。下面是 JS 实现快速排序算法的详细步骤和代码实现：

步骤：

1. 首先选择一个基准数，一般选择第一个数或最后一个数。
2. 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比基准数小，另一部分所有数据都比基准数大。
3. 然后再按此方法对这两部分数据分别进行快速排序，递归进行该过程。
4. 重复第 2 步和第 3 步，直到数组中的所有数据都排好序。

代码实现：

```
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr.splice(pivotIndex, 1)[0];
  const left = [];
  const right = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot], quickSort(right));
}
```

这段代码首先判断数组长度是否小于等于 1，如果是，则直接返回该数组。然后以数组中间的数作为基准数，将数组分成左右两部分。接下来，对左右两部分递归进行快速排序，最终将左右两部分和基准数拼接起来返回。

<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-05 15:18:20
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-09 14:42:24
 * @Description: 八股文重点速记0305
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\速记.md
-->

### 一、HTML

#### 语义化

- **语义化**：具有特定含义的标签，使得文档更易于理解、维护和访问。
- **作用**：提高页面的可读性和可访问性，利于 SEO。
- **常用标签**：&lt;header&gt; 头部、&lt;nav&gt; 导航、&lt;article&gt; 文章、&lt;aside&gt; 侧边栏、&lt;section&gt; 章节等。

#### Canvas 和 SVG 区别

- **Canvas**：基于**像素**的位图渲染技术。
- **SVG**：基于**矢量**的图形渲染技术。
- **区别**：Canvas 使用 JavaScript API 绘制位图，而 SVG 则使用 XML 标记绘制矢量图形。Canvas 是渲染像素，SVG 是渲染矢量图形。Canvas 用于绘制复杂的动态图形和游戏，SVG 用于静态图形绘制和数据可视化。
- **位图**：由一系列像素点构成的图像，放大会失真。
- **矢量**：通过直线、曲线、矩形、多边形等基本几何形状来描述图像，可以无限放大而不失真。

### 二、CSS

#### BFC（Block Formatting Context）

- **BFC**：块级格式化上下文。
- **产生条件**：根元素、浮动元素、绝对定位元素、Flex 弹性盒子、行内块元素、表格单元格等。
- **特点**：垂直方向排列，不会重叠。
- **作用**：清除浮动、防止 margin 重叠。

#### IFC（Inline Formatting Context）

- **IFC**：内联格式化上下文。
- **产生条件**：块级元素中仅包含内联级别元素。（例如 p 标签里面的 span 标签）
- **特点**：按照从左到右的顺序排列，会换行，会自动调整大小。
- **场景**：水平居中、垂直居中、多列布局。

#### FFC（Flex Formatting Context）

- **FFC**：弹性格式化上下文。
- **产生条件**：display: flex 和 display: inline-flex。
- **特点**：弹性容器中的每一个子元素都是一个弹性项目。
- **场景**：弹性布局。

#### GFC（Grid Formatting Context）

- **GFC**：网格格式化上下文。
- **产生条件**：display: grid 和 display: inline-grid
- **特点**：。通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间
- **场景**：网格布局。

#### 盒模型

- **标准盒模型**：box-sizing: content-box; 盒子大小为 width + padding + border，此值为其默认值，其让元素维持 W3C 的标准。
- **IE 盒模型**：box-sizing: border-box; 盒子大小为 width，也就是说 padding 和 border 是包含到 width 里面。
- **区别**：在标准盒模型中，一个盒子的宽度由内容区域（content）的宽度（width）构成。而在 IE 盒模型中，一个盒子的宽度由内容区域、内边距和边框的宽度（width + padding + border）构成。

#### 回流（Reflow）

- **回流**：重新渲染部分或全部文档而进行的一系列计算过程。
- **导致回流**：初始化渲染时，浏览器窗口大小变化；改变字体大小；元素的位置、尺寸、内容等发生改变。
- **避免回流**：避免频繁操作样式；使用 flex 进行布局；避免使用 document.write。
- **概念**：回流必将引起重绘，重绘不一定会引起回流。

#### 重绘（Repaint）

- **重绘**：元素样式的改变并不影响其在文档流中的位置，重新渲染元素的可视化外观。
- **导致重绘**：修改元素颜色、背景、透明度等；修改文本样式；浏览器窗口大小变化。
- **避免重绘**：避免频繁读取布局信息，避免使用 CSS 表达式。

#### 清除浮动

- **方法一**：额外标签法（clear: both）
- **方法二**：父级添加 overflow 属性方法（overflow: hidden | auto）
- **方法三**：使用 after 伪元素清除浮动（.clearfix:after）
- **方法四**：使用 before 和 after 双伪元素清除浮动（.clearfix:before, .clearfix:after）
- **方法五**：父元素直接设置 display: table（display: table）

#### 水平垂直居中

- **方法一**：flex 布局（父级 justify-content: center 和 align-items: center 即可）
- **方法二**：absolute + transform（定位的上、左为 50%，translate 上、左负 50%）
- **方法三**：absolute + margin: auto（定位的上下左右为 0）
- **方法四**：table-cell（使用表格样式）
- **方法五**：absolute + 负 margin（定位的上、左为 50%，margin 的上、左负子元素的一半）

#### 常见布局

- **常见布局**：盒模型布局、浮动布局、定位布局、Flex 弹性布局、栅格布局

### 三、JavaScript

#### JavaScript

- **JavaScript**：JavaScript 是一种**动态、弱类型、基于事件驱动**的编程语言。它最初由 Brendan Eich 于 1995 年创建，作为浏览器中实现交互式用户界面的脚本语言。随着互联网的普及和 Web 应用程序的快速发展，JavaScript 已经成为一种重要的客户端脚本语言。

#### 数据类型

- **栈区**是用来存储函数的参数值、局部变量等在函数执行时需要分配的内存空间。它的特点是分配效率高，但空间较小，由系统自动分配和回收，具有后进先出（LIFO）的特点。
- **堆区**是动态分配内存的区域，用来存储对象、数组等数据。它的特点是空间较大，但分配效率较低。由于需要手动分配和回收内存，所以容易产生内存泄漏等问题。
- **基本数据类型**：（7 种，最后 2 种是 ES6 新增的）

1. **Number**：数值类型，包括整数和浮点数。
1. **String**：字符串类型。
1. **Boolean**：布尔类型，只有两个值：true 和 false。
1. **Null**：表示空值或空对象指针。
1. **Undefined**：表示未定义或不存在的值。
1. **Symbol**：表示唯一的标识符，通常用于对象属性的键值。
1. **BigInt**：用于表示大整数，可以处理超出 Number 类型表示范围的整数。

- **引用数据类型**：（1 种）

1. **Object**：表示一个复杂数据类型，可以存储多个键值对。

- **判断数据类型**：

1. **typeof**：可以判断除 null 外的 ES5 基本数据类型（对于函数类型会返回 "function"，而不是 "object"。对于 null 类型的值，typeof 会返回 "object"。）
2. **instanceof**：instanceof 运算符可以用来判断一个对象是否是某个构造函数（或者其原型链上）创建的实例，其语法为 obj instanceof constructor。如果 obj 是 constructor 的实例，则返回 true，否则返回 false。
3. **construter**：可以正确判断数据类型（如果创建一个对象并改变他的原型，就不能用 construter 判断类型了）
4. **Object.prototype.toString.call()**：Object.prototype.toString.call() 可以判断几乎所有 JavaScript 数据类型，包括基本数据类型和引用数据类型。它的原理是通过调用 Object.prototype.toString() 方法，返回一个格式为 [object Type] 的字符串，其中 Type 表示数据类型。

- **typeof**：可以判断基本数据类型除 null 外的，对于函数类型会返回 "function"，而不是 "object"。对于 null 类型的值，typeof 会返回 "object"。
- **instanceof**：instanceof 运算符可以用来判断一个对象是否是某个构造函数（或者其原型链上）创建的实例，其语法为 obj instanceof constructor。如果 obj 是 constructor 的实例，则返回 true，否则返回 false。
- **toString**：Object.prototype.toString.call()：可以正确判断对象的类型。
- **isNaN()**：isNaN 函数会尝试将其参数转换为数值类型，如果参数无法被转换为数值类型，则返回 true。这意味着对于非数值类型的参数，isNaN 函数会先尝试将其转换为数值类型，然后再进行判断。
- **Number.isNaN()**：Number.isNaN 函数不会尝试将其参数转换为数值类型。如果参数不是 NaN 值，Number.isNaN 函数会直接返回 false。

#### 数组

- **数组**：组是一个有序的数据集合，用于存储一组相关的数据。它是一种特殊的对象，可以通过整数下标访问和操作其中的元素。
- **判断数组类型**：

1. **Array.isArray()**
1. **Object.peototype.toString.call()**
1. **instanceof**
1. **Array.isPrototypeOf()**

- **改变原数组**：

1. **push()**：在数组末尾添加一个或多个元素。
1. **pop()**：删除并返回数组最后一个元素。
1. **shift()**：删除并返回数组的第一个元素。
1. **unshift()**：在数组开头添加一个或多个元素。
1. **splice()**：删除或替换数组的元素，可以在任何位置添加新元素。
1. **sort()**：对数组进行排序。
1. **reverse()**：将数组元素反转顺序。
1. **fill()**：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。
1. **copyWithin()**：在数组内部将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回修改后的数组。

- **数组遍历方法**：

1. **for** 循环：常规的 for 循环语句可以遍历数组元素，通过数组的 length 属性可以获取数组的长度。
2. **forEach** 方法：遍历数组元素，对每个元素执行回调函数。
3. **map** 方法：遍历数组元素，对每个元素执行回调函数，将返回值存入新的数组中。
4. **filter** 方法：遍历数组元素，对每个元素执行回调函数，根据返回值来过滤元素，将满足条件的元素存入新的数组中。
5. **reduce** 方法：遍历数组元素，对每个元素执行回调函数，将计算结果累加到一个累加器中，返回累加器的最终结果。
6. **every** 方法：遍历数组元素，对每个元素执行回调函数，当所有元素都满足条件时返回 true，否则返回 false。
7. **some** 方法：遍历数组元素，对每个元素执行回调函数，当任意一个元素满足条件时返回 true，否则返回 false。
8. **for...of** 循环：ES6 新增的语法，可以遍历数组元素。

- **Array.isArray()**：判断是否是数组类型。

#### 闭包

- **闭包**：闭包 = 函数 + 自由变量（红宝书：可以调用另一个函数作用域中变量的函数）。
- **优点**：不会污染全局作用域；让变量长期保存在内存中；对局部变量的间接访问。
- **缺点**：使用不当容易造成内存泄露；可能会导致性能问题。
- **使用场景**：节流、防抖、计数器、私有变量、模块化开发。

#### 原型

- **原型**：在 JavaScript 中，每个对象都有一个内部属性 **prototype**，通常称为“原型”，它引用另一个对象。

#### 原型链

- **原型链**：当我们访问一个对象的属性或方法时，JavaScript 引擎会先在对象自身中查找是否存在该属性或方法，如果没有找到，则会到对象的原型中查找，如果还没找到，会继续在原型的原型中查找，直到找到该属性或者找到原型链的末尾为止。
- **终点**：原型链的终点是 null，因为 Object.prototype 是所有对象的基类，而他的隐式原型为空。

#### 作用域链

- **作用域**：作用域（Scope）指的是变量或函数的可访问范围，JavaScript 中有全局作用域和函数作用域两种类型的作用域。
- **作用域链**：作用域链（Scope Chain）指的是当 JavaScript 引擎在查找变量的值时，从当前作用域开始查找，如果在当前作用域中找不到该变量，则会一层层向上查找，直到找到该变量或查找到全局作用域为止。

#### 深拷贝

- **浅拷贝**：只复制对象的第一层属性，复制的是对象的内存地址。
- **深拷贝**：递归地复制所有属性，包括对象中的对象。
- **区别**：浅拷贝会同步修改原对象，深拷贝不会。
- **实现深拷贝**：JSON.parse(JSON.stringify(obj)); 递归地复制对象；使用第三方库（Lodash）。

#### 节流

- **节流**：节流（Throttling）是一种限制函数的调用频率的方法。在一定时间间隔内，无论事件被触发了多少次，函数都只会执行第一次。
- **场景**：滚动加载、搜索框联想、提交按钮之类的。

#### 防抖

- **防抖**：防抖（debounce）是一种常用的 JavaScript 技术，可以在一定时间内多次触发同一个函数，只执行最后一次。
- **场景**：适用于某些需要频繁触发的事件，例如 resize、scroll、input 等。

#### ES6

- **ES6 新语法**：块级作用域（let、const）；箭头函数；解构赋值；模板字符串；函数默认参数；展开运算符；Promise；async/await；模块化；Symbol；BigInt；Map 和 WeakMap；Set 和 WeakSet；for...in；for...of；类；继承。
- **块级作用域**：使用 let 和 const 声明变量时可以创建块级作用域。
- **let、const**：let 声明变量，const 声明常量，都不会有变量提升，不会添加全局属性，不能重复声明，会造成暂时性死区。（const 必须设置初始值）
- **箭头函数**：使用 => 语法定义匿名函数。
- **解构赋值**：可以从数组和对象中提取值并将其赋给变量。
- **模板字符串**：使用反引号 `` 来创建多行字符串，并且可以在字符串中插入表达式。
- **函数默认参数**：定义函数参数的默认值。
- **展开运算符**：使用 ... 语法来展开数组或对象。
- **Map**：字典，一种新的集合类型，为 ECMAScript 语言带来了真正的键/值存储机制，键可以是任何类型，不仅限于字符串或 Symbol 类型。
- **WeakMap**：是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。
- **Set**：集合，一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。
- **WeakSet**：它只能存储对象，且只持有对象的弱引用。
- **Promise**：处理异步操作的一种方法，可以通过链式调用来组合多个异步操作。
- **async/await**：是 Promise 的语法糖，让异步操作更直观。
- **模块化**：使用 import 和 export 关键字来导入和导出模块。
- **Symbol**：标识符，引入了一种新的原始数据类型，用于创建唯一的标识符。
- **BigInt**：大整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。
- **for...in**：用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。
- **for...of**：用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。
- **类**：使用 class 关键字来定义类。
- **继承**：使用 extends 关键字来定义继承。

#### Promise

- **Promise**：Promise 是一种用于异步编程的 JavaScript 对象，它可以更好地管理和组织异步操作。Promise 提供了一种解决 Ajax 回调地狱（Callback Hell）的方案，使得异步代码可以更加清晰和易于维护。
- **Ajax**：Ajax 是一种跨域解决方案，用于实现客户端与服务器端的异步通信效果，实现页面的局部刷新。
- **回调地狱**：回调地狱是指在异步编程中，多次嵌套回调函数所形成的代码结构，使得代码难以阅读和维护。
- **Promise 状态**：Pending（等待状态）、Fulfilled（已完成状态）和 Rejected（已失败状态）
- **常用 API**：Promise.then()；Promise.catch()；Promise.finally()；Promise.all()；Promise.race()；Promise.any()；

#### JS 垃圾回收机制

- **垃圾回收机制**：JS 的垃圾回收机制是为了防止内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。
- **标记清除**：标记清除是一种常用的垃圾回收方法，它的原理是通过标记那些不再使用的对象，然后进行清除。垃圾收集器会从根节点开始遍历所有对象，标记所有能够从根节点访问到的对象，然后将未被标记的对象进行清除。
- **引用计数**：引用计数是另一种垃圾回收方法，它的原理是通过记录每个对象被引用的次数，当引用次数为 0 时就可以将该对象进行清除。引用计数方法的优点是可以很快地回收那些被引用次数为 0 的对象，但是它也存在一些例如循环引用的问题。

### 四、VUE

#### Vue 基础

- **Vue**：是用于构建用户界面的渐进式 JavaScript 框架。
- **SPA 单页应用**：SPA（Single Page Application）即单页面应用，是一种 Web 应用程序的架构方式，它通过 Ajax 或 WebSockets 等技术，在一个单页面中动态加载内容并更新页面，使得 Web 应用具有更加流畅的用户体验。
- **MPA 多页应用**：MPA（Multiple Page Application）是由多个完整页面构成的应用。MPA 应用的页面跳转方式是从一个页面跳转到另一个新的页面。MPA 的优点是首屏加载速度快，SEO 效果好；缺点是页面切换慢。
- **MVC**：分为三个部分：模型、视图和控制器。模型用于存储应用程序数据，视图用于展示数据，而控制器用于管理模型和视图之间的交互。
- **MVVM**：分为三个部分：模型、视图和视图模型。模型和视图在 MVVM 中的作用与 MVC 相同。视图模型是一个中介层，它将视图和模型之间的交互进行解耦。视图模型将数据从模型层转换为视图层，同时也处理视图层的交互事件，将其转换为模型层能够处理的操作。
- **computed**：
- **watch**：
- **slot**：
- **mixin**：
- **nextTick**：
- **$set**：

#### Vue 2.X 和 Vue 3.X 区别？

1. **监测机制的改变**：从 Object.defineProperty 改为 Proxy
2. **根节点的改变**：Vue3 支持碎片(Fragments)，Vue3 中组件的 template 下可以包含多个根节点，而 Vue2 中组件的 template 下只能包含一个根节点。
3. **API 模式的改变**：Vue2 使用选项式 API（Options API），Vue3 组合式 API（Composition API）
4. **建立响应式数据的方式**：Vue2 把数据放入 data 属性中，Vue3 引入 ref 或 reactive 实现
5. **生命周期钩子**：可以用 setup () 替代 beforeCreate 和 created；组件卸载阶段生命周期的变更；增加了 onRenderTracked 和 onRenderTriggred 生命周期
6. **Diff 算法的改变**：Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff，Vue3 使用最长递增子序列优化了对比流程
7. **v-if 和 v-for**：在 Vue2 中，v-for 优先于 v-if 生效，每次都要先渲染才会进行条件判断，会带来性能的浪费。最好不要把 v-if 和 v-for 同时用在一个元素上。而在 Vue2 中，v-if 优先于 v-for 生效，把 v-if 和 v-for 同时用在一个元素上 Vue 会给我们报警告。
8. **去除了过滤器**；Vue 3 中 filter 被去除，我们可以通过 计算属性实现。
9. **支持 TypeScript**；Vue 3 对 TypeScript 的支持更加友好。

#### Vue 2.X 响应式原理 definePeroperty

- **definePeroperty**：Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
- **数据劫持**：数据劫持是指在访问对象的属性时，拦截并对这个属性的读取和写入进行某些额外的操作，从而可以实现一些高级特性，例如数据绑定、观察者模式等。
- **发布者-订阅者模式**：发布者-订阅者模式（Publisher-Subscriber Pattern）是一种设计模式，用于解决应用程序中的事件处理问题。它包括两个主要组件：发布者和订阅者。发布者发布事件，订阅者订阅事件并在事件发生时得到通知并执行相应的处理。这个模式可以使应用程序组件之间的通信变得更加灵活。
- **优点**：兼容性好，可以用于实现 Vue2.x 的响应式数据原理
- **缺点**：通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染。（Vue 内部通过重写函数的方式解决了这个问题）

#### Vue 3.X 响应式原理 Proxy

- **Proxy**：Proxy 是 ECMAScript 6 新增的一个特性，它可以拦截对象的各种操作，比如读取属性、写入属性、删除属性、函数调用等。使用 Proxy 可以实现数据劫持，从而实现响应式数据。
- **优点**：可以拦截对象的各种操作，比如读取属性、写入属性、删除属性、函数调用等；不需要再单独对数组的一些方法进行重写。
- **缺点**：Proxy 是 ES6 的新特性，不兼容旧版本的浏览器，需要使用 polyfill 或者转译器进行转换。

#### 虚拟 DOM

- **虚拟 DOM**：从本质上来说，Virtual Dom（虚拟 DOM） 是一个 JavaScript 对象，通过对象的方式来表示 DOM 结构。将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次 DOM 修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改 DOM 的重绘重排次数，提高渲染性能。
- **优点**：保证性能下限，在不进行手动优化的情况下，提供过得去的性能；可以很方便的跨平台操作，比如服务端渲染、uniapp。
- **缺点**：首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。

#### Vue 2.X Diff 算法

- **Diff 算法**：Diff 算法是 虚拟 DOM（Virtual DOM） 的核心算法，用于比较两个 虚拟 DOM（Virtual DOM） 树的差异，并将差异应用到实际 DOM 上，从而实现高效的视图更新。
- **基本原理**：

1. 如果新旧节点**不是同一个节点**，则直接将新节点替换旧节点，结束这个节点的对比，开始对比下一个节点。
1. 如果新旧节点**是同一个节点**，那么对比它们的子节点：
   a. 如果新旧节点都没有子节点，则认为它们是相等的，不需要更新。
   b. 如果新节点没有子节点，但是旧节点有子节点，则将旧节点的子节点全部删除。
   c. 如果旧节点没有子节点，但是新节点有子节点，则将新节点的子节点全部添加到旧节点中。
   d. 如果新旧节点都有子节点，则递归调用 Diff 算法，对比它们的子节点。
1. 对比新旧节点的**属性**是否有变化，如果有变化，则更新属性。
1. 对比新旧节点的**子节点列表**是否有变化，如果有变化，则更新子节点列表。

- **特点**：

1. **分层 Diff**：不考虑跨层级移动节点，让新旧两个 VDOM 树的比对无需循环递归（复杂度大幅优化，直接下降一个数量级的首要条件）。这个前提也是 Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
1. 组件的 Type（Tagname）不一致，原因是绝大多数情况拥有相同 type 的两个组件将会生成相似的树形结构，拥有不同 type 的两个组件将会生成不同的树形结构，所以 Type 不一致可以放弃继续比对。
1. 列表组件的 Key 不一致，旧树中无新 Key 或反之。毕竟 key 是元素的身份 id，能直接对应上是否是同一个节点。
1. 对触发了 getter/setter 的组件进行 diff，精准减少 diff 范围。

#### Vue 3.X Diff 算法

- **Diff 算法**：Diff 算法是 虚拟 DOM（Virtual DOM） 的核心算法，用于比较两个 虚拟 DOM（Virtual DOM） 树的差异，并将差异应用到实际 DOM 上，从而实现高效的视图更新。
- **基本原理**：

1. Virtual DOM 是对真实 DOM 的一种抽象描述，通过比较虚拟节点的差异来最小化更新操作，从而提高性能。
2. Vue 3.X 中，编译器会在动态标签末尾加上 PatchFlag，用来标记动态属性的类型。当 PatchFlag 的值大于 0 时，表示该元素可以被优化生成或更新；当 PatchFlag 的值小于 0 时，表示该元素需要进行 full diff，即递归遍历 VNode tree 的比较更新过程。
3. 在更新已渲染过的元素列表时，Vue 默认采用“就地复用”策略，即不移动 DOM 元素来匹配数据项的顺序，而是复用已被渲染过的每个元素，并确保它在特定索引下显示已被渲染过的每个元素。
4. 在对比新旧节点时，Vue 3.X 采用**双端比较**的方式，即从新旧节点的两端开始比较，如果相同则移动索引，如果不同则停止比较。具体来说，Diff 算法的基本原理包括以下步骤：
   a. 初始化索引 i、e1 和 e2，分别表示当前比较的位置，旧节点的最后一个节点索引和新节点的最后一个节点索引。
   b. 从新旧节点的两端开始比较，如果新旧节点类型和 key 都相同，则执行 patch 操作，否则停止比较。
   c. 如果新节点已经遍历完成，而旧节点还没有遍历完成，则将剩余的旧节点删除。
   d. 如果旧节点已经遍历完成，而新节点还没有遍历完成，则将剩余的新节点添加。
   e. 如果新旧节点都没有遍历完成，则进入最核心的 diff 算法，即递归遍历 VNode tree 的比较更新过程。

**特点**：

Vue 3.X 中的 Diff 算法基于**双端比较**的思想，通过 **PatchFlag** 标记动态属性（动静分离）的类型，最小化更新操作，从而提高性能。

#### Vue 2.X 生命周期

- **Vue 的生命周期**：从 Vue 实例创建、挂载、更新到销毁的期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！

1. **beforeCreate**：实例刚在内存中被创建出来，此时还没有初始化好 data 和 methods 属性，因此无法访问这两个属性，可以在这里做一些全局的配置，如注册全局组件、全局指令等。
1. **created**：实例已经在内存中创建完成，此时 data 和 methods 都已经被初始化好了，可以访问这两个属性，如果想和后端交互，可以在这里使用 axios 等库。
1. **beforeMount**：此时模板已经在内存中编译完成，但尚未挂载到页面中。
1. **mounted**：此时模板已经挂载到页面中，用户可以看到渲染好的页面。可以在这里做一些初始化页面的操作，如获取页面中的 DOM 元素、对获取的数据进行进一步处理等。
1. **beforeUpdate**：状态更新之前触发，此时可以对状态进行更新之前的操作，如更新状态之前获取页面的 scrollTop 等。
1. **updated**：状态更新之后触发，此时可以对更新后的状态进行操作，如操作更新后的 DOM 元素等。
1. **beforeDestroy**：实例在销毁之前调用，可以在这里进行善后工作，如清除定时器、清除非 Vue 插件等。
1. **destroyed**：实例已经销毁，这个时候就不能再访问实例中的 data 和 methods 属性了，可以在这里进行垃圾回收等工作。

通常在 created、beforeMount、mounted 钩子函数中请求异步数据，因为此时实例已经被创建完成，data 和 methods 属性也已经被初始化好了，可以访问这两个属性。

- **Keep-alive** 生命周期如下：

1. **activated**：页面第一次进入的时候，钩子触发的顺序是 created->mounted->activated
1. **deactivated**: 页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated

#### Vue 3.X 生命周期

- **生命周期**：从 Vue 实例创建、挂载、更新到销毁的期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！

1. **创建**（Creation）- 在组件实例被创建时调用（beforeCreate 和 created 可以被 setup 方法取代）
2. **挂载**（Mounting）- 在组件挂载到 DOM 时调用
3. **更新**（Updating）- 当响应式数据发生改变时调用
4. **销毁**（Unmounting）- 在组件被销毁时调用

详细生命周期

1. **beforeCreate** - 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用
1. **created** - 在实例创建完成后被立即调用。在这一步，实例已完成以下配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
1. **beforeMount** - 在挂载开始之前被调用：相关的 render 函数首次被调用。
1. **mounted** - el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。
1. **beforeUpdate** - 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改数据，但不会触发附加的重渲染过程。
1. **updated** - 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。
1. **beforeUnmount** - 在卸载开始之前调用。在这一步，实例仍然完全可用。
1. **unmounted** - 在组件实例被卸载和销毁之前调用。在这一步，实例完全被解除了对其自身属性和方法的引用。
1. **errorCaptured** – 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。

当使用组合式 API 时生命周期改变如下，我们可以在 setup 方法中访问的 API 生命周期钩子有 9 个选项

1. beforeCreate -> 使用 setup()
1. created -> 使用 setup()
1. beforeMount -> onBeforeMount
1. mounted -> onMounted
1. beforeUpdate -> onBeforeUpdate
1. updated -> onUpdated
1. beforeDestroy -> onBeforeUnmount
1. destroyed -> onUnmounted
1. errorCaptured -> onErrorCaptured
1. activated -> onActivated – 被 keep-alive 缓存的组件激活时调用。
1. deactivated -> onDeactivated – 被 keep-alive 缓存的组件停用时调用。

#### Vue 2.X 组件通信

- **父子组件通信**：props 和 $emit；$parent / $children (父子)
- **祖孙组件通信**：$attrs / $listeners（祖孙）
- **兄弟组件通信**：ref / $refs （父子，兄弟）
- **跨级组件通信**：全局事件总线（Event Bus $emit / $on）
- **任意组件通信**：VueX；全局事件总线（Event Bus $emit / $on）

#### Vue 3.X 组件通信

- **父子组件通信**：props 和 $emit；父组件 v-model 传值，子组件 modelValue 接收，$emit；多个 v-model；父 ref 获取，子 defineExpose 传递。
- **祖孙组件通信**：provide 传递 / inject 接收。
- **跨级组件通信**：全局事件总线（Event Bus $emit / $on）。
- **任意组件通信**：VueX；Pinia；全局事件总线（Event Bus $emit / $on）。
<!-- - **兄弟组件通信**：ref / $refs （父子，兄弟）。 -->

#### 封装组件

- **组件封装原则**：高内聚、低耦合、可重用
- **组件包含**：定义 template 模板、定义需要传递的参数 Props、定义组件数据 data、定义组件样式、定义组件方法和回调函数 $emit、注册组件（Vue.component()）
- **使用组件**：如果是大部分页面要使用的，注册组件到 Vue 上，如果是少部分页面使用到，可以通过导入使用。

#### 封装 axios

- **封装全局参数**：全局的请求头、响应头等信息，减少重复代码的编写。
- **封装请求拦截器**：可以在请求发送之前对请求进行处理，例如在请求头中添加 token 等信息。
- **封装响应拦截器**：可以在响应返回后对响应进行处理，例如判断响应状态码是否正确，统一处理错误信息等。
- **封装公共方法**：可以将一些通用的请求方法进行封装，例如 get、post、put、delete 等方法。

#### 封装 keep-alive

- **keep-alive**：&lt;keep-alive&gt; 是 Vue.js 中的一个抽象组件，它的主要作用是缓存组件。在一个有大量组件需要频繁切换的页面中，使用 &lt;keep-alive&gt; 可以提高页面的性能，减少因频繁创建和销毁组件而产生的性能消耗。
- **封装方法**：在 Vue 的路由配置中添加 meta 字段，然后在 App.vue 中通过 v-if 进行调用

#### 状态管理 VueX

- **VueX**：VueX 是一个状态管理模式，它是基于 Vue.js 构建的，用于在大型单页面应用程序中管理应用程序的状态。VueX 提供了一个中央存储库，用于保存所有组件的状态，并通过显式的方式将状态传递给组件，从而使组件之间的通信更加容易和高效。
- **核心属性**：store（存储数据的地方）；state（表示状态的数据）；mutation（操作状态的方法，每个 mutation 都有一个字符串类型的事件类型和一个回调函数。）；action（异步操作状态的方法，每个 action 都有一个字符串类型的事件类型和一个回调函数。）；module（模块化管理 state、getters、mutations 和 actions）；getter（类似计算属性，用于从 state 中派生出一些状态。）；
- **store**：状态对象，即存储数据的地方。在 Vue 组件中，可以通过 $store.state 访问到它。
- **state**：表示状态的数据。它是一个响应式对象，用来保存我们的数据。它可以通过直接赋值的方式进行修改。
- **mutation**：操作状态的方法，每个 mutation 都有一个字符串类型的事件类型和一个回调函数。在回调函数中，可以通过第一个参数访问到 state 对象，并通过第二个参数（payload）传递数据。Mutation 必须是同步函数。
- **action**：异步操作状态的方法，每个 action 都有一个字符串类型的事件类型和一个回调函数。回调函数可以接收一个与 store 实例具有相同方法和属性的 context 对象，但不能直接修改 state，需要通过 commit 方法来触发 mutation。Action 可以返回一个 Promise 对象。
- **module**：模块化管理 state、getters、mutations 和 actions。可以将 store 分割成不同的模块，每个模块可以拥有自己的 state、getters、mutations、actions 和子模块。模块内部的 action、mutation 和 getter 等方法仍然注册在全局命名空间下，但 state 却是模块的局部状态，而不是全局状态。
- **getter**：类似计算属性，用于从 state 中派生出一些状态。Getters 可以访问 state 中的属性，也可以接收其他 getters 作为第二个参数。

#### 状态管理 Pinia

- **Pinia**：Pinia 是一个状态管理库
- **核心属性**：store（存储数据的地方）；state（表示状态的数据）；action（表示操作数据，可以执行同步、异步操作）；getter（表示计算属性）。
- **store**：表示状态的存储。它包含了所有状态，例如数据、方法等等。在使用 Pinia 的时候，我们需要定义一个 store，然后把这个 store 暴露出去。
- **state**：表示状态的数据。它是一个响应式对象，用来保存我们的数据。它可以通过直接赋值的方式进行修改。
- **action**：表示同步、异步操作。它们通常用来执行一些异步的操作，例如获取数据等等。在执行异步操作之前，我们可以在 action 中执行一些同步操作，例如修改 state 中的数据。
- **getter**：表示计算属性。它们的作用是根据 store 中的数据，动态地计算出一个值。这些计算属性通常用来派生数据。

#### 路由 Vue-Router

- **Vue 路由**：Vue 路由是 Vue.js 官方提供的一种实现前端页面跳转、刷新、回退等页面管理的机制。它通过监听 URL 变化，匹配路由规则并展示相应的组件，实现了单页应用（SPA）的前端路由功能。
- **Hash**：在 URL 中使用 # 符号来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载。hash 值的改变只会引起浏览器滚动条位置的改变。
- **History**：使用 HTML5 提供的新特性，改变浏览器地址栏的 URL，不会带有 # 符号。当 URL 改变时，页面会重新加载。需要后端支持。
- **切换路由**：通过路由文件里的 mode 进行切换。
- **query**：query 则用于传递可选参数，通常在路由跳转时携带，刷新页面不会丢失，通过\$route.query 获取。
- **params**：params 用于传递必须参数，通常用于动态路由，刷新页面会丢失，通过\$route.params 获取。
- **route**：表示当前的路由信息，包含当前路由的路径、参数、查询参数等信息。
- **router**：表示路由实例，用于实现路由的跳转、监听等功能。
- **路由钩子函数**：

1. **beforeEach**: 在路由跳转之前调用，可以用来做用户权限验证或全局路由拦截等操作。
1. **beforeResolve**: 在路由解析之前调用，在组件被解析之后调用（几乎不使用）。
1. **afterEach**: 在路由跳转完成后调用，可以用来做页面访问统计等操作。
1. **beforeEnter**：在路由进入之前调用。
1. **beforeRouteEnter**: 在路由进入之前调用，但是此时组件实例还未被创建，所以无法访问 this，通常用来做异步数据加载等操作。
1. **beforeRouteUpdate**: 在路由参数更新时调用，可以在此处做异步数据加载等操作。
1. **beforeRouteLeave**: 在离开当前路由时调用，可以用来做页面离开前的数据保存或用户确认等操作。

#### 权限管理

- **路由拦截**：路由拦截是指在路由跳转时，根据用户的角色或权限，判断该用户是否有权访问该路由。可以在路由配置文件中设置 meta 属性，用来存储该路由的访问权限信息，然后在路由跳转前，通过路由守卫进行权限验证，如果没有权限，则跳转到指定的页面。
- **菜单权限**：解析后端返回来的菜单树，如果页面有按钮权限，在 meta 中存放按钮权限、页面 title 等信息；最后存放到 sessionStorage 中。
- **动态渲染**：动态渲染是指根据用户的角色或权限，动态生成页面内容，例如隐藏某些按钮或链接。
- **按钮权限**：可以在组件中通过 v-if 或 v-show 指令根据用户的角色或权限控制组件的显示或隐藏。

#### Vue-Cli

- **Vue-Cli**：Vue-Cli 是一个官方提供的脚手架工具，用于快速搭建 Vue.js 项目。它基于 Node.js 和 Webpack，并提供了诸如 ESLint、Babel、Vue 插件、单元测试、集成测试等工具，使开发者可以轻松地搭建 Vue.js 项目，并快速进入开发阶段。Vue-Cli 提供了一套完整的命令行工具，可以方便地初始化、开发、构建和测试 Vue.js 应用。
- **特点**：快速搭建项目；完善的开发工具；自定义配置；易于维护。

#### Webpack

- **Webpack**：Webpack 可以将 JavaScript、CSS、HTML、图片、字体等各种类型的资源打包成静态资源，并通过模块化的方式进行管理和加载。它支持常用的模块化规范，如 CommonJS、AMD、ES6 模块等，同时还支持插件机制，可以扩展其功能。
- **优点**：支持各种类型的文件打包；支持代码分割和懒加载；支持插件扩展；支持开发和生产环境的不同配置。
- **缺点**：学习成本较高；配置复杂；打包时间较长。
- **打包速度优化**：使用 HappyPack 将 Loader 转化为多进程打包；移除不必要的 Loader 和 Plugin；定义打包文件范围。
- **构建速度优化**：尽量减少 Webpack 的编译范围；配置 Webpack 的 mode 为 production 模式，开启代码压缩等优化。
- **减少打包体积**：Tree Shaking 清除代码中未使用的代码；使用 Webpack 的压缩插件，如 TerserPlugin、UglifyJsPlugin。
- **优化前端性能**：Tree-shaking 清除代码中未使用的代码；使用 Webpack 的 Bundle Analyzer 等插件来分析构建结果。

#### Vite

- **Vite**：Vite 是一种基于原生 ES 模块导入的 Web 开发构建工具，它旨在提供快速的开发体验和更快的构建速度。
- **优点**：快速的启动和热更新；只需对需要修改的文件进行编译，构建速度更快；开发过程中不需要编译，使用浏览器原生支持的 ESM 特性进行开发，修改代码后浏览器会自动更新。
- **缺点**：目前只支持开发阶段，生产环境需要借助其他工具进行打包；社区还不够完善。
- **和 Webpack 区别**：
- **应用场景**：Vite 更适合于小型、中型项目的快速开发，而 Webpack 更适合于大型项目和复杂项目的优化和定制。

1. **构建速度**：Webpack 在打包时需要对整个项目进行分析和打包，构建速度相对较慢，而 Vite 采用了 ESM 原生支持的方式进行开发，因此只需对需要修改的文件进行编译，构建速度更快。
1. **开发体验**：Webpack 需要在开发过程中进行编译打包，每次修改代码需要重新编译，而 Vite 在开发过程中不需要编译，使用浏览器原生支持的 ESM 特性进行开发，修改代码后浏览器会自动更新，因此开发体验更加优秀。
1. **集成度**：Webpack 提供了更多的插件和 Loader，可以完成更多的任务，例如图片压缩、字体处理、代码拆分等等。而 Vite 的插件相对较少，但它可以集成 Rollup 和 Webpack。
1. **生态环境**：Webpack 已经成为了主流的前端构建工具，具有更加完善的生态环境和更丰富的社区支持，而 Vite 还处于发展阶段，生态环境相对较小，但它获得了 Vue.js 官方的支持，并且在 Vue.js 3 中作为默认构建工具。

### 五、计算机网络

#### TCP 三次握手四次挥手

- **三次握手**：在 TCP 通信开始前，需要先进行三次握手来建立连接：

1. **第一次握手**（SYN）：客户端向服务器发送 SYN 报文，其中包含一个随机序列号 X，表示客户端准备连接服务器。
1. **第二次握手**（SYN+ACK）：服务器收到 SYN 报文之后，向客户端发送 SYN+ACK 报文，其中包含了确认号 ACK=X+1，表示服务器已经接收到客户端的请求，可以建立连接。
1. **第三次握手**（ACK）：客户端收到 SYN+ACK 报文之后，向服务器发送 ACK 报文，其中包含确认号 ACK=X+1，表示客户端已经接收到了服务器的确认，连接建立成功。

- **为什么三次**：通过三次握手的过程，可以确保客户端和服务器之间的通信是可靠的，包括：

1. 确定了双方的发送和接收能力正常，可以进行数据传输；
1. 确保客户端和服务器都能收到对方的消息，避免了因网络原因造成的消息丢失问题；
1. 防止已经失效的连接请求报文段突然又传送到了服务端，因而产生错误。

- **四次挥手**：在 TCP 通信结束后，需要进行四次挥手来断开连接：

1. **第一次挥手**（FIN）：客户端向服务器发送 FIN 报文，表示客户端已经不会再发送数据了。
1. **第二次挥手**（ACK）：服务器收到 FIN 报文之后，向客户端发送 ACK 报文，表示服务器已经接收到了客户端的请求，但是还有数据需要传输。
1. **第三次挥手**（FIN）：服务器传输完数据之后，向客户端发送 FIN 报文，表示服务器已经不会再发送数据了。
1. **第四次挥手**（ACK）：客户端收到 FIN 报文之后，向服务器发送 ACK 报文，表示客户端已经接收到了服务器的请求，可以断开连接。

- **为什么四次**：四次挥手是为了保证数据的可靠传输，防止因为网络延迟等原因导致的数据丢失或者重复。如果只使用三次挥手，服务端可能无法知道客户端是否已经收到了最后一个数据包。因此，四次挥手可以保证双方都能够知道对方已经完成了关闭操作。

#### HTTP

- **HTTP/0.9**：是 HTTP 的第一个版本，于 1991 年发布，只支持 GET 方法，没有头部信息和状态码，数据传输采用纯文本方式。
- **HTTP/1.0**：于 1996 年发布，支持多种请求方法，引入了头部信息、状态码、缓存等概念，并且支持基本的安全机制，如通过 HTTPS 进行加密通信。
- **HTTP/1.1**：于 1999 年发布，是 HTTP 的主流版本，引入了持久连接（keep-alive）、分块传输编码（chunked）、管道化请求（pipelining）等功能，显著提高了网络传输效率。
- **HTTP/2**：于 2015 年发布，是 HTTP 的最新版本，采用二进制格式传输数据，支持多路复用（multiplexing）、头部压缩（header compression）、服务器推送（server push）等功能，进一步提高了网络传输效率。
- **HTTP/3**：于 2020 年发布，是基于 QUIC 协议的 HTTP 版本，采用 UDP 协议进行数据传输，解决了 TCP 协议的拥塞控制和队头阻塞等问题，提高了网络传输效率。
- **队头堵塞**：队头阻塞是指在 HTTP/1.1 中，如果某个请求占用了连接的带宽，在其响应之前，后续的所有请求都必须等待，造成了阻塞的效果。
- **多路复用**：在 HTTP/2 中，多路复用可以解决 HTTP 级别的队头阻塞
- **HTTPS**：HTTPS 是一种透过计算机网络进行安全通信的传输协议，经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包，提供对网站服务器的身份认证，保护交换数据的隐私与完整性，因此 HTTPS 比 HTTP 更加安全。
- **SSL/TLS 协议**：HTTPS 采用 SSL/TLS 协议来对传输的数据进行加密，防止被窃听、篡改或者伪造。TLS 目前的最新版本是 TLS 1.3。
- **数字证书**：为了验证服务器的身份和防止中间人攻击，服务器需要使用数字证书。数字证书包含了一些基本信息，如证书颁发机构、证书有效期、服务器公钥等。浏览器使用数字证书验证服务器的身份，并根据证书中的公钥来进行数据的加密。
- **对称加密和非对称加密**：HTTPS 采用对称加密和非对称加密相结合的方式来对数据进行加密。首先使用非对称加密算法进行身份认证和密钥协商，然后使用对称加密算法对数据进行加密。因为对称加密算法的运算速度较快，所以在传输数据时使用对称加密算法可以提高传输效率。
- **HTTPS 证书的过期和吊销**：HTTPS 证书会设置有效期，一般为 1 年或 2 年，过期后需要重新申请。如果证书被攻击者盗用，证书的发行机构可以吊销证书，从而避免攻击者继续使用该证书进行攻击。
- **对称加密算法**：使用相同的密钥进行加密和解密，加密和解密的速度较快，但是密钥的传输安全性较低；密钥长度通常较短，一般为 128 位或 256 位；适用于对大量数据进行加密和解密，
- **非对称加密算法**：使用一对公钥和私钥进行加密和解密，密钥的传输安全性较高，但是加密和解密的速度较慢；密钥长度一般为 1024 位或 2048 位，甚至更长；对少量数据进行加密和解密，例如密码、证书等。

#### 前端安全

- **XSS**：即**跨站脚本攻击**。攻击者通过注入恶意脚本代码来攻击用户浏览器，获取用户的敏感信息，如 cookie、session 等。
- **防御 XSS**：不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。
- **XSRF**：即**跨站请求伪造攻击**。攻击者通过引导用户进入恶意网站，来伪造用户的请求，对目标网站进行操作，如盗取用户信息、发表文章等。
- **防御 XSRF**：进行同源检测；使用 token 认证；对 Cookie 进行双重验证
- **点击劫持**：即点击劫持攻击。攻击者通过伪造页面将用户的点击操作劫持到恶意链接上，使得用户不知不觉地执行了攻击者的操作。
- **防御点击劫持**：可以采取措施来防范点击劫持，例如设置 X-Frame-Options 响应头、在页面中添加透明的 div 层等。
- **HTTP 劫持**：攻击者通过劫持 HTTP 请求，从而篡改 302 重定向，使用户访问恶意或钓鱼网站。
- **防御 HTTP 劫持**：开发者可以采取 HSTS 技术来防范 HTTP 劫持，通知浏览器禁止使用 HTTP 方式加载，自动将所有尝试使用 HTTP 的请求自动替换为 HTTPS 进行请求。

#### 状态码

- **1xx：信息状态码**，表示服务器已接受请求，需要请求者继续执行操作。
- **2xx：成功状态码**，表示请求已成功被服务器接收、理解、并接受。

1. **200 OK**：请求成功，服务器已经成功返回页面。
1. **201 Created**：请求成功，服务器已经成功创建新的资源。
1. **204 No Content**：请求成功，但没有返回任何内容。

- **3xx：重定向状态码**，表示客户端需要采取进一步的操作才能完成请求。

1. **301 Moved Permanently**：被请求的页面已经永久移动到新的位置，客户端应该使用新的 URI 重新请求。
1. **302 Found**：被请求的页面已经暂时移动到新的位置，客户端应该在将来的请求中使用这个相同的 URI。
1. **303 See Other**: 临时性重定向。与 302 有相同的功能，但是 303 明确要求客户端必须使用 GET 方法获取新的资源。
1. **304 Not Modified**：请求的页面没有被修改，可以使用缓存的版本。

- **4xx：客户端错误状态码**，表示客户端的请求有误。

1. **400 Bad Request**：请求失败，服务器无法理解请求。
1. **401 Unauthorized**：请求失败，客户端没有提供身份验证信息。
1. **403 Forbidden**：请求失败，客户端没有权限访问所请求的页面。
1. **404 Not Found**：请求失败，所请求的页面不存在。
1. **405 Method Not Allowed**：请求失败，请求中使用的 HTTP 方法不被服务器支持。
1. **408 Request Timeout**：请求超时，服务器没有及时响应。
1. **429 Too Many Requests**：请求过多，服务器拒绝处理请求。

- **5xx：服务器错误状态码**，表示服务器在处理请求时发生了错误。

1. **500 Internal Server Error**：请求失败，服务器遇到了一个错误。
1. **502 Bad Gateway**：表示服务器作为网关或代理角色时无法从上游服务器或其他资源获得响应，一般是上游服务器或其他资源无响应或者响应超时引起的。
1. **503 Service Unavailable**：请求失败，服务器暂时无法处理请求。

### 六、浏览器

#### 从输入 URL 到页面展示过程

- **过程概述**：解析 URL -> 缓存判断 -> DNS 解析 -> TCP 三次握手 -> （HTTPS 握手） -> 发送请求 -> 服务器处理请求并返回数据 -> 浏览器解析 HTML 页面并渲染页面 -> TCP 四次挥手
- **DNS 解析**：浏览器首先会检查本地 DNS 缓存，如果没有缓存则向本地 DNS 服务器发起请求，如果本地 DNS 服务器也没有缓存则会向根 DNS 服务器发起请求，根 DNS 服务器返回负责该域名的顶级 DNS 服务器地址，浏览器再向顶级 DNS 服务器发起请求，顶级 DNS 服务器返回该域名对应的 IP 地址。
- **TCP 三次握手**：浏览器使用 HTTP 协议与服务器建立 TCP 连接，建立连接需要三次握手。
- **发送请求**：浏览器向服务器发送请求，包括请求方法、URL、请求头等信息。
- **服务器处理请求并返回数据**：服务器接收到请求后，根据请求的 URL 和参数等信息进行处理，生成相应的 HTML 页面或其他资源文件，并通过 TCP 连接返回给浏览器。
- **浏览器解析 HTML 页面并渲染页面**：浏览器接收到服务器返回的 HTML 页面后，开始解析 HTML 标签和 CSS 样式，构建 DOM 树和 CSSOM 树，然后将两者组合成渲染树，并计算出每个节点的几何信息，最终通过 GPU 绘制页面。
- **TCP 四次挥手**：当浏览器完成页面的渲染后，会关闭 TCP 连接，释放资源。
- **HTTPS 握手**：由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法；服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书；客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验；服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。
- **三次握手**：客户端发起连接请求；服务器端确认连接请求，向客户端发送一个随机序号；客户端进入连接建立的状态，向服务器也发送一个 ACK 确认报文段。服务端接收到后，连接就建立了。三次握手验证了双方的收发功能是否正常。
- **四次挥手**：客户端向服务端发送连接释放请求；服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接，并进入 CLOSE_WAIT 状态；服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态；客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL 时间，若此时没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。
- **优化手段**：

1. 启用浏览器缓存机制，尽可能减少网络请求次数，缓存静态资源。
1. 优化 DNS 解析速度，比如采用 CDN、减少 DNS 查询次数等。
1. 减少 HTTP 请求次数，可以合并 CSS、JS 文件，压缩图片等。
1. 优化服务器响应速度，比如使用缓存、优化数据库查询等。
1. 使用 CDN 等加速服务，将静态资源存放在离用户较近的服务器上，提高资源加载速度。
1. 使用异步加载、懒加载等技术，优化页面加载速度。
1. 减少 JavaScript 的执行时间，尽量减少 DOM 操作和重绘/回流等开销。
1. 优化页面结构，减少 HTML、CSS、JavaScript 的代码量，提高页面渲染速度。
1. 优化图片等资源的大小和格式，减少网络传输开销。

#### 跨域

- **同源策略**：同源策略是浏览器的一种安全策略，它限制了一个源（协议、域名、端口）的文档或脚本如何能够与另一个源的资源进行交互。
- **跨域**：协议、域名、端口任意一个不同就是跨域，跨域（Cross-Origin）指的是在浏览器的同源策略下，一个网页无法请求另一个网页的资源，即浏览器禁止跨域请求。
- **解决跨域**：CORS 跨域资源共享，添加响应头；JSONP 动态插入一个 script 标签，请求一个带有参数的地址；配置代理；Nginx 代理。
- **项目跨域**：配置 Proxy 代理。
- **CORS**：CORS 跨域资源共享，设置响应头。简单请求 get，post，head 服务端设置，复杂请求双方都要设置。
- **CORS 优缺点**：优点：支持所有 HTTP 请求，缺点：需要服务器支持。
- **JSONP**：JSONP 是一种跨域解决方案，它利用 script 标签的跨域特性，通过动态创建 script 标签来向另一个域名下的服务器请求数据，并在返回数据时将数据作为参数传入一个回调函数中，以实现跨域访问数据。
- **JSONP 优缺点**：优点：兼容性好，缺点，只支持 GET 请求；只支持 HTTP 请求；请求错误不会返回状态码。
- **代理**：优点：兼容性好，缺点：需要额外的服务器资源

#### 异步编程

- **单线程**：JavaScript 语言的执行环境是“单线程”，也就是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。
- **异步编程**：异步编程是一种编程模式，它可以让程序在执行一些需要等待的任务（比如网络请求、文件读写、计时器等）时，不会阻塞主线程的执行，而是在后台进行处理，等待任务完成后再进行相应的处理。异步编程能够提高程序的性能和响应速度，使程序可以更好地利用 CPU 和 I/O 资源。
- **实现方式**：在 JavaScript 中，异步编程可以通过回调函数、Promise 和 async/await 等方式来实现。
- **发展史**：callback -> promise -> generator -> async+await。
- **Generator**：在 JavaScript 中，Generator 也是一种特殊类型的函数，可以像普通函数一样被调用，但是它可以通过 yield 关键字暂停函数的执行，并在需要时恢复执行。Generator 通常用于生成序列、迭代器或异步编程等场景。

#### 事件

- **常见事件**：click（鼠标单击）、mouseover（鼠标移入）、mouseout（鼠标移出）等。
- **绑定事件**：element.addEventListener('click', myFunction);
- **解绑事件**：element.removeEventListener('click', myFunction);
- **事件冒泡**：事件冒泡是指当一个元素触发了某个事件后，该事件会沿着 DOM 树向上传递直到根节点，途中经过的每个父级元素都会被同样触发该事件。比如，一个按钮被点击后，它的点击事件会先被该按钮处理，然后一层层向上冒泡，直到最外层的元素。
- **阻止事件冒泡**：event.stopPropagation()；在事件处理函数中返回 false。
- **事件捕获**：事件捕获是 DOM 事件的一种传播机制，在捕获阶段，事件从最外层的祖先节点向目标节点传播，直到达到目标节点。与事件冒泡不同，事件冒泡是从目标节点开始向祖先节点传播。
- **阻止事件捕获**：使用 event.stopPropagation() 方法来阻止事件传播。
- **异常捕获**：在 JavaScript 中，可以使用 try...catch 语句块来处理异常捕获。
- **事件委托**：事件委托是指将事件处理器添加到其父元素上，而不是直接添加到目标元素上。通过在父元素上捕获事件，然后根据事件的目标确定实际处理程序的方式，从而实现在子元素被添加、删除、移动时，不需要更新事件处理程序的目的。

#### 事件循环

- **事件循环**：简单地说，对于 JS 运行中的任务，JS 有一套处理收集，排队，执行的特殊机制，我们把这套处理机制称为事件循环（Event Loop）。
- **单线程**：JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
- **执行栈**：执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。
- **执行上下文**：执行上下文，又叫做执行环境（全局执行上下文、函数执行上下文、Eval 函数执行上下文）。
- **任务队列**：一个事件循环中，可以有一个或者多个任务队列（task queue），一个任务队列便是一系列有序任务（task）的集合。
- **同步任务**：同步任务是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务，当我们打开网站时，网站的渲染过程，比如元素的渲染，其实就是一个同步任务。
- **异步任务**：异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程，当我们打开网站时，像图片的加载，音乐的加载，其实就是一个异步任务。
- **宏任务**：script（整体代码）、setTimeout、setInterval、UI 交互事件等。
- **微任务**：Promise.then()、Promise.catch()、process.nextTick。

#### this 绑定

- **this**：在 JavaScript 中，this 是一个关键字，用来指向当前函数的上下文对象。this 的指向会根据函数的调用方式而变化。
- **this 绑定**：有四种常见绑定方式
  1. **默认绑定**：当函数直接调用时，this 指向全局对象（非严格模式）或 undefined（严格模式）。
  1. **隐式绑定**：当函数作为对象的方法调用时，this 指向该对象。
  1. **显示绑定**：当使用 call、apply 或 bind 方法时，可以显式指定函数的 this 指向。
  1. **new 绑定**：当使用 new 关键字调用构造函数时，this 指向新创建的对象。
- **修改 this 绑定**：在 JavaScript 中，有几种方法可以改变函数的 this 指向，包括 call()、apply()、bind() 和 使用变量保存 this 四种方式。
  1. **call()**：将函数中的 this 指向指定的对象，并立即执行函数。第一个参数是指定的对象，后续多个参数逗号隔开。
  1. **apply()**：将函数中的 this 指向指定的对象，并立即执行函数。第一个参数是指定的对象，后续多个参数使用数组或者类数组传递。
  1. **bind()**：它改变函数的 this 指向时不会立即执行函数，而是返回一个新的函数，需要调用返回的函数才能执行原来的函数。

#### 浏览器缓存机制

- **强缓存**：浏览器在第一次请求资源时，会先检查本地是否有缓存副本，如果有并且未过期，则直接使用缓存，不会向服务器发送请求，从而提高页面的访问速度。强制缓存可以通过设置 HTTP 响应头中的 Expires（过期时间） 或 Cache-Control（有 max-age，no-cache，no-store 三种） 字段实现。
- **协商缓存**：如果强制缓存失效，浏览器会发送请求到服务器，服务器在响应中返回一些缓存信息（如 Last-Modified 和 ETag），浏览器会将这些信息保存到本地缓存中。下一次请求时，浏览器会通过 If-Modified-Since 或 If-None-Match 字段将这些缓存信息发送给服务器，服务器根据这些信息判断资源是否发生变化，如果没有变化，服务器会返回一个 304 响应，告诉浏览器可以使用本地缓存，如果资源发生了变化，则会返回最新的资源。协商缓存可以通过设置 HTTP 响应头中的 Last-Modified 或 ETag 字段实现。
- **Service Worker 缓存**：Service Worker 是一种运行在浏览器后台的脚本，可以拦截并缓存浏览器发出的请求，以便在下次访问时快速响应请求。Service Worker 缓存可以通过使用 Service Worker 技术实现，它可以对页面的请求进行拦截，然后决定是返回缓存中的响应还是发起网络请求。

#### 浏览器本地存储

- **cookie 存储机制**：如果不在浏览器中设置过期时间，cookie 被保存在内存中，生命周期随浏览器的关闭而结束，这种 cookie 简称会话 cookie。如果在浏览器中设置了 cookie 的过期时间，cookie 被保存在硬盘中，关闭浏览器后，cookie 数据仍然存在，直到过期时间结束才消失。
- **session 存储机制**：当服务器收到请求需要创建 session 对象时，首先会检查客户端请求中是否包含 session id。如果有 session id，服务器将根据该 id 返回对应 session 对象。如果客户端请求中没有 session id，服务器会创建新的 session 对象，并把 session id 在本次响应中返回给客户端。

本地存储区别

- **Cookie**：cookie 只能保存字符串类型，以文本的方式；单个 cookie 保存的数据不能超过 4kb；针对 cookie 所存在的攻击：Cookie 欺骗，Cookie 截获。
- **Session**：通过类似与 Hashtable 的数据结构来保存，能支持任何类型的对象；大小理论上没有限制。安全性大于 cookie。
- **Web storage API**：Web Storage 存储机制是对 HTML4 中 cookie 存储机制的一个改善。由于 cookie 存储机制有很多缺点，HTML5 不再使用它，转而使用改良后的 Web Storage 存储机制。
  1. **SessionStorage**：sessionStorage 的容量上线也为 5MB。只存储在客户端，默认不参与与服务器端的通讯。sessionStorage 将数据保存在 Session 对象中，仅在当前会话下有效。
  1. **LocaleStorage**：localStorage 的容量上线为 5MB。只存储在客户端，默认不参与与服务器端的通讯；而 localStorage 将数据保存在客户端本地的硬件设备，即使浏览器被关闭了该数据依然存在，下次打开浏览器访问网站时可以继续使用。
- **IndexDB**：当数据量不大时，我们可以通过 SessionStorage 或者 LocalStorage 来进行存储，但是当数据量较大，或符合一定的规范时，我们可以使用 indexedDB 数据库来进行数据的存储，indexedDB 数据库存储理论上没有大小的限制。

#### DOM（Document Object Model）

- **DOM**（Document Object Model）: 指的是用于访问和操作 HTML 或 XML 文档的编程接口。DOM 将文档解析为一个由节点和对象（包含属性和方法）组成的结构集合。开发人员可以使用 DOM API 来操纵页面上的元素，比如添加、修改、删除等操作。在 JavaScript 中，可以通过 document 对象来访问 DOM。
- **节点类型**：

1. **元素节点**（element node）：表示 HTML 元素，如 &lt;div&gt;、&lt;p&gt;、&lt;ul&gt; 等，是 DOM 树中最常见的节点类型。
1. **文本节点**（text node）：表示 HTML 文本内容，如 &lt;p&gt;some text&lt;/p&gt; 中的 some text，也是 DOM 树中常见的节点类型。
1. **属性节点**（attribute node）：表示 HTML 元素的属性，如 &lt;div class="wrapper"&gt; 中的 class 属性，也是 DOM 树中的节点类型。
1. **注释节点**（comment node）：表示 HTML 文档中的注释，如 &lt;!-- This is a comment --&gt;，在 DOM 树中也是一种节点类型。
1. **文档节点**（document node）：表示整个 HTML 文档，每个文档只有一个文档节点。

- **创建节点**：

1. **createDocumentFragment() 方法**：创建一个文档片段，可以在其中插入节点，然后再将文档片段插入到页面中；
1. **createElement() 方法**：创建一个新的元素节点；
1. **createTextNode() 方法**：创建一个包含文本的新文本节点。

- **插入节点**：

1. **appendChild() 方法**：将新节点插入到父节点的子节点列表末尾；
1. **insertBefore() 方法**：将新节点插入到指定节点的前面；
1. **replaceChild() 方法**：替换指定节点的一个子节点；
1. **innerHTML 属性**：设置节点的 HTML 内容；
1. **outerHTML 属性**：替换整个节点，包括其所有子节点；

- **获取节点**：

1. **通过 ID 属性获取元素节点**：document.getElementById("elementId");
1. **通过标签名获取元素节点**：document.getElementsByTagName("tagName");
1. **通过类名获取元素节点**：document.getElementsByClassName("className");
1. **通过 CSS 选择器获取元素节点**：
   - document.querySelector("selector");
   - document.querySelectorAll("selector");
1. **通过自定义属性获取元素节点**：
   - document.querySelectorAll("\[attributeName=attributeValue]");

- **删除节点**：

1. **removeChild()**：通过父节点来删除子节点。
1. **parentNode.removeChild()**：通过子节点的父节点来删除子节点。
1. **replaceChild()**：通过父节点来替换子节点。
1. **innerHTML**：直接删除节点的 HTML 内容。
1. **outerHTML**：直接删除节点的 HTML 内容和节点本身。
1. **empty**：清空节点的所有子节点。

- **绑定事件**：addEventListener('click', handleClick);
- **解绑事件**：removeEventListener('click', myFunction);

- **event 对象**：有如下属性。

1. **type**：事件类型，例如 "click"、"keydown" 等等。
1. **target**：事件发生的元素。
1. **currentTarget**：事件绑定的元素。
1. **bubbles**：指示事件是否会向上传播到祖先元素。
1. **cancelable**：指示事件是否可以被取消。
1. **preventDefault()**：取消事件的默认行为。
1. **stopPropagation()**：停止事件的传播。

- **event.target 对象**：

1. **nodeName**：返回节点的名称，以大写字母形式表示。
1. **nodeValue**：返回节点的值。
1. **nodeType**：返回节点的类型，例如元素节点为 1，文本节点为 3，注释节点为 8 等。
1. **parentNode**：返回当前节点的父节点。
1. **childNodes**：返回当前节点的所有子节点，以 NodeList 对象形式返回。
1. **firstChild**：返回当前节点的第一个子节点。
1. **lastChild**：返回当前节点的最后一个子节点。
1. **previousSibling**：返回当前节点的前一个兄弟节点。
1. **nextSibling**：返回当前节点的后一个兄弟节点。
1. **attributes**：返回当前节点的属性列表，以 NamedNodeMap 对象形式返回。

#### BOM（Browser Object Model）

- **BOM**（Browser Object Model）: 指的是与浏览器窗口进行交互的编程接口。它包括浏览器窗口和框架对象，提供了与浏览器交互的方法和接口，比如弹出新窗口、移动、缩放窗口、获取屏幕尺寸等。在 JavaScript 中，可以通过 window 对象来访问 BOM。
- **Window 对象**：Window 对象由如下 5 个对象组成：

1. **Document 对象**：代表当前窗口或标签页中的文档，提供了操作文档的方法和属性；
1. **Location 对象**：代表当前文档的 URL 信息，提供了访问和操作 URL 的方法和属性；
1. **Navigator 对象**：包含了浏览器的信息，提供了访问浏览器相关信息的方法和属性；
1. **History 对象**：代表当前窗口的浏览历史记录，提供了访问和操作浏览器历史记录的方法和属性；
1. **Screen 对象**：代表当前窗口的屏幕信息，提供了访问和操作屏幕相关信息的方法和属性；

### 七、NodeJS

#### V8 垃圾回收机制

- **垃圾回收机制**：V8 垃圾回收机制是一种内存自动管理技术，它能够检测和清除不再使用的对象，以释放内存并避免内存泄漏。由于 JavaScript 语言的特性，它是一种垃圾回收语言，需要借助于垃圾回收机制来管理内存，以避免内存泄漏等问题。
- **新生代**：新生代内存空间的大小为 32MB，由于新生代内存空间比较小，因此 V8 使用了更为轻量级的 Scavenge GC 算法。在 Scavenge 的具体实现中，主要采用 Cheney 算法。
- **新生代算法**：Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。
- **老生代**：老生代内存空间的大小为 1.4GB，因此 V8 使用了更为复杂的垃圾回收算法。
- **老生代算法**：老生代中的对象一般存活时间较长且数量也多，主要使用了两个算法，分别是**标记清除算法**和**标记压缩算法**。

老生代具体算法

1. **标记清除算法**（Mark-Sweep）：从根对象出发，标记所有活动对象，然后将未标记的对象清除。（会产生内存碎片）
1. **标记压缩算法**（Mark-Compact）：与标记清除算法类似，但在清除时会压缩对象空间，将活动对象向一端移动，另一端为空闲空间。（需要更多的时间来压缩内存）
1. **增量标记算法**（Incremental Marking）：将垃圾回收过程分成多个阶段，在阶段间插入程序执行，减小了每个阶段的停顿时间，提高了程序的响应性能。（可能会导致垃圾回收时间更长）
1. **延迟清理算法**（lazy sweeping）将垃圾回收的时间推迟，直到内存资源不足时再进行回收。它适用于大量的短期对象，可以避免频繁的垃圾回收，提高了程序的性能。（会导致内存占用更高）

#### 内存泄漏

- **内存泄漏**：内存泄露指的是应用程序中的内存被错误地分配或使用，导致内存不能被及时地释放或回收，最终导致内存资源的浪费或耗尽的现象。当内存泄露严重时，会导致应用程序运行缓慢或崩溃。
- **造成原因**：没有及时清理不再使用的对象和变量；定时器和回调函数未清理；循环引用；不当使用闭包。
- **如何避免**：及时清理不再使用的对象和变量（赋值为 null）；避免循环引用；清理定时器和回调函数。

#### 内存溢出

- **内存溢出**：内存溢出是指程序在申请内存时，没有足够的内存可供使用，导致操作系统分配给程序的内存空间不足，出现异常情况，例如程序崩溃、运行变慢等现象。
- **造成原因**：内存泄漏导致内存占用增加；递归调用、数据库连接未关闭等。
- **如何避免**：及时释放无用的对象和变量；避免无限递归调用；及时关闭数据库连接。

### 八、性能优化

#### 前端性能指标

- **页面加载时间**：指从用户发起请求到页面加载完成的时间。这个指标包括了 DNS 查询、HTTP 请求、页面渲染等时间。
- **首次渲染时间（First Contentful Paint）**：指浏览器首次渲染页面内容的时间。它表示页面开始呈现内容的时间，包括文字、图像、背景等。
- **用户可交互时间（Time to Interactive）**：指页面加载完成并且用户可以与页面交互的时间。
- **总下载时间**：指所有资源加载完成的时间。
- **资源压缩**：对 CSS、JavaScript 和图像等资源进行压缩，减少文件大小和加载时间。
- **资源合并**：将多个文件合并成一个，减少 HTTP 请求次数。
- **图像优化**：对图像进行优化，减小图像大小和加载时间。
- **缓存利用率**：使用缓存技术，减少重复的 HTTP 请求。
- **代码优化**：对 JavaScript、CSS、HTML 等代码进行优化，减少代码量和加载时间。
- **延迟加载**：在页面加载完成后，再加载一些不是关键资源的内容。

#### 前端性能优化

- **构建速度优化**：HappyPack 多线程打包；减少文件搜索范围。
- **页面性能优化**：减少 HTTP 请求次数；压缩 CSS、JS 代码；使用精灵图；使用服务端渲染（SSR）。
- **加载时性能优化**：使用 CDN 加速；使用缓存机制；使用 HTTP/2 协议。
- **运行时性能优化**：避免出现大量的重排和重绘；把 JavaScript 防止 body 结束标签前面。
- **长列表性能优化**：使用懒加载；使用虚拟列表。

### 九、React

#### 生命周期

1. **挂载阶段**（Mounting）：组件被创建并插入到 DOM 中，包括以下方法：

- **constructor()**：组件构造函数，用于初始化 state 和绑定事件处理函数。
- **static getDerivedStateFromProps()**：在组件挂载和更新时被调用，返回一个对象来更新 state 或者返回 null 来不更新 state。
- **render()**：根据组件的 props 和 state 返回一个 React 元素（描述了在屏幕上显示的内容）。
- **componentDidMount()**：组件被插入到 DOM 中后立即调用，通常用于进行网络请求或订阅事件。

1. **更新阶段**（Updating）：组件的 props 或 state 发生改变，导致组件重新渲染，包括以下方法：

- **static getDerivedStateFromProps()**：在组件挂载和更新时被调用，返回一个对象来更新 state 或者返回 null 来不更新 state。
- **shouldComponentUpdate()**：用于判断组件是否需要重新渲染，默认返回 true。
- **render()**：根据组件的 props 和 state 返回一个 React 元素（描述了在屏幕上显示的内容）。
- **getSnapshotBeforeUpdate()**：在 render() 方法调用后，DOM 更新之前调用，用于获取组件更新前的状态。
- **componentDidUpdate()**：在组件更新后立即调用，通常用于更新 DOM 或执行其他副作用。

1. **卸载阶段**（Unmounting）：组件从 DOM 中被移除，包括以下方法：

- **componentWillUnmount()**：在组件被移除前调用，通常用于清除组件中使用的定时器、取消网络请求等清理操作。

此外，React 还提供了一些钩子函数（如 getDerivedStateFromError() 和 componentDidCatch()）用于处理组件渲染过程中出现的错误。

#### 组件通信

- **父子组件间通信**：通过 props 传递数据或回调函数。
- **子父组件间通信**：通过回调函数或使用 Ref 访问父组件的方法和属性。
- **兄弟组件间通信**：通过共同的父组件传递数据或通过事件总线（Event Bus）进行通信。
- **跨级组件通信**：通过 Context API 进行通信。
- **非嵌套组件间通信**：通过全局状态管理工具（如 Redux 或 MobX）进行通信。

#### 虚拟 DOM

- **虚拟 DOM**：React 虚拟 DOM 是 React 框架的核心概念之一，用于提高渲染效率。虚拟 DOM 本身是一个纯 JavaScript 对象，用来描述真实 DOM 的层次结构、属性和内容等信息。虚拟 DOM 中包含了真实 DOM 所有的信息，但它并不直接操作真实 DOM，而是通过比对新旧虚拟 DOM 的差异，然后批量更新真实 DOM，从而减少了对真实 DOM 的频繁操作，提高了页面渲染的性能。
- **虚拟 DOM 工作流程**：

1. **初始化**：通过调用 React.createElement() 函数创建虚拟 DOM 对象。
1. **渲染**：将虚拟 DOM 对象转换为真实 DOM 对象，并插入到页面中。
1. **更新**：在组件状态改变时，通过比较新旧虚拟 DOM 的差异，找出需要更新的部分，并进行更新操作。
1. **销毁**：当组件被销毁时，也会同时销毁对应的虚拟 DOM。

- **和 Vue 区别**：

1. React 的虚拟 DOM 是通过 React.createElement() 方法或 JSX 语法创建的 JavaScript 对象，称为 React 元素，包含了组件的名称、属性和子元素等信息。React 将每个组件渲染成一个虚拟 DOM 树，组件的状态发生变化时，React 会比较新旧虚拟 DOM 树的差异，并仅更新需要改变的部分。
2. Vue 的虚拟 DOM 是通过模板语法和 Vue 组件生成的，称为 VNode（Virtual Node）对象，包含了节点类型、节点属性、节点子元素等信息。当组件状态变化时，Vue 会重新渲染组件，生成一个新的 VNode 树，然后将新的 VNode 树和旧的 VNode 树进行比较，然后再将变化的部分更新到真实 DOM 上。

#### Diff 算法

- **Diff 算法**：React 的 diff 算法主要是基于同层比较的策略，它比较新旧虚拟 DOM 树的同一层节点，通过对节点的增、删、改操作尽可能地减少 DOM 操作，从而提高渲染性能。
- **实现步骤**：

1. 比较树的根节点，如果不同，直接替换整棵树；
2. 如果根节点相同，则比较根节点的属性和状态，如果有变化，则更新根节点的属性和状态；
3. 逐层比较子节点，分别对新旧节点进行比较，比较规则如下：
   - 如果两个节点类型不同，则直接删除旧节点，插入新节点；
   - 如果两个节点类型相同，则比较节点属性和子节点：
     - 如果节点属性有变化，则更新节点属性；
     - 如果只有子节点有变化，则继续递归比较子节点。

- **和 Vue 区别**：

1. **同层级比较**：React 的 diff 算法会从顶层开始，一层一层地比较，如果发现同一层有不同的节点，就会把这一层的节点全部更新，这种做法有可能会导致一些无用的更新；而 Vue 的 diff 算法是采用双指针的方式，从头开始遍历，只要找到相同的节点就停止比较，然后再进行下一层的比较。
1. **key 值比较**：React 的 diff 算法会根据节点的 key 值来判断是否是同一节点，如果 key 值相同就认为是同一节点，如果 key 值不同就认为是不同的节点；而 Vue 的 diff 算法也会根据节点的 key 值来判断是否是同一节点，但是如果 key 值相同但是节点类型不同，Vue 会认为这是不同的节点。
1. **异步更新**：React 在更新过程中，会将所有需要更新的组件先加入到更新队列中，等到下一个事件循环时再进行更新，这样可以尽可能地减少 DOM 操作，提高更新效率；而 Vue 是采用异步更新策略，即在 nextTick 的时候进行批量更新，这种方式可以让更新效率更高，因为同一个 tick 内的更新都会被合并，减少 DOM 操作的次数。

#### 路由

#### 高阶组件 HOC

#### 状态管理 Redux

### 十、软件工程

#### 前端工程化

- **工程化**：前端工程化是一种将软件工程方法和思想应用到前端开发中的方法，旨在提高前端开发效率，降低开发成本，保障代码质量和服务稳定性。具体来说，前端工程化包括一系列规范、流程和工具，如模块化、组件化、规范化和自动化等方面。下面将从以下几个方面介绍如何实现前端工程化：
- **前后端分离**：前端工程师主要负责静态资源和动态资源的处理、JavaScript 实现前端业务逻辑、HTML 模板文件的产出等任务。前后端分离是实现前端各种优化方案的基础。
- **模块化**：模块化的职责在于模块管理和资源加载。常用的工具有 Node.js、npm、webpack、parcel、rollup 等。其中，webpack 是前端工程化中最常用的模块化解决方案之一，它可以将代码打包为模块，实现代码的分离和管理。
- **组件化**：组件化是前端工程化中的重要组成部分，它自由、灵活、可复用，大大提高了开发效率。微信小程序的目录结构应用了组件化的思想。
- **规范化**：规范化是前端工程化中不可或缺的一部分，它可以通过一些工具来实现，如 ESLint、stylelint 等。ESLint 是一个可插拔的 JavaScript 代码检查工具，它可以检查 JavaScript 代码中的语法错误和潜在问题，还可以对代码进行格式化和修复。
- **自动化**：自动化阶段包括构建、测试和部署三个阶段。自动化构建工具有 grunt、gulp 等，它们可以对文件进行压缩、校验、资源合并等处理方式。

#### 模块化

- **模块化**：前端模块化是一种管理和组织前端代码的方式，它将一个大的程序拆分成互相依赖的小文件，再用简单的方法拼装起来，以便更好地维护和管理代码。前端模块化可以使前端代码更加可重用、可维护和可扩展。在不同的模块化规范中，有不同的方式来定义和使用模块，如 CommonJS，AMD，CMD 和 ES6 模块系统。
- **作用**：提高代码的可读性和可维护性；减少命名冲突；提高代码的可重用性。
- **模块化规范**：
  1. **CommonJS 规范**：CommonJS 规范应用于 nodejs 应用中，在 nodejs 应用中每个文件就是一个模块，拥有自己的作用域，文件中的变量、函数都是私有的，与其他文件相隔离。CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。
  1. **AMD 和 CMD 规范**：AMD 和 CMD 是为了解决浏览器异步加载模块而诞生的方案，其中 AMD 由 require.js 驱动，CMD 由 sea.js 驱动。这些规范的主要目的是为了在浏览器中异步加载模块，以提高应用程序的性能。但随着打包工具的发展，commonjs 和 ES6 都可以在浏览器上运行了，因此 AMD 和 CMD 将逐渐被替代。
  1. **ES6 模块系统**：在 ES6 中，模块是一种特殊的文件类型，它使用 import 和 export 关键字来定义和使用模块。ES6 模块系统是一种新的模块化标准，可以在浏览器和 nodejs 中使用，它的主要优点是在语言层面上提供了对模块的支持，可以在编译时进行静态分析，从而提高应用程序的性能和可维护性。

#### 设计模式

- **观察者模式**：观察者模式（Observer Pattern）是一种常见的设计模式，它用于对象之间的一对多依赖关系，当一个对象发生变化时，它的所有依赖对象都会收到通知并自动更新。这种设计模式可以有效地解耦对象之间的关系，提高代码的灵活性和可维护性。
- **发布-订阅模式**：发布订阅模式（Publish/Subscribe Pattern）是一种常见的设计模式，它用于解决多个对象之间的一对多依赖关系。在发布订阅模式中，发布者（或称为消息中心）负责向订阅者（或称为观察者）发布消息，而订阅者则可以自由地订阅和取消订阅感兴趣的消息，以便在消息发布时及时接收到通知。

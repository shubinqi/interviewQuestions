<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-05 15:18:20
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-05 23:11:28
 * @Description: 八股文重点速记0305
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\速记.md
-->

### 一、HTML

#### 语义化

- **语义化**：具有特定含义的标签，使得文档更易于理解、维护和访问。
- **作用**：提高页面的可读性和可访问性，利于 SEO。
- **常用标签**：&lt;header&gt;、&lt;nav&gt;、&lt;article&gt;、&lt;aside&gt;、&lt;section&gt;等。

### 二、CSS

#### BFC

- **BFC**：块级格式化上下文。
- **产生条件**：根元素、浮动元素、绝对定位元素、Flex 弹性盒子、行内块元素、表格单元格等。
- **特点**：垂直方向排列，不会重叠。
- **作用**：清除浮动、防止 margin 重叠。

#### IFC

- **IFC**：内联格式化上下文。
- **特点**：按照从左到右的顺序排列，会换行，会自动调整大小。
- **场景**：水平居中、垂直居中、多列布局。

#### 盒模型

- **标准盒模型**：box-sizing: content-box; 盒子大小为 width + padding + border ，此值为其默认值，其让元素维持 W3C 的标准。
- **IE 盒模型**：box-sizing: border-box; 盒子大小为 width 就是说 padding 和 border 是包含到 width 里面。
- **区别**：在标准盒模型中，一个盒子的宽度由内容区域（content）的宽度（width）构成。而在 IE 盒模型中，一个盒子的宽度由内容区域、内边距和边框的宽度（width + padding + border）构成。

#### 回流

- **回流**：重新渲染部分或全部文档而进行的一系列计算过程。
- **导致回流**：浏览器窗口大小变化；改变字体大小；元素的位置、尺寸、内容等发生改变。
- **避免回流**：避免频繁操作样式；使用 flex 进行布局；避免使用 document.write。

#### 重绘

- **重绘**：元素样式的改变并不影响其在文档流中的位置，重新渲染元素的可视化外观。
- **导致重绘**：修改元素颜色、背景等；浏览器窗口大小变化。
- **避免重绘**：避免频繁读取布局信息，避免使用 CSS 表达式。

#### 清除浮动

- **方法一**：额外标签法（clear: both）
- **方法二**：父级添加 overflow 属性方法（overflow: hidden | auto）
- **方法三**：使用 after 伪元素清除浮动（.clearfix:after）
- **方法四**：使用 before 和 after 双伪元素清除浮动（.clearfix:before, .clearfix:after）
- **方法五**：父元素直接设置 display: table（display: table）

#### 水平垂直居中

- **方法一**：flex 布局（父级 justify-content: center 和 align-items: center 即可）
- **方法二**：absolute + transform（定位的上、左为 50%，translate 上、左负 50%）
- **方法三**：absolute + margin: auto（定位的上下左右为 0）
- **方法四**：table-cell（使用表格样式）
- **方法五**：absolute + 负 margin（定位的上、左为 50%，margin 的上、左负子元素的一半）

#### 常见布局

- **常见布局**：盒模型布局、浮动布局、定位布局、Flex 弹性布局、栅格布局

### 三、JavaScript

#### 闭包

- **闭包**：闭包 = 函数 + 自由变量（红宝书：可以调用另一个函数作用域中变量的函数）。
- **优点**：不会污染全局作用域；让变量长期保存在内存中；对局部变量的间接访问。
- **缺点**：使用不当容易造成内存泄露；可能会导致性能问题。
- **使用场景**：节流、防抖、计数器、私有变量、模块化开发。

#### 原型

- **原型**：在 JavaScript 中，每个对象都有一个内部属性 **prototype**，通常称为“原型”，它引用另一个对象。

#### 原型链

- **原型链**：当我们访问一个对象的属性或方法时，JavaScript 引擎会先在对象自身中查找是否存在该属性或方法，如果没有找到，则会到对象的原型中查找，如果还没找到，会继续在原型的原型中查找，直到找到该属性或者找到原型链的末尾为止。
- **终点**：原型链的终点是 null，因为 Object.prototype 是所有对象的基类，而他的隐式原型为空。

#### 作用域链

- **作用域**：作用域（Scope）指的是变量或函数的可访问范围，JavaScript 中有全局作用域和函数作用域两种类型的作用域。
- **作用域链**：作用域链（Scope Chain）指的是当 JavaScript 引擎在查找变量的值时，从当前作用域开始查找，如果在当前作用域中找不到该变量，则会一层层向上查找，直到找到该变量或查找到全局作用域为止。

#### 跨域

- **同源策略**：同源策略是浏览器的一种安全策略，它限制了一个源（协议、域名、端口）的文档或脚本如何能够与另一个源的资源进行交互。
- **跨域**：跨域（Cross-Origin）指的是在浏览器的同源策略下，一个网页无法请求另一个网页的资源，即浏览器禁止跨域请求。
- **解决跨域**：CORS 跨域资源共享，服务器添加响应头；JSONP 动态插入一个 script 标签，请求一个带有参数的地址；配置代理；Nginx 反向代理。
- **项目跨域**：配置 Proxy。

#### 异步编程

- **异步编程**：异步编程是一种编程模式，它可以让程序在执行一些需要等待的任务（比如网络请求、文件读写、计时器等）时，不会阻塞主线程的执行，而是在后台进行处理，等待任务完成后再进行相应的处理。异步编程能够提高程序的性能和响应速度，使程序可以更好地利用 CPU 和 I/O 资源。
- **实现方式**：在 JavaScript 中，异步编程可以通过回调函数、Promise 和 async/await 等方式来实现。

#### 事件循环

- **事件循环**：简单地说，对于 JS 运行中的任务，JS 有一套处理收集，排队，执行的特殊机制，我们把这套处理机制称为事件循环（Event Loop）。
- **执行栈**：执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。
- **执行上下文**：执行上下文，又叫做执行环境（全局执行上下文、函数执行上下文、Eval 函数执行上下文）。
- **任务队列**：一个事件循环中，可以有一个或者多个任务队列（task queue），一个任务队列便是一系列有序任务（task）的集合。
- **同步任务**：同步任务是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务，当我们打开网站时，网站的渲染过程，比如元素的渲染，其实就是一个同步任务。
- **异步任务**：异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程，当我们打开网站时，像图片的加载，音乐的加载，其实就是一个异步任务。
- **宏任务**：script（整体代码）、setTimeout、setInterval、UI 交互事件等
- **微任务**：Promise.then()、Promise.catch()、process.nextTick

#### 深拷贝

- **浅拷贝**：只复制对象的第一层属性，复制的是对象的内存地址。
- **深拷贝**：递归地复制所有属性，包括对象中的对象。
- **区别**：浅拷贝会同步修改原对象，深拷贝不会。
- **实现深拷贝**：JSON.parse(JSON.stringify(obj)); 递归地复制对象；使用第三方库（Lodash）。

#### 节流

- **节流**：节流（Throttling）是一种限制函数的调用频率的方法。在一定时间间隔内，无论事件被触发了多少次，函数都只会执行一次。
- **场景**：滚动加载、搜索框联想、提交按钮之类的。

#### 防抖

- **防抖**：防抖（debounce）是一种常用的 JavaScript 技术，可以在一定时间内多次触发同一个函数，只执行一次。
- **场景**：适用于某些需要频繁触发的事件，例如 resize、scroll、input 等。

#### ES6

- **ES6 新语法**：块级作用域（let、const）；箭头函数；解构赋值；模板字符串；函数默认参数；展开运算符；Promise；async/await；导入导出；Symbol、BigInt；Map 和 WeakMap；Set 和 WeakSet；for...in；for...of。
- **async/await**：
- **Map**：

#### Promise

- **Promise**：Promise 是一种用于异步编程的 JavaScript 对象，它可以更好地管理和组织异步操作。Promise 提供了一种解决 Ajax 回调地狱（Callback Hell）的方案，使得异步代码可以更加清晰和易于维护。
- **Ajax**：Ajax 是一种跨域解决方案，用于实现客户端与服务器端的异步通信效果，实现页面的局部刷新。
- **回调地狱**：回调地狱是指在异步编程中，多次嵌套回调函数所形成的代码结构，使得代码难以阅读和维护。
- **Promise 状态**：Pending（等待状态）、Fulfilled（已完成状态）和 Rejected（已失败状态）
- **常用 API**：

#### JS 垃圾回收机制

- **垃圾回收机制**：JS 的垃圾回收机制是为了防止内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。
- **标记清除**：
- **引用计数**：

### 四、VUE

#### 响应式原理 definePeroperty

- **definePeroperty**：

#### 响应式原理 Proxy

- **Proxy**：

#### 虚拟 DOM

- **虚拟 DOM**：

#### Diff 算法

- **Diff 算法**：

#### 生命周期

- **生命周期**：

#### 组件通信

- **父子组件通信**：props 和 $emit；$parent / $children (父子)
- **祖孙组件通信**：$attrs / $listeners（祖孙）
- **兄弟组件通信**：ref / $refs （父子，兄弟）
- **跨级组件通信**：全局事件总线（Event Bus $emit / $on）
- **任意组件通信**：VueX；全局事件总线（Event Bus $emit / $on）

#### 封装组件

- **组件封装原则**：高内聚、低耦合、可重用
- **组件包含**：模板、传参 Props、数据 data、方法 $emit、注册组件（Vue.component()）

#### 封装 axios

- **封装全局参数**：全局的请求头、响应头等信息，减少重复代码的编写。
- **封装请求拦截器**：可以在请求发送之前对请求进行处理，例如在请求头中添加 token 等信息。
- **封装响应拦截器**：可以在响应返回后对响应进行处理，例如判断响应状态码是否正确，统一处理错误信息等。
- **封装公共方法**：可以将一些通用的请求方法进行封装，例如 get、post、put、delete 等方法。

#### 封装 keep-alive

#### 权限管理

- **菜单权限**：
- **按钮权限**：

### 五、计算机网络

#### TCP 三次握手四次挥手

- **三次握手**：
- **为什么三次**：
- **四次挥手**：
- **为什么四次**：

### 六、浏览器

#### 从输入 URL 到页面展示过程

### 七、NodeJS

#### V8 垃圾回收机制

- **垃圾回收机制**：V8 垃圾回收机制是一种内存自动管理技术，它能够检测和清除不再使用的对象，以释放内存并避免内存泄漏。由于 JavaScript 语言的特性，它是一种垃圾回收语言，需要借助于垃圾回收机制来管理内存，以避免内存泄漏等问题。
- **新生代算法**：
- **老生代算法**：
- **标记清除**：
- **增量标记算法**：

#### 内存泄漏

- **内存泄漏**：内存泄露指的是应用程序中的内存被错误地分配或使用，导致内存不能被及时地释放或回收，最终导致内存资源的浪费或耗尽的现象。当内存泄露严重时，会导致应用程序运行缓慢或崩溃。
- **造成原因**：没有及时清理不再使用的对象和变量；定时器和回调函数未清理；循环引用；不当使用闭包。
- **如何避免**：及时清理不再使用的对象和变量（赋值为 null）；避免循环引用；清理定时器和回调函数。

#### 内存溢出

- **内存溢出**：内存溢出是指程序在申请内存时，没有足够的内存可供使用，导致操作系统分配给程序的内存空间不足，出现异常情况，例如程序崩溃、运行变慢等现象。
- **造成原因**：内存泄漏导致内存占用增加；递归调用、数据库连接未关闭等。
- **如何避免**：及时释放无用的对象和变量；避免无限递归调用；及时关闭数据库连接。

### 八、性能优化

#### 前端性能指标

#### 前端性能优化

### 九、React

#### 生命周期

#### 组件通信

#### 虚拟 DOM

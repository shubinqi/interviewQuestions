<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-05 15:18:20
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-06 18:39:43
 * @Description: 八股文重点速记0305
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\速记.md
-->

### 一、HTML

#### 语义化

- **语义化**：具有特定含义的标签，使得文档更易于理解、维护和访问。
- **作用**：提高页面的可读性和可访问性，利于 SEO。
- **常用标签**：&lt;header&gt;、&lt;nav&gt;、&lt;article&gt;、&lt;aside&gt;、&lt;section&gt;等。

#### Canvas 和 SVG 区别

- **Canvas**：基于**像素**的位图渲染技术。
- **SVG**：基于**矢量**的图形渲染技术。
- **区别**：Canvas 使用 JavaScript API 绘制位图，而 SVG 则使用 XML 标记绘制矢量图形。Canvas 是渲染像素，SVG 是渲染矢量图形。Canvas 用于绘制复杂的动态图形和游戏，SVG 用于静态图形绘制和数据可视化。
- **位图**：由一系列像素点构成的图像，放大会失真。
- **矢量**：通过直线、曲线、矩形、多边形等基本几何形状来描述图像，可以无限放大而不失真

### 二、CSS

#### BFC

- **BFC**：块级格式化上下文。
- **产生条件**：根元素、浮动元素、绝对定位元素、Flex 弹性盒子、行内块元素、表格单元格等。
- **特点**：垂直方向排列，不会重叠。
- **作用**：清除浮动、防止 margin 重叠。

#### IFC

- **IFC**：内联格式化上下文。
- **特点**：按照从左到右的顺序排列，会换行，会自动调整大小。
- **场景**：水平居中、垂直居中、多列布局。

#### 盒模型

- **标准盒模型**：box-sizing: content-box; 盒子大小为 width + padding + border ，此值为其默认值，其让元素维持 W3C 的标准。
- **IE 盒模型**：box-sizing: border-box; 盒子大小为 width 就是说 padding 和 border 是包含到 width 里面。
- **区别**：在标准盒模型中，一个盒子的宽度由内容区域（content）的宽度（width）构成。而在 IE 盒模型中，一个盒子的宽度由内容区域、内边距和边框的宽度（width + padding + border）构成。

#### 回流

- **回流**：重新渲染部分或全部文档而进行的一系列计算过程。
- **导致回流**：浏览器窗口大小变化；改变字体大小；元素的位置、尺寸、内容等发生改变。
- **避免回流**：避免频繁操作样式；使用 flex 进行布局；避免使用 document.write。

#### 重绘

- **重绘**：元素样式的改变并不影响其在文档流中的位置，重新渲染元素的可视化外观。
- **导致重绘**：修改元素颜色、背景等；浏览器窗口大小变化。
- **避免重绘**：避免频繁读取布局信息，避免使用 CSS 表达式。

#### 清除浮动

- **方法一**：额外标签法（clear: both）
- **方法二**：父级添加 overflow 属性方法（overflow: hidden | auto）
- **方法三**：使用 after 伪元素清除浮动（.clearfix:after）
- **方法四**：使用 before 和 after 双伪元素清除浮动（.clearfix:before, .clearfix:after）
- **方法五**：父元素直接设置 display: table（display: table）

#### 水平垂直居中

- **方法一**：flex 布局（父级 justify-content: center 和 align-items: center 即可）
- **方法二**：absolute + transform（定位的上、左为 50%，translate 上、左负 50%）
- **方法三**：absolute + margin: auto（定位的上下左右为 0）
- **方法四**：table-cell（使用表格样式）
- **方法五**：absolute + 负 margin（定位的上、左为 50%，margin 的上、左负子元素的一半）

#### 常见布局

- **常见布局**：盒模型布局、浮动布局、定位布局、Flex 弹性布局、栅格布局

### 三、JavaScript

#### 闭包

- **闭包**：闭包 = 函数 + 自由变量（红宝书：可以调用另一个函数作用域中变量的函数）。
- **优点**：不会污染全局作用域；让变量长期保存在内存中；对局部变量的间接访问。
- **缺点**：使用不当容易造成内存泄露；可能会导致性能问题。
- **使用场景**：节流、防抖、计数器、私有变量、模块化开发。

#### 原型

- **原型**：在 JavaScript 中，每个对象都有一个内部属性 **prototype**，通常称为“原型”，它引用另一个对象。

#### 原型链

- **原型链**：当我们访问一个对象的属性或方法时，JavaScript 引擎会先在对象自身中查找是否存在该属性或方法，如果没有找到，则会到对象的原型中查找，如果还没找到，会继续在原型的原型中查找，直到找到该属性或者找到原型链的末尾为止。
- **终点**：原型链的终点是 null，因为 Object.prototype 是所有对象的基类，而他的隐式原型为空。

#### 作用域链

- **作用域**：作用域（Scope）指的是变量或函数的可访问范围，JavaScript 中有全局作用域和函数作用域两种类型的作用域。
- **作用域链**：作用域链（Scope Chain）指的是当 JavaScript 引擎在查找变量的值时，从当前作用域开始查找，如果在当前作用域中找不到该变量，则会一层层向上查找，直到找到该变量或查找到全局作用域为止。

#### 深拷贝

- **浅拷贝**：只复制对象的第一层属性，复制的是对象的内存地址。
- **深拷贝**：递归地复制所有属性，包括对象中的对象。
- **区别**：浅拷贝会同步修改原对象，深拷贝不会。
- **实现深拷贝**：JSON.parse(JSON.stringify(obj)); 递归地复制对象；使用第三方库（Lodash）。

#### 节流

- **节流**：节流（Throttling）是一种限制函数的调用频率的方法。在一定时间间隔内，无论事件被触发了多少次，函数都只会执行一次。
- **场景**：滚动加载、搜索框联想、提交按钮之类的。

#### 防抖

- **防抖**：防抖（debounce）是一种常用的 JavaScript 技术，可以在一定时间内多次触发同一个函数，只执行一次。
- **场景**：适用于某些需要频繁触发的事件，例如 resize、scroll、input 等。

#### ES6

- **ES6 新语法**：块级作用域（let、const）；箭头函数；解构赋值；模板字符串；函数默认参数；展开运算符；Promise；async/await；模块化；Symbol；BigInt；Map 和 WeakMap；Set 和 WeakSet；for...in；for...of；类；继承。
- **块级作用域**：使用 let 和 const 声明变量时可以创建块级作用域。
- **let、const**：let 声明变量，const 声明常量，都不会有变量提升，会造成暂时性死区。
- **箭头函数**：使用 => 语法定义匿名函数。
- **解构赋值**：可以从数组和对象中提取值并将其赋给变量。
- **模板字符串**：使用反引号 `` 来创建多行字符串，并且可以在字符串中插入表达式。
- **函数默认参数**：定义函数参数的默认值。
- **展开运算符**：使用 ... 语法来展开数组或对象。
- **Map**：字典，一种新的集合类型，为 ECMAScript 语言带来了真正的键/值存储机制，键可以是任何类型，不仅限于字符串或 Symbol 类型。
- **WeakMap**：是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。
- **Set**：集合，一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。
- **WeakSet**：它只能存储对象，且只持有对象的弱引用。
- **Promise**：处理异步操作的一种方法，可以通过链式调用来组合多个异步操作。
- **async/await**：是 Promise 的语法糖，让异步操作更直观。
- **模块化**：使用 import 和 export 关键字来导入和导出模块。
- **Symbol**：标识符，引入了一种新的原始数据类型，用于创建唯一的标识符。
- **BigInt**：大整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。
- **for...in**：用于遍历对象中的属性，它会将对象的属性名称作为循环变量来访问对象的每一个属性。
- **for...of**：用于遍历可迭代对象（如数组、Map、Set 等），它会将集合中的每一个元素作为循环变量来访问每一个元素。
- **类**：使用 class 关键字来定义类。
- **继承**：使用 extends 关键字来定义继承。

#### Promise

- **Promise**：Promise 是一种用于异步编程的 JavaScript 对象，它可以更好地管理和组织异步操作。Promise 提供了一种解决 Ajax 回调地狱（Callback Hell）的方案，使得异步代码可以更加清晰和易于维护。
- **Ajax**：Ajax 是一种跨域解决方案，用于实现客户端与服务器端的异步通信效果，实现页面的局部刷新。
- **回调地狱**：回调地狱是指在异步编程中，多次嵌套回调函数所形成的代码结构，使得代码难以阅读和维护。
- **Promise 状态**：Pending（等待状态）、Fulfilled（已完成状态）和 Rejected（已失败状态）
- **常用 API**：Promise.then()；Promise.catch()；Promise.finally()；Promise.all()；Promise.race()；Promise.any()；

#### JS 垃圾回收机制

- **垃圾回收机制**：JS 的垃圾回收机制是为了防止内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。
- **标记清除**：标记清除是一种常用的垃圾回收方法，它的原理是通过标记那些不再使用的对象，然后进行清除。垃圾收集器会从根节点开始遍历所有对象，标记所有能够从根节点访问到的对象，然后将未被标记的对象进行清除。
- **引用计数**：引用计数是另一种垃圾回收方法，它的原理是通过记录每个对象被引用的次数，当引用次数为 0 时就可以将该对象进行清除。引用计数方法的优点是可以很快地回收那些被引用次数为 0 的对象，但是它也存在一些例如循环引用的问题。

### 四、VUE

#### Vue 基础

- **Vue**：是用于构建用户界面的渐进式 JavaScript 框架。
- **SPA 单页应用**：SPA（Single Page Application）即单页面应用，是一种 Web 应用程序的架构方式，它通过 Ajax 或 WebSockets 等技术，在一个单页面中动态加载内容并更新页面，使得 Web 应用具有更加流畅的用户体验。
- **MPA 多页应用**：MPA（Multiple Page Application）是由多个完整页面构成的应用。MPA 应用的页面跳转方式是从一个页面跳转到另一个新的页面。MPA 的优点是首屏加载速度快，SEO 效果好；缺点是页面切换慢。
- **MVC**：分为三个部分：模型、视图和控制器。模型用于存储应用程序数据，视图用于展示数据，而控制器用于管理模型和视图之间的交互。
- **MVVM**：分为三个部分：模型、视图和视图模型。模型和视图在 MVVM 中的作用与 MVC 相同。视图模型是一个中介层，它将视图和模型之间的交互进行解耦。视图模型将数据从模型层转换为视图层，同时也处理视图层的交互事件，将其转换为模型层能够处理的操作。

#### 响应式原理 definePeroperty

- **definePeroperty**：Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
- **数据劫持**：数据劫持是指在访问对象的属性时，拦截并对这个属性的读取和写入进行某些额外的操作，从而可以实现一些高级特性，例如数据绑定、观察者模式等。
- **发布者-订阅者模式**：发布者-订阅者模式（Publisher-Subscriber Pattern）是一种设计模式，用于解决应用程序中的事件处理问题。它包括两个主要组件：发布者和订阅者。发布者发布事件，订阅者订阅事件并在事件发生时得到通知并执行相应的处理。这个模式可以使应用程序组件之间的通信变得更加灵活。
- **优点**：兼容性好，可以用于实现 Vue2.x 的响应式数据原理
- **缺点**：通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染。（Vue 内部通过重写函数的方式解决了这个问题）

#### 响应式原理 Proxy

- **Proxy**：Proxy 是 ECMAScript 6 新增的一个特性，它可以拦截对象的各种操作，比如读取属性、写入属性、删除属性、函数调用等。使用 Proxy 可以实现数据劫持，从而实现响应式数据。
- **优点**：可以拦截对象的各种操作，比如读取属性、写入属性、删除属性、函数调用等；不需要再单独对数组的一些方法进行重写。
- **缺点**：Proxy 是 ES6 的新特性，不兼容旧版本的浏览器，需要使用 polyfill 或者转译器进行转换。

#### 虚拟 DOM

- **虚拟 DOM**：Virtual Dom（虚拟 DOM） 是一个 JavaScript 对象，通过对象的方式来表示 DOM 结构。
- **优点**：保证性能下限，在不进行手动优化的情况下，提供过得去的性能；可以很方便的跨平台操作，比如服务端渲染、uniapp。
- **缺点**：首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。

#### Diff 算法

- **Diff 算法**：Diff 算法是 虚拟 DOM（Virtual DOM） 的核心算法，用于比较两个 虚拟 DOM（Virtual DOM） 树的差异，并将差异应用到实际 DOM 上，从而实现高效的视图更新。
- **基本原理**：

1. 如果新旧节点**不是同一个节点**，则直接将新节点替换旧节点，结束这个节点的对比，开始对比下一个节点。
1. 如果新旧节点**是同一个节点**，那么对比它们的子节点：
   a. 如果新旧节点都没有子节点，则认为它们是相等的，不需要更新。
   b. 如果新节点没有子节点，但是旧节点有子节点，则将旧节点的子节点全部删除。
   c. 如果旧节点没有子节点，但是新节点有子节点，则将新节点的子节点全部添加到旧节点中。
   d. 如果新旧节点都有子节点，则递归调用 Diff 算法，对比它们的子节点。
1. 对比新旧节点的**属性**是否有变化，如果有变化，则更新属性。
1. 对比新旧节点的**子节点列表**是否有变化，如果有变化，则更新子节点列表。

#### Vue 2.X 生命周期

- **Vue 的生命周期**：从 Vue 实例创建、数据初始化、挂载、更新到销毁的期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！

1. **beforeCreate**：实例刚在内存中被创建出来，此时还没有初始化好 data 和 methods 属性，因此无法访问这两个属性，可以在这里做一些全局的配置，如注册全局组件、全局指令等。
1. **created**：实例已经在内存中创建完成，此时 data 和 methods 都已经被初始化好了，可以访问这两个属性，如果想和后端交互，可以在这里使用 axios 等库。
1. **beforeMount**：此时模板已经在内存中编译完成，但尚未挂载到页面中。
1. **mounted**：此时模板已经挂载到页面中，用户可以看到渲染好的页面。可以在这里做一些初始化页面的操作，如获取页面中的 DOM 元素、对获取的数据进行进一步处理等。
1. **beforeUpdate**：状态更新之前触发，此时可以对状态进行更新之前的操作，如更新状态之前获取页面的 scrollTop 等。
1. **updated**：状态更新之后触发，此时可以对更新后的状态进行操作，如操作更新后的 DOM 元素等。
1. **beforeDestroy**：实例在销毁之前调用，可以在这里进行善后工作，如清除定时器、清除非 Vue 插件等。
1. **destroyed**：实例已经销毁，这个时候就不能再访问实例中的 data 和 methods 属性了，可以在这里进行垃圾回收等工作。

通常在 created、beforeMount、mounted 钩子函数中请求异步数据，因为此时实例已经被创建完成，data 和 methods 属性也已经被初始化好了，可以访问这两个属性。

- **Keep-alive** 生命周期如下：

1. **activated**：页面第一次进入的时候，钩子触发的顺序是 created->mounted->activated
1. **deactivated**: 页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated

#### Vue 3.X 生命周期

- **生命周期**：从 Vue 实例创建、挂载、更新到销毁的期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！

1. 创建（Creation）- 在组件实例被创建时调用（beforeCreate 和 created 可以被 setup 方法取代）
2. 挂载（Mounting）- 在组件挂载到 DOM 时调用
3. 更新（Updating）- 当响应式数据发生改变时调用
4. 销毁（Unmounting）- 在组件被销毁时调用

详细生命周期

1. **beforeCreate** - 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用
1. **created** - 在实例创建完成后被立即调用。在这一步，实例已完成以下配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
1. **beforeMount** - 在挂载开始之前被调用：相关的 render 函数首次被调用。
1. **mounted** - el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。
1. **beforeUpdate** - 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改数据，但不会触发附加的重渲染过程。
1. **updated** - 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。
1. **beforeUnmount** - 在卸载开始之前调用。在这一步，实例仍然完全可用。
1. **unmounted** - 在组件实例被卸载和销毁之前调用。在这一步，实例完全被解除了对其自身属性和方法的引用。
1. **errorCaptured** – 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。

当使用组合式 API 时生命周期改变如下，我们可以在 setup 方法中访问的 API 生命周期钩子有 9 个选项

1. beforeCreate -> 使用 setup()
1. created -> 使用 setup()
1. beforeMount -> onBeforeMount
1. mounted -> onMounted
1. beforeUpdate -> onBeforeUpdate
1. updated -> onUpdated
1. beforeDestroy -> onBeforeUnmount
1. destroyed -> onUnmounted
1. errorCaptured -> onErrorCaptured
1. activated -> onActivated – 被 keep-alive 缓存的组件激活时调用。
1. deactivated -> onDeactivated – 被 keep-alive 缓存的组件停用时调用。

#### 组件通信

- **父子组件通信**：props 和 $emit；$parent / $children (父子)
- **祖孙组件通信**：$attrs / $listeners（祖孙）
- **兄弟组件通信**：ref / $refs （父子，兄弟）
- **跨级组件通信**：全局事件总线（Event Bus $emit / $on）
- **任意组件通信**：VueX；全局事件总线（Event Bus $emit / $on）

#### 封装组件

- **组件封装原则**：高内聚、低耦合、可重用
- **组件包含**：定义模板、定义需要传递的参数 Props、定义组件数据 data、定义组件方法和回调函数 $emit、注册组件（Vue.component()）

#### 封装 axios

- **封装全局参数**：全局的请求头、响应头等信息，减少重复代码的编写。
- **封装请求拦截器**：可以在请求发送之前对请求进行处理，例如在请求头中添加 token 等信息。
- **封装响应拦截器**：可以在响应返回后对响应进行处理，例如判断响应状态码是否正确，统一处理错误信息等。
- **封装公共方法**：可以将一些通用的请求方法进行封装，例如 get、post、put、delete 等方法。

#### 封装 keep-alive

- **keep-alive**：&lt;keep-alive&gt; 是 Vue.js 中的一个抽象组件，它的主要作用是缓存组件。在一个有大量组件需要频繁切换的页面中，使用 &lt;keep-alive&gt; 可以提高页面的性能，减少因频繁创建和销毁组件而产生的性能消耗。
- **封装方法**：在 Vue 的路由配置中添加 meta 字段，然后在 App.vue 中通过 v-if 进行调用

#### 状态管理 VueX

- **VueX**：VueX 是一个状态管理模式，它是基于 Vue.js 构建的，用于在大型单页面应用程序中管理应用程序的状态。VueX 提供了一个中央存储库，用于保存所有组件的状态，并通过显式的方式将状态传递给组件，从而使组件之间的通信更加容易和高效。
- **核心属性**：store（存储数据的地方）；state（表示状态的数据）；mutation（操作状态的方法，每个 mutation 都有一个字符串类型的事件类型和一个回调函数。）；action（异步操作状态的方法，每个 action 都有一个字符串类型的事件类型和一个回调函数。）；module（模块化管理 state、getters、mutations 和 actions）；getter（类似计算属性，用于从 state 中派生出一些状态。）；
- **store**：状态对象，即存储数据的地方。在 Vue 组件中，可以通过 $store.state 访问到它。
- **state**：表示状态的数据。它是一个响应式对象，用来保存我们的数据。它可以通过直接赋值的方式进行修改。
- **mutation**：操作状态的方法，每个 mutation 都有一个字符串类型的事件类型和一个回调函数。在回调函数中，可以通过第一个参数访问到 state 对象，并通过第二个参数（payload）传递数据。Mutation 必须是同步函数。
- **action**：异步操作状态的方法，每个 action 都有一个字符串类型的事件类型和一个回调函数。回调函数可以接收一个与 store 实例具有相同方法和属性的 context 对象，但不能直接修改 state，需要通过 commit 方法来触发 mutation。Action 可以返回一个 Promise 对象。
- **module**：模块化管理 state、getters、mutations 和 actions。可以将 store 分割成不同的模块，每个模块可以拥有自己的 state、getters、mutations、actions 和子模块。模块内部的 action、mutation 和 getter 等方法仍然注册在全局命名空间下，但 state 却是模块的局部状态，而不是全局状态。
- **getter**：类似计算属性，用于从 state 中派生出一些状态。Getters 可以访问 state 中的属性，也可以接收其他 getters 作为第二个参数。

#### 状态管理 Pinia

- **Pinia**：Pinia 是一个状态管理库
- **核心属性**：store（存储数据的地方）；state（表示状态的数据）；action（表示操作数据，可以执行同步、异步操作）；getter（表示计算属性）。
- **store**：表示状态的存储。它包含了所有状态，例如数据、方法等等。在使用 Pinia 的时候，我们需要定义一个 store，然后把这个 store 暴露出去。
- **state**：表示状态的数据。它是一个响应式对象，用来保存我们的数据。它可以通过直接赋值的方式进行修改。
- **action**：表示同步、异步操作。它们通常用来执行一些异步的操作，例如获取数据等等。在执行异步操作之前，我们可以在 action 中执行一些同步操作，例如修改 state 中的数据。
- **getter**：表示计算属性。它们的作用是根据 store 中的数据，动态地计算出一个值。这些计算属性通常用来派生数据。

#### 路由 Vue-Router

- **Vue 路由**：Vue 路由是 Vue.js 官方提供的一种实现前端页面跳转、刷新、回退等页面管理的机制。它通过监听 URL 变化，匹配路由规则并展示相应的组件，实现了单页应用（SPA）的前端路由功能。
- **Hash**：在 URL 中使用 # 符号来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载。hash 值的改变只会引起浏览器滚动条位置的改变。
- **History**：使用 HTML5 提供的新特性，改变浏览器地址栏的 URL，不会带有 # 符号。当 URL 改变时，页面会重新加载。需要后端支持。
- **切换路由**：通过路由文件里的 mode 进行切换。
- **query**：query 则用于传递可选参数，通常在路由跳转时携带，刷新页面不会丢失，通过\$route.query 获取。
- **params**：params 用于传递必须参数，通常用于动态路由，刷新页面会丢失，通过\$route.params 获取。
- **route**：表示当前的路由信息，包含当前路由的路径、参数、查询参数等信息。
- **router**：表示路由实例，用于实现路由的跳转、监听等功能。
- **路由钩子函数**：

1. **beforeEach**: 在路由跳转之前调用，可以用来做用户权限验证或全局路由拦截等操作。
1. **beforeResolve**: 在路由解析之前调用，在组件被解析之后调用（几乎不使用）。
1. **afterEach**: 在路由跳转完成后调用，可以用来做页面访问统计等操作。
1. **beforeEnter**：在路由进入之前调用。
1. **beforeRouteEnter**: 在路由进入之前调用，但是此时组件实例还未被创建，所以无法访问 this，通常用来做异步数据加载等操作。
1. **beforeRouteUpdate**: 在路由参数更新时调用，可以在此处做异步数据加载等操作。
1. **beforeRouteLeave**: 在离开当前路由时调用，可以用来做页面离开前的数据保存或用户确认等操作。

#### 权限管理

- **路由拦截**：路由拦截是指在路由跳转时，根据用户的角色或权限，判断该用户是否有权访问该路由。可以在路由配置文件中设置 meta 属性，用来存储该路由的访问权限信息，然后在路由跳转前，通过路由守卫进行权限验证，如果没有权限，则跳转到指定的页面。
- **菜单权限**：解析后端返回来的菜单树，如果页面有按钮权限，在 meta 中存放按钮权限、页面 title 等信息；最后存放到 sessionStorage 中。
- **动态渲染**：动态渲染是指根据用户的角色或权限，动态生成页面内容，例如隐藏某些按钮或链接。
- **按钮权限**：可以在组件中通过 v-if 或 v-show 指令根据用户的角色或权限控制组件的显示或隐藏。

### 五、计算机网络

#### TCP 三次握手四次挥手

- **三次握手**：
- **为什么三次**：
- **四次挥手**：
- **为什么四次**：

### 六、浏览器

#### 从输入 URL 到页面展示过程

- **过程概述**：解析 URL -> 缓存判断 -> DNS 解析 -> TCP 三次握手 -> （HTTPS 握手） -> 发送请求 -> 服务器处理请求并返回数据 -> 浏览器解析 HTML 页面并渲染页面 -> TCP 四次挥手
- **DNS 解析**：浏览器首先会检查本地 DNS 缓存，如果没有缓存则向本地 DNS 服务器发起请求，如果本地 DNS 服务器也没有缓存则会向根 DNS 服务器发起请求，根 DNS 服务器返回负责该域名的顶级 DNS 服务器地址，浏览器再向顶级 DNS 服务器发起请求，顶级 DNS 服务器返回该域名对应的 IP 地址。
- **TCP 三次握手**：浏览器使用 HTTP 协议与服务器建立 TCP 连接，建立连接需要三次握手。
- **发送请求**：浏览器向服务器发送请求，包括请求方法、URL、请求头等信息。
- **服务器处理请求并返回数据**：服务器接收到请求后，根据请求的 URL 和参数等信息进行处理，生成相应的 HTML 页面或其他资源文件，并通过 TCP 连接返回给浏览器。
- **浏览器解析 HTML 页面并渲染页面**：浏览器接收到服务器返回的 HTML 页面后，开始解析 HTML 标签和 CSS 样式，构建 DOM 树和 CSSOM 树，然后将两者组合成渲染树，并计算出每个节点的几何信息，最终通过 GPU 绘制页面。
- **TCP 四次挥手**：当浏览器完成页面的渲染后，会关闭 TCP 连接，释放资源。
- **HTTPS 握手**：由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法；服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书；客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验；服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。
- **三次握手**：客户端发起连接请求；服务器端确认连接请求，向客户端发送一个随机序号；客户端进入连接建立的状态，向服务器也发送一个 ACK 确认报文段。服务端接收到后，连接就建立了。三次握手验证了双方的收发功能是否正常。
- **四次挥手**：客户端向服务端发送连接释放请求；服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接，并进入 CLOSE_WAIT 状态；服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态；客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL 时间，若此时没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。
- **优化手段**：

1. 启用浏览器缓存机制，尽可能减少网络请求次数，缓存静态资源。
1. 优化 DNS 解析速度，比如采用 CDN、减少 DNS 查询次数等。
1. 减少 HTTP 请求次数，可以合并 CSS、JS 文件，压缩图片等。
1. 优化服务器响应速度，比如使用缓存、优化数据库查询等。
1. 使用 CDN 等加速服务，将静态资源存放在离用户较近的服务器上，提高资源加载速度。
1. 使用异步加载、懒加载等技术，优化页面加载速度。
1. 减少 JavaScript 的执行时间，尽量减少 DOM 操作和重绘/回流等开销。
1. 优化页面结构，减少 HTML、CSS、JavaScript 的代码量，提高页面渲染速度。
1. 优化图片等资源的大小和格式，减少网络传输开销。

#### 跨域

- **同源策略**：同源策略是浏览器的一种安全策略，它限制了一个源（协议、域名、端口）的文档或脚本如何能够与另一个源的资源进行交互。
- **跨域**：跨域（Cross-Origin）指的是在浏览器的同源策略下，一个网页无法请求另一个网页的资源，即浏览器禁止跨域请求。
- **解决跨域**：CORS 跨域资源共享，服务器添加响应头；JSONP 动态插入一个 script 标签，请求一个带有参数的地址；配置代理；Nginx 反向代理。
- **项目跨域**：配置 Proxy。

#### 异步编程

- **异步编程**：异步编程是一种编程模式，它可以让程序在执行一些需要等待的任务（比如网络请求、文件读写、计时器等）时，不会阻塞主线程的执行，而是在后台进行处理，等待任务完成后再进行相应的处理。异步编程能够提高程序的性能和响应速度，使程序可以更好地利用 CPU 和 I/O 资源。
- **实现方式**：在 JavaScript 中，异步编程可以通过回调函数、Promise 和 async/await 等方式来实现。

#### 事件

- **常见事件**：click（鼠标单击）、mouseover（鼠标移入）、mouseout（鼠标移出）等。
- **绑定事件**：element.addEventListener('click', myFunction);
- **解绑事件**：element.removeEventListener('click', myFunction);
- **事件冒泡**：事件冒泡是指当一个元素触发了某个事件后，该事件会沿着 DOM 树向上传递直到根节点，途中经过的每个父级元素都会被同样触发该事件。比如，一个按钮被点击后，它的点击事件会先被该按钮处理，然后一层层向上冒泡，直到最外层的元素。
- **阻止事件冒泡**：event.stopPropagation()；在事件处理函数中返回 false。
- **事件捕获**：事件捕获是 DOM 事件的一种传播机制，在捕获阶段，事件从最外层的祖先节点向目标节点传播，直到达到目标节点。与事件冒泡不同，事件冒泡是从目标节点开始向祖先节点传播。
- **阻止事件捕获**：使用 event.stopPropagation() 方法来阻止事件传播。
- **异常捕获**：在 JavaScript 中，可以使用 try...catch 语句块来处理异常捕获。
- **事件委托**：事件委托是指将事件处理器添加到其父元素上，而不是直接添加到目标元素上。通过在父元素上捕获事件，然后根据事件的目标确定实际处理程序的方式，从而实现在子元素被添加、删除、移动时，不需要更新事件处理程序的目的。

#### 事件循环

- **事件循环**：简单地说，对于 JS 运行中的任务，JS 有一套处理收集，排队，执行的特殊机制，我们把这套处理机制称为事件循环（Event Loop）。
- **单线程**：JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
- **执行栈**：执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。
- **执行上下文**：执行上下文，又叫做执行环境（全局执行上下文、函数执行上下文、Eval 函数执行上下文）。
- **任务队列**：一个事件循环中，可以有一个或者多个任务队列（task queue），一个任务队列便是一系列有序任务（task）的集合。
- **同步任务**：同步任务是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务，当我们打开网站时，网站的渲染过程，比如元素的渲染，其实就是一个同步任务。
- **异步任务**：异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程，当我们打开网站时，像图片的加载，音乐的加载，其实就是一个异步任务。
- **宏任务**：script（整体代码）、setTimeout、setInterval、UI 交互事件等
- **微任务**：Promise.then()、Promise.catch()、process.nextTick

#### this 绑定

- **this**：在 JavaScript 中，this 是一个关键字，用来指向当前函数的上下文对象。this 的指向会根据函数的调用方式而变化。
- **this 绑定**：有四种常见绑定方式
  1. **默认绑定**：当函数直接调用时，this 指向全局对象（非严格模式）或 undefined（严格模式）。
  1. **隐式绑定**：当函数作为对象的方法调用时，this 指向该对象。
  1. **显示绑定**：当使用 call、apply 或 bind 方法时，可以显式指定函数的 this 指向。
  1. **new 绑定**：当使用 new 关键字调用构造函数时，this 指向新创建的对象。
- **修改 this 绑定**：在 JavaScript 中，有几种方法可以改变函数的 this 指向，包括 call()、apply()、bind() 和 使用变量保存 this 四种方式。
  1. **call()**：将函数中的 this 指向指定的对象，并立即执行函数。第一个参数是指定的对象，后续多个参数逗号隔开。
  1. **apply()**：将函数中的 this 指向指定的对象，并立即执行函数。第一个参数是指定的对象，后续多个参数使用数组或者类数组传递。
  1. **bind()**：它改变函数的 this 指向时不会立即执行函数，而是返回一个新的函数，需要调用返回的函数才能执行原来的函数。

### 七、NodeJS

#### V8 垃圾回收机制

- **垃圾回收机制**：V8 垃圾回收机制是一种内存自动管理技术，它能够检测和清除不再使用的对象，以释放内存并避免内存泄漏。由于 JavaScript 语言的特性，它是一种垃圾回收语言，需要借助于垃圾回收机制来管理内存，以避免内存泄漏等问题。
- **新生代**：新生代内存空间的大小为 32MB，由于新生代内存空间比较小，因此 V8 使用了更为轻量级的 Scavenge GC 算法。在 Scavenge 的具体实现中，主要采用 Cheney 算法。
- **新生代算法**：Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。
- **老生代**：老生代内存空间的大小为 1.4GB，因此 V8 使用了更为复杂的垃圾回收算法。
- **老生代算法**：老生代中的对象一般存活时间较长且数量也多，主要使用了两个算法，分别是**标记清除算法**和**标记压缩算法**。

老生代具体算法

1. **标记清除算法**（Mark-Sweep）：从根对象出发，标记所有活动对象，然后将未标记的对象清除。（会产生内存碎片）
1. **标记压缩算法**（Mark-Compact）：与标记清除算法类似，但在清除时会压缩对象空间，将活动对象向一端移动，另一端为空闲空间。（需要更多的时间来压缩内存）
1. **增量标记算法**（Incremental Marking）：将垃圾回收过程分成多个阶段，在阶段间插入程序执行，减小了每个阶段的停顿时间，提高了程序的响应性能。（可能会导致垃圾回收时间更长）
1. **延迟清理算法**（lazy sweeping）将垃圾回收的时间推迟，直到内存资源不足时再进行回收。它适用于大量的短期对象，可以避免频繁的垃圾回收，提高了程序的性能。（会导致内存占用更高）

#### 内存泄漏

- **内存泄漏**：内存泄露指的是应用程序中的内存被错误地分配或使用，导致内存不能被及时地释放或回收，最终导致内存资源的浪费或耗尽的现象。当内存泄露严重时，会导致应用程序运行缓慢或崩溃。
- **造成原因**：没有及时清理不再使用的对象和变量；定时器和回调函数未清理；循环引用；不当使用闭包。
- **如何避免**：及时清理不再使用的对象和变量（赋值为 null）；避免循环引用；清理定时器和回调函数。

#### 内存溢出

- **内存溢出**：内存溢出是指程序在申请内存时，没有足够的内存可供使用，导致操作系统分配给程序的内存空间不足，出现异常情况，例如程序崩溃、运行变慢等现象。
- **造成原因**：内存泄漏导致内存占用增加；递归调用、数据库连接未关闭等。
- **如何避免**：及时释放无用的对象和变量；避免无限递归调用；及时关闭数据库连接。

### 八、性能优化

#### 前端性能指标

#### 前端性能优化

### 九、React

#### 生命周期

#### 组件通信

#### 虚拟 DOM

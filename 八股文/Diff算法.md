<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-01 22:32:15
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-02 01:28:44
 * @Description: 八股文：DIFF 算法（3题）
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\Diff算法.md
-->

#### DIFF 算法的原理？

Diff 算法是 虚拟 DOM（Virtual DOM） 的核心算法，用于比较两个 虚拟 DOM（Virtual DOM） 树的差异，并将差异应用到实际 DOM 上，从而实现高效的视图更新。

Diff 算法的原理如下：

1. 对比新旧节点是否是同一个节点，如果不是则直接将新节点替换旧节点，结束这个节点的对比，开始对比下一个节点。
1. 如果新旧节点是同一个节点，那么对比它们的子节点：
   a. 如果新旧节点都没有子节点，则认为它们是相等的，不需要更新。
   b. 如果新节点没有子节点，但是旧节点有子节点，则将旧节点的子节点全部删除。
   c. 如果旧节点没有子节点，但是新节点有子节点，则将新节点的子节点全部添加到旧节点中。
   d. 如果新旧节点都有子节点，则递归调用 Diff 算法，对比它们的子节点。
1. 对比新旧节点的属性是否有变化，如果有变化，则更新属性。
1. 对比新旧节点的子节点列表是否有变化，如果有变化，则更新子节点列表。

通过以上步骤，Diff 算法能够找出新旧节点的差异，从而高效地更新视图。

需要注意的是，Diff 算法并不是完全精确的，它只能找到最小的差异，并尽可能地减少对实际 DOM 的操作次数。因此，在实际开发中，需要合理地设计组件结构，减少不必要的 Diff 计算，提高性能。

#### Vue 中 key 的作用？

vue 中 key 值的作用可以分为两种情况来考虑：

- 第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。
- 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。

key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速

1. 更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。
1. 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快

#### Vue3 Diff 算法和 Vue2 的区别？

我们知道在数据变更触发页面重新渲染，会生成虚拟 DOM 并进行 patch 过程，这一过程在 Vue3 中的优化有如下

编译阶段的优化：

1. **事件缓存**：将事件缓存（如: @click），可以理解为变成静态的了
1. **静态提升**：第一次创建静态节点时保存，后续直接复用
1. **添加静态标记**：给节点添加静态标记，以优化 Diff 过程

由于编译阶段的优化，除了能更快的生成虚拟 DOM 以外，还使得 Diff 时可以跳过"永远不会变化的节点"，

Diff 优化如下

1. Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff
1. 使用最长递增子序列优化了对比流程

根据尤大公布的数据就是 Vue3 update 性能提升了 1.3~2 倍

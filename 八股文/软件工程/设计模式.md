<!--
 * @Author: Shu Binqi
 * @Date: 2023-03-08 17:36:39
 * @LastEditors: Shu Binqi
 * @LastEditTime: 2023-03-09 23:37:55
 * @Description: 八股文：设计模式
 * @Version: 1.0.0
 * @FilePath: \interviewQuestions\八股文\软件工程\设计模式.md
-->

#### 设计模式是什么？

设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF 设计模式」。

#### 前端设计模式是什么？

前端设计模式是一组用于前端开发的通用解决方案，它们可以帮助开发人员更好地组织和管理前端代码。设计模式是在软件工程中广泛使用的，但在前端开发中也有很多常见的设计模式。

以下是几个常见的前端设计模式：

1. **MVC**（Model-View-Controller）模式：MVC 是一种常用的设计模式，用于组织前端应用程序的代码结构。它将应用程序分为三个部分：模型（Model）、视图（View）和控制器（Controller），每个部分都具有不同的责任和功能。
1. **观察者模式**：观察者模式是一种基于事件的模式，用于实现对象之间的松散耦合。在观察者模式中，一个对象（称为主题）维护一组观察者对象，并在其状态发生变化时通知它们。
1. **工厂模式**：工厂模式是一种创建型模式，用于创建对象而不需要显式地指定它们的类。在工厂模式中，一个工厂对象负责创建其他对象，这些对象可能属于同一类或不同的类。
1. **单例模式**：单例模式是一种创建型模式，用于确保类只有一个实例，并提供一种全局访问点以访问该实例。在单例模式中，一个类只能有一个实例，并提供一种机制以访问该实例。

这些设计模式可以帮助开发人员更好地组织和管理前端代码，从而使代码更加可维护、可重用和可扩展。

#### 前端常见设计模式有哪些？

在前端开发中，常见的设计模式有以下 23 种：

1. **工厂模式**：工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。
1. **抽象工厂模式**：抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。
1. **单例模式**：单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。
1. **建造者模式**（构建者模式）：建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。
1. **原型模式**：原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。
1. **适配器模式**：适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。
1. **装饰器模式**：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。
1. **代理模式**：在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。
1. **外观模式**：外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。
1. **桥接模式**：桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
1. **组合模式**：组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。
1. **享元模式**：享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。
1. **策略模式**：在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。
1. **模板方法模式**：在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
1. **观察者模式**：当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。
1. **迭代子模式**：迭代器模式（Iterator Pattern）是 Java 和 \.Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
1. **责任链模式**：顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。
1. **命令模式**：命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
1. **备忘录模式**：备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。
1. **状态模式**：在状态模式（State Pattern）中，类的行为是基于它的状态改变的。
1. **访问者模式**：在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。
1. **中介者模式**：中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。
1. **解释器模式**：解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

以上是常见的前端设计模式，不同的设计模式可以帮助我们在不同场景下更加灵活和高效地开发。

#### 简单说说你对观察者模式的理解？以及它的优缺点？

观察者模式（Observer Pattern）是一种常见的设计模式，它用于对象之间的一对多依赖关系，当一个对象发生变化时，它的所有依赖对象都会收到通知并自动更新。这种设计模式可以有效地解耦对象之间的关系，提高代码的灵活性和可维护性。

在观察者模式中，有两个重要的角色：观察者和被观察者。被观察者维护一个观察者列表，并提供注册和删除观察者的接口；观察者则定义了在被观察者发生变化时所要执行的操作。当被观察者发生变化时，它会依次通知所有的观察者，并将变化的信息传递给它们。观察者可以根据变化的信息来执行相应的操作，例如更新 UI 界面或者改变对象的状态等。

观察者模式的优点包括：

1. **低耦合**：观察者模式可以将对象之间的关系解耦，使得它们可以独立地进行修改和维护，提高代码的灵活性和可维护性。
1. **可扩展性**：观察者模式允许动态地添加和删除观察者，因此可以轻松地扩展功能。
1. **通信效率高**：观察者模式可以实现对象之间的高效通信，避免了无谓的轮询操作，提高了通信效率。

观察者模式的缺点包括：

1. **内存泄漏**：如果观察者没有被正确地移除，它可能会一直存在于观察者列表中，导致内存泄漏。
1. **性能问题**：当观察者数量较多时，通知所有观察者的过程可能会影响系统的性能。

#### 简单说说你对发布订阅模式的理解？

发布订阅模式（Publish/Subscribe Pattern）是一种常见的设计模式，它用于解决多个对象之间的一对多依赖关系。在发布订阅模式中，发布者（或称为消息中心）负责向订阅者（或称为观察者）发布消息，而订阅者则可以自由地订阅和取消订阅感兴趣的消息，以便在消息发布时及时接收到通知。

在发布订阅模式中，有三个主要的角色：发布者、订阅者和消息中心。发布者负责发布消息，它将消息发送到消息中心，而消息中心则负责将消息传递给所有订阅者。订阅者可以自由地订阅和取消订阅感兴趣的消息，以便在消息发布时及时接收到通知。

发布订阅模式的优点包括：

1. **低耦合**：发布订阅模式可以将对象之间的关系解耦，使得它们可以独立地进行修改和维护，提高代码的灵活性和可维护性。
1. **可扩展性**：发布订阅模式允许动态地添加和删除订阅者，因此可以轻松地扩展功能。
1. **通信效率高**：发布订阅模式可以实现对象之间的高效通信，避免了无谓的轮询操作，提高了通信效率。

发布订阅模式的缺点包括：

1. **运行效率问题**：发布订阅模式需要维护订阅者列表和消息中心，因此在运行效率上可能会有一定的开销。
1. **异常处理问题**：由于发布订阅模式采用异步通信方式，因此在出现异常情况时可能需要额外的处理，以保证系统的稳定性和可靠性。

#### 观察者模式与发布订阅的区别？

观察者模式和发布订阅模式都是用于解决对象之间的依赖关系的设计模式，它们的主要区别在于以下几个方面：

1. **组织形式**：观察者模式中，观察者直接订阅被观察者，而发布订阅模式中，订阅者不直接订阅发布者，而是通过消息中心来进行订阅和发布。
1. **耦合度**：观察者模式中，被观察者和观察者之间是强耦合的，因为它们之间存在直接的引用关系。而在发布订阅模式中，发布者和订阅者之间是松耦合的，它们之间并没有直接的引用关系。
1. **通信机制**：观察者模式中，被观察者直接通知观察者，通常是同步的方式。而在发布订阅模式中，发布者和订阅者之间的通信是通过消息中心进行的，通常是异步的方式。
1. **消息内容**：观察者模式中，被观察者和观察者之间通常是传递特定的数据或事件对象。而在发布订阅模式中，发布者和订阅者之间传递的消息是通用的消息，可以携带任何数据。

综上所述，观察者模式和发布订阅模式在组织形式、耦合度、通信机制和消息内容等方面存在一定的差异。在具体应用中，需要根据实际情况选择适合的设计模式。

#### 设计模式的六大原则（SOLID）？

总原则——**开闭原则**（Open Closed Principle）

一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。

在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

想要达到这样的效果，我们需要使用接口和抽象类等。

1. **单一职责原则**（Single Responsibility Principle）

一个类应该只有一个发生变化的原因。
不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。

2. **里氏替换原则**（Liskov Substitution Principle）

所有引用基类的地方必须能透明地使用其子类的对象。
任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

3. **依赖倒置原则**（Dependence Inversion Principle）

- 上层模块不应该依赖底层模块，它们都应该依赖于抽象。
- 抽象不应该依赖于细节，细节应该依赖于抽象。
  面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

4. **接口隔离原则**（Interface Segregation Principle）

- 客户端不应该依赖它不需要的接口。
- 类间的依赖关系应该建立在最小的接口上。
  每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

5. **迪米特法则**（最少知道原则）(Law of Demeter)

只与你的直接朋友交谈，不跟“陌生人”说话。
一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

6. **合成复用原则**（Composite Reuse Principle）

尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。
合成或聚合可以将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。

记忆口诀：SOLID CD（稳固的 CD）。

#### 设计模式中的三大类？

设计模式的三大类

1. **创建型模式**（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。

（5 种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式

记忆口诀：创工原单建抽（创公园，但见愁）

2. **结构型模式**（Structural Pattern）：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。

（7 种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式

记忆口诀：结享外组适代装桥（姐想外租，世代装桥）

3. **行为型模式**（Behavioral Pattern）：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。

（11 种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

记忆口诀：行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）
